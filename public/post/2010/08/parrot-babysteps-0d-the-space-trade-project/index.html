<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
    










    







<script defer language="javascript" type="text/javascript" src="/js/bundle.min.60856f0f2ed73fb3cd2820ee548c4698ffbc4d743736e852c0e27ce4f52dfd9c.js"></script>






    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    <link rel="icon" href=/favicon.png>

    
    





  





  
  
  

<meta property="og:url" content="https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/">
<meta property="og:title" content="Parrot Babysteps 0d - The SpaceTrade Project">
<meta name="twitter:title" content="Parrot Babysteps 0d - The SpaceTrade Project">


  <meta name="twitter:site" content="@brianwisti">



  
    <meta name="twitter:description" content="I might be done with the Stellar application for the moment, but I don&rsquo;t think I&rsquo;m done with the space theme in Parrot yet.
Back in the ancient days, there was a nifty game called Star Trader. You and your friends were interstellar merchants trying to earn a few credits (or whatever) in a cold and uncaring universe. Star Trader has had many popular descendants, which have evolved over the generations into games like Trade Wars Rising, Oolite and Eve Online.">
    <meta property="og:description" content="I might be done with the Stellar application for the moment, but I don&rsquo;t think I&rsquo;m done with the space theme in Parrot yet.
Back in the ancient days, there was a nifty game called Star Trader. You and your friends were interstellar merchants trying to earn a few credits (or whatever) in a cold and uncaring universe. Star Trader has had many popular descendants, which have evolved over the generations into games like Trade Wars Rising, Oolite and Eve Online.">
  



<title itemprop="name">Parrot Babysteps 0d - The SpaceTrade Project - Random Geekery</title>
<meta property="og:title" content=Parrot&#32;Babysteps&#32;0d&#32;-&#32;The&#32;SpaceTrade&#32;Project&#32;-&#32;Random&#32;Geekery />
<meta name="twitter:title" content=Parrot&#32;Babysteps&#32;0d&#32;-&#32;The&#32;SpaceTrade&#32;Project&#32;-&#32;Random&#32;Geekery />
<meta itemprop="name" content=Parrot&#32;Babysteps&#32;0d&#32;-&#32;The&#32;SpaceTrade&#32;Project&#32;-&#32;Random&#32;Geekery />
<meta name="application-name" content=Parrot&#32;Babysteps&#32;0d&#32;-&#32;The&#32;SpaceTrade&#32;Project&#32;-&#32;Random&#32;Geekery />
<meta property="og:site_name" content="Random Geekery" />


<meta name="description" content="" />
<meta itemprop="description" content="" />
<meta property="og:description" content="" />
<meta name="twitter:description" content="" />


<base href="https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/" />
<link rel="canonical" href="https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/" itemprop="url" />
<meta name="url" content="https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/" />
<meta name="twitter:url" content="https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/" />
<meta property="og:url" content="https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/" />


<meta property="og:updated_time" content=2008-02-12T80:00:10-0700 />


<link rel="sitemap" type="application/xml" title="Sitemap" href='https://randomgeekery.org/sitemap.xml' />

  <link
      rel="alternate"
      type="application/rss+xml"
    
        href="/index.xml"
    
      title="Random Geekery"/>



<meta name="robots" content="index,follow" />
<meta name="googlebot" content="index,follow" />


<meta name="twitter:site" content="" />
<meta name="twitter:creator" content="" />
<meta property="fb:admins" content="" />


<meta name="apple-mobile-web-app-title" content="Random Geekery" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />






<meta name="generator" content="Hugo 0.121.2">


    
    

<link
    rel="stylesheet"
    href="/css/style.fe9735814e6394fb590ff4fd2eb036a13152e6808ad90dd06ba181d89087b5d3.css"
    integrity="sha256-/pc1gU5jlPtZD/T9LrA2oTFS5oCK2Q3Qa6GB2JCHtdM=" 
    crossorigin="anonymous">


</head>

    <body class="">
        <div class="wrapper">
            <aside class="sidebar">
    <div class="container sidebar-sticky">
        <div class="light-dark" align="right">
    <button class="btn-light-dark" title="Toggle light/dark mode">
        <svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M6 .278a.768.768 0 0 1 .08.858a7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277c.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316a.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71C0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
        </svg>
        <svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M8 12a4 4 0 1 0 0-8a4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
        </svg>
    </button>
</div>

        <div class="sidebar-about">
    <h1 class="brand">
        
        
            <a href="https://randomgeekery.org">
                <h1>Random Geekery</h1>
            </a>
        
    </h1>
    <p class="lead">
    Collecting my attempts to improve at tech, art, and life
    </p>
</div>

        <nav>
    <ul class="sidebar-nav">
      
        <li class="bullet">
          <a href="/follow/">Follow</a>
        </li>
      
        <li class="bullet">
          <a href="/now/">Now</a>
        </li>
      
    </ul>
</nav>

        
  <div class="related">
    <div class="related-posts">
      <h3>Related</h3>
      <ul>
        
          <li><a href="/post/2010/10/parrot-babysteps-0e-parrot-namespaces/">Parrot Babysteps 0e - Parrot Namespaces</a></li>
        
          <li><a href="/post/2010/07/parrot-babysteps-0x-the-stellar-app/">Parrot Babysteps 0c - The Stellar App</a></li>
        
          <li><a href="/post/2010/06/parrot-babysteps-0b-subroutine-params/">Parrot Babysteps 0b - Subroutine Params</a></li>
        
          <li><a href="/post/2010/06/parrot-babysteps-0a-the-stellar-project/">Parrot Babysteps 0a - The Stellar Project</a></li>
        
          <li><a href="/post/2010/04/parrot-babysteps-09-simple-projects/">Parrot Babysteps 09 - Simple Projects</a></li>
        
      </ul>
    </div>
  </div>



        
















        <p class="footnote">
powered by <a target="_blank" href="https://gohugo.io">Hugo</a> | themed with <a target="_blank" href="https://github.com/lukeorth/poison">poison</a>
    <br>
    &copy; 2024 Brian Wisti. All rights reserved.
</p>
<p class="footnote">
  This work is licensed under a
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    Creative Commons Attribution 4.0 International License
  </a>.
</p>

  </div>
</aside>

            <main class="content container">
                <div class="post">
  <nav class="masthead">
    <ul>
    
  
    
  
    
  
    
  

    <li><a href="https://randomgeekery.org/">Random Geekery</a></li>
  

    <li><a href="https://randomgeekery.org/post/">Posts</a></li>
  

    <li><a href="https://randomgeekery.org/post/2010/">2010</a></li>
  

    <li><a class="active" href="https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/">Parrot Babysteps 0d - The SpaceTrade Project</a></li>
</nav>



  <div class="info">
    <h1 class="post-title">
        <a href="https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/">Parrot Babysteps 0d - The SpaceTrade Project</a>
    </h1>
    
        <time datetime="2010-08-02T00:00:00-0700" class="post-date">
            August 2, 2010
        </time>
    
    
    <ul class="tags">
        
        <li class="tag-parrot">
            <a href="https://randomgeekery.org/tags/parrot">parrot</a>
        </li>
        
        <li class="tag-learn">
            <a href="https://randomgeekery.org/tags/learn">learn</a>
        </li>
        
        <li class="tag-coolnamehere">
            <a href="https://randomgeekery.org/tags/coolnamehere">coolnamehere</a>
        </li>
        
    </ul>
    
    
    
    
        <p class="seriesname">
            Series: <a href="https://randomgeekery.orgseries/">[Parrot Babysteps]</a>
        </p>
    
    
    
</div>

  <p>I might be done with the <a href="/post/2010/07/parrot-babysteps-0c-the-stellar-app/">Stellar</a> application for the moment, but I
don&rsquo;t think I&rsquo;m done with the space theme in <a href="/card/parrot/">Parrot</a> yet.</p>
<p>Back in the ancient days, there was a nifty game called <a href="https://en.wikipedia.org/wiki/Star_Trader">Star Trader</a>. You and your friends were
interstellar merchants trying to earn a few credits (or whatever) in a cold and uncaring universe. Star Trader
has had <em>many</em> popular descendants, which have evolved over the generations into games like <a href="http://tradewarsrising.com">Trade Wars Rising</a>,
<a href="http://www.oolite.org/">Oolite</a> and <a href="http://eveonline.com">Eve Online</a>. Those games are interactive and fun and great ways to kill many hours, but I&rsquo;ve
got an itch for something old school. I want to revisit the joy of a text interface that demands your
imagination work overtime while you figure out what is going on.</p>
<p>It is possible that I have been playing <a href="http://www.bay12games.com/dwarves/">Dwarf Fortress</a> a little bit too much for my own good.</p>
<p>This one is going to take some work. It is a fairly elaborate game. The map is random, markets change, and
merchants can be haggled with. I can use the <a href="https://web.archive.org/web/20131222221016/http://www.dunnington.u-net.com/public/basicgames/TRADES">original code</a> as a resource, but not very well. The listing I
could find was written in a HP-BASIC dialect that I am unfamiliar with. So I have to do more than just copy
the game. I&rsquo;ll have to make a game inspired by Star Trader instead. That seems to be what all the cool kids
are doing - assuming you use a rather flexible definition of &ldquo;cool.&rdquo;</p>
<p>I talked about using a text interface, but I know that eventually I will want to choose my own interface for
the game. Players can choose their own approach, and bored coders will be able to create new ones. I will
start by keeping the game logic as abstract as I can, and worry about the details of play later.</p>
<h2 id="spacetrade-summary">SpaceTrade Summary</h2>
<p>Space Trade is a turn-based game in which one or more players assumes the role of an interstellar merchant in
the future. The game has a fixed number of turns, determined during game setup. Players are competing to have
a pilot with the highest worth at the end of the game. The single player goal is to beat her own previous
high scores.</p>
<p>Game play occurs on a map of star systems. Each star system has a trade classification, which makes the price
of goods vary from one system to the next. There is a port in every system for traders to buy and sell goods,
or to upgrade their ship&rsquo;s capabilities. Traders may attempt to haggle for a more favorable price, but this
might not work. As the game progresses, markets may change based on trade activity. A glut of a particular
good could temporarily reduce its value, or a run on that good could temporarily increase its value.</p>
<p>Traders may encounter hazards such as planetoids or pirates while travelling between systems. The results of
these encounters could be cargo loss or damage to the trader&rsquo;s ship. If a ship accumulates enough damage
without repair, it could be destroyed. Destruction of a ship ends the game for that trader.</p>
<h3 id="development-tasks">Development Tasks</h3>
<p>My summary is a little vague compared to your average game, but there are a lot of juicy programming tasks in
there.</p>
<ul>
<li>Creating a star</li>
<li>Building a star map</li>
<li>Creating a new trader</li>
<li>Buying cargo</li>
<li>Selecting and travelling to a new system</li>
<li>Selling cargo</li>
<li>Dealing with changing markets</li>
<li>Haggling with merchants</li>
<li>Coping with environmental hazards (pirates, planetoids, etcetera)</li>
<li>Enabling multiple players</li>
<li>Upgrading a ship</li>
<li>Scoring the endgame</li>
<li>Tracking high scores</li>
<li>Saving a game in play</li>
<li>Loading a saved game</li>
</ul>
<p>At each stage, we will work on the simple text interface and add randomization to make gameplay interesting.</p>
<p>I have never written a game in Parrot before. I have not written many games in <em>any</em> language. I understand if
one of your questions is &ldquo;why not use language X?&rdquo; - where <em>X</em> is Python, Perl, Ruby, Rakudo, D, or something
else. I might use language X another time, but then it would be part of the X Babysteps rather than the Parrot
Babysteps.</p>
<p>Another question might be &ldquo;Are we <em>ever</em> going to use Parrot to write a language?&rdquo; Actually, yes. I&rsquo;m going to
put together a simple script language that handles game behavior. Not a powerful megasmart language for high
end projects, but something for building the star map and playing the game itself. It will be used for saving
and sharing games, and inevitably for hacking game details. Hey, what fun is a game if you can&rsquo;t hack it?</p>
<p>That&rsquo;s three more on-going development tasks, then:</p>
<ul>
<li>Developing an interactive user shell</li>
<li>Randomizing game play elements</li>
<li>Creating a game scripting language</li>
</ul>
<p>This is more complex than Stellar, and it will take more than a few steps to
finish it. I am certain there will be a lot of new Parrot territory to explore.</p>
<p>This should be fun. Let&rsquo;s get started!</p>
<h2 id="setting-up-the-project">Setting up the project</h2>
<p>Thanks to Stellar, I already know how I like to prepare my workspace for a new
project.  The setup from <a href="/post/2010/04/parrot-babysteps-09-simple-projects/">Step 09</a> will provide the starting point for
SpaceTrade.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mkdir spacetrade
$ mkdir spacetrade/t
$ mkdir spacetrade/lib
$ cd spacetrade</code></pre>
</figure><p>The <code>setup.pir</code> script will start out the same as the one used for Stellar.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-01/setup.pir
.sub &#39;main&#39; :main
    .param pmc args
    $S0 = shift args # Ignore my own filename
    load_bytecode &#39;distutils.pbc&#39;

    # find out what command the user has issued.
    .local string directive
    directive = shift args

    # Used by test mode
    .local string prove_exec
    prove_exec = get_parrot()

    setup(directive, &#39;prove_exec&#39; =&gt; prove_exec)
.end</code></pre>
</figure><p>There is one basic feature I want to get out of the way before I start handling game logic. User interaction
is important. Oh sure, there may eventually be interfaces in <a href="https://github.com/parrot/parrot/blob/master/runtime/parrot/library/Curses.pir">Curses</a> or <a href="https://github.com/parrot/parrot/tree/master/runtime/parrot/library/SDL">SDL</a>, but all that&rsquo;s needed for
now is a simple command line <a href="http://en.wikipedia.org/wiki/Shell_%28computing%29">shell</a>. This shell will be used to examine the nuts and bolts of SpaceTrade
and to play a simple text-based version of the game.</p>
<h3 id="the-spacetrade-interactive-shell">The SpaceTrade Interactive Shell</h3>
<p>I believe that every interactive shell needs a few minimal components to be useful.</p>
<ul>
<li>A command to quit</li>
<li>A command to get help</li>
<li>A reasonable way to handle invalid input</li>
</ul>
<p>A sample session with such a minimal shell might look like this:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot lib/spacetrade.pir
Welcome to SpaceTrade!
Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.
&gt; waffles!
Unknown command: waffles!
Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.
&gt; :help
COMMANDS
:help    This view
:quit    Exit the shell
&gt; :quit
Goodbye!
$</code></pre>
</figure><p>Why do I imagine this shell having commands prefixed by a <code>:</code> character? Well, &ldquo;normal&rdquo; commands would look
normal, but behavior like getting help or quitting the game are only important for dealing with the shell.
I want those special shell commands to look different from the normal game commands.</p>
<p>Of course, I may change my mind later. I am fickle.</p>
<p>What is the smallest amount of code I can use to get this end result and still feel comfortable?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-01/lib/spacetrade.pir
.sub &#39;main&#39; :main
    run_shell()
.end

.sub run_shell
    .local string input
    .local pmc    stdin
    .const string PROMPT     = &#39;&gt; &#39;
    .const string QUICK_HELP = &#34;Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.&#34;

    stdin = getstdin

    say &#34;Welcome to SpaceTrade!&#34;
    say QUICK_HELP

  READLINE:
    input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if input == &#39;:quit&#39; goto EXIT
    if input == &#39;:help&#39; goto SHOW_USAGE
    goto SHOW_ERROR

  SHOW_USAGE:
    say &#34;COMMANDS&#34;
    say &#34;:help    This view&#34;
    say &#34;:quit    Exit the shell&#34;
    goto READLINE

  SHOW_ERROR:
    .local string error_message
    error_message = &#34;Unknown command: &#34;
    error_message .= input
    say error_message
    say QUICK_HELP
    goto READLINE

  EXIT:
    say &#34;Goodbye!&#34;
.end</code></pre>
</figure><p>This works, but it doesn&rsquo;t look right.</p>
<p>For a start, the commands are kind of a mess. When I add commands, I will have to add both an <code>if</code> check in the
<code>READLINE</code> section and a line of output in the <code>SHOW_USAGE</code> section. Then there are the blocks I would have to
add to provide that actual functionality. No, I do not like this at all. The shell commands should be better
organized so that adding and managing features is as easy as possible.</p>
<p>One approach would be to add a registry which stores the commands recognized by the shell.</p>
<h3 id="creating-a-command-registry">Creating a Command Registry</h3>
<p>The idea is that I could have a simple structure that stores information about available commands, and the
application could add commands as needed. Let&rsquo;s start with a simple Hash and two subroutines for adding and
evaluating shell commands.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-02/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(1)

    .local pmc    commands
    .local string expected
    .local string output

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)
    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)
.end

.sub say_dude
    .return(&#34;Dude!&#34;)
.end</code></pre>
</figure><p>The first sub that&rsquo;s needed is <code>register_command</code>, which will add a <code>:dude</code> entry in the <code>commands</code> Hash with
appropriate information.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-02/lib/spacetrade.pir

.sub register_command
    .param pmc    commands
    .param string name
    .param string sub_name
    .param string explanation

    .local pmc    command
    .local pmc    callback

    command = new &#39;Hash&#39;
    command[&#39;sub_name&#39;] = sub_name
    command[&#39;explanation&#39;] = explanation
    commands[name] = command

  RETURN_COMMANDS:
    .return(commands)
.end</code></pre>
</figure><p>There is no special magic going on here. <code>command[':dude']</code> points to a Hash containing a subroutine name and
an explanation of the command. <code>commands</code> is returned to the caller once the new command has been added.</p>
<p>You can probably figure out what I expect to happen from the test code. I have
a <code>say_dude</code> sub, and somehow I expect the shell to figure out how to call that
sub when I ask for it by sending the <code>:dude</code> command. We&rsquo;ve actually already
done this, back when we were grabbing the <code>chomp</code> sub in <a href="/post/2009/10/parrot-babysteps-06-files-and-hashes/">step 06</a>.
The <code>get_global</code> <a href="http://docs.parrot.org/parrot/latest/html/src/ops/var.ops.html">variable opcode</a> will look for a variable with a specified
name and return it to us if it exists.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-02/lib/spacetrade.pir
.sub evaluate_command
    .param pmc    commands
    .param string name

    .local string sub_name
    .local pmc    command_sub
    .local string output

    sub_name = commands[name;&#39;sub_name&#39;]
    command_sub = get_global sub_name
    output = command_sub()

    .return(output)
.end</code></pre>
</figure><p>There is one new bit of strangeness here, though:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >sub_name = commands[name;&#39;sub_name&#39;]</code></pre>
</figure><p>This is called a &ldquo;complex key,&rdquo; and lets us directly access the values in the Hash held at <code>commands[name]</code>.
Each index in a complex key is separated by a semicolon (<code>;</code>) character.  Without a
complex key, we might have to do something like this:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$P1 = commands[name]
sub_name = $P1[&#39;sub_name&#39;]</code></pre>
</figure><p>I did not realize I could use a complex key until I scanned the <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch04_variables.pod.html">variables chapter</a> of the Parrot PIR Book.
It is important to keep reviewing documentation, even if you think you already know a solution. Remember:
regardless of what you know, there is probably a better way.</p>
<p>It is time to add basic error handling to the shell. <code>evaluate_command</code> needs to handle two major error cases.</p>
<ol>
<li>User tries a command that doesn&rsquo;t exist</li>
<li>User tries a command that points to a nonexistent subroutine.</li>
</ol>
<p>Okay, let&rsquo;s add the tests.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-03/t/01-shell-metacommands.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(3)

    .local pmc    commands
    .local string expected
    .local string output

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)
    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)

    expected = &#34;Unknown command: :sweet&#34;
    output = evaluate_command(commands, &#39;:sweet&#39;)
    is(output, expected, &#39;Shell should warn about unknown commands&#39;)

    commands = register_command(commands, &#39;:whats-mine-say&#39;, &#39;whats_mine_say&#39;, &#34;What&#39;s mine say?&#34;)
    expected = &#34;Invalid command: :whats-mine-say points to nonexistent sub whats_mine_say&#34;
    output = evaluate_command(commands, &#39;:whats-mine-say&#39;)
    is(output, expected, &#39;Shell should warn about invalid commands&#39;)
.end

# ...</code></pre>
</figure><p><code>evaluate_command</code> is a little more complicated now, but it is still manageable.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-03/lib/spacetrade.pir

# ...

.sub evaluate_command
    .param pmc    commands
    .param string name

    .local string sub_name
    .local pmc    command_sub
    .local string output

    sub_name = commands[name;&#39;sub_name&#39;]
    unless sub_name goto UNKNOWN_COMMAND
    command_sub = get_global sub_name
    if_null command_sub, INVALID_COMMAND
    output = command_sub()
    goto RETURN_OUTPUT

  UNKNOWN_COMMAND:
    output = &#34;Unknown command: &#34; . name
    goto RETURN_OUTPUT

  INVALID_COMMAND:
    output = &#34;Invalid command: &#34; . name
    output .= &#34; points to nonexistent sub &#34;
    output .= sub_name

  RETURN_OUTPUT:
    .return(output)
.end

# ...</code></pre>
</figure><p>One thing that might catch your attention is the <code>if_null</code> opcode.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >if_null command_sub, INVALID_COMMAND</code></pre>
</figure><p>This will check if <code>command_sub</code> is null, and branch to <code>INVALID_COMMAND</code> if
the subroutine we just tried to grab is indeed null. To be perfectly honest
with you, I&rsquo;m not sure if a branch is the same as a <code>goto</code>. It behaves the same
in this code, so for now I will pretend that it is the same.</p>
<h3 id="setting-up-those-default-shell-commands">Setting Up Those Default Shell Commands</h3>
<p>This ends up working pretty much the same as the earlier code did, and it&rsquo;s a
bit more flexible. Is this how we make programming languages in Parrot? Well,
no. This is not how we make programming languages in Parrot. This is a very
simple shell which will have a few simple commands, but try to pass everything
else off to the game itself. Proper language development is still a few
Babysteps away.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-04/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(5)

    .local pmc    commands
    .local string expected
    .local string output

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)
    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)

    expected = &#34;Unknown command: :sweet&#34;
    output = evaluate_command(commands, &#39;:sweet&#39;)
    is(output, expected, &#39;Shell should warn about unknown commands&#39;)

    commands = register_command(commands, &#39;:whats-mine-say&#39;, &#39;whats_mine_say&#39;, &#34;What&#39;s mine say?&#34;)
    expected = &#34;Invalid command: :whats-mine-say points to nonexistent sub whats_mine_say&#34;
    output = evaluate_command(commands, &#39;:whats-mine-say&#39;)
    is(output, expected, &#39;Shell should warn about invalid commands&#39;)

    commands = register_default_commands()

    expected =&lt;&lt;&#39;EXPECTED&#39;
COMMANDS
:help    This view
:quit    Exit the shell
EXPECTED
    output = evaluate_command(commands, &#39;:help&#39;)
    is(output, expected, &#39;:help should be a registered default command&#39;)

    expected = &#39;&#39;
    output = evaluate_command(commands, &#39;:quit&#39;)
    is(output, expected, &#39;:quit should be a registered default command that returns an empty string&#39;)
.end

.sub say_dude
    .return(&#34;Dude!&#34;)
.end</code></pre>
</figure><p>The test code that has already been written shows a clear path for registering
default commands. All that&rsquo;s needed is the subroutines that will be invoked
when the command is called.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >example-0d-04/lib/spacetrade.pir
.sub register_default_commands
    .local pmc commands

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:help&#39;, &#39;default_help&#39;, &#39;This view&#39;)
    commands = register_command(commands, &#39;:quit&#39;, &#39;default_quit&#39;, &#39;Exit the shell&#39;)

    .return(commands)
.end

.sub default_help
    .local string output

    output =&lt;&lt;&#39;OUTPUT&#39;
COMMANDS
:help    This view
:quit    Exit the shell
OUTPUT

    .return(output)
.end

.sub default_quit
    .local string output
    output = &#39;&#39;
    .return(output)
.end</code></pre>
</figure><p>There&rsquo;s a problem.</p>
<p>The problem is that I had to cheat on <code>default_help</code>. See, the way that I set
up <code>evaluate_commands</code> is to directly invoke the registered subroutine without
any arguments. I would prefer that <code>default_help</code> examined the currently
registered commands and provided a real summary. It should even include my
magnificent <code>:dude</code> command in the summary.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(6)

    .local pmc    commands
    .local string expected
    .local string output

    commands = register_default_commands()

    expected =&lt;&lt;&#39;EXPECTED&#39;
COMMANDS
:help    This view
:quit    Exit the shell
EXPECTED
    output = evaluate_command(commands, &#39;:help&#39;)
    is(output, expected, &#39;:help should be a registered default command&#39;)

    expected = &#39;&#39;
    output = evaluate_command(commands, &#39;:quit&#39;)
    is(output, expected, &#39;:quit should be a registered default command that returns an empty string&#39;)

    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)

    expected =&lt;&lt;&#39;EXPECTED&#39;
COMMANDS
:dude    Say &#34;Dude!&#34;
:help    This view
:quit    Exit the shell
EXPECTED
    output = evaluate_command(commands, &#39;:help&#39;)
    is(output, expected, &#39;:help should reflect registered commands&#39;)

    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)

    expected = &#34;Unknown command: :sweet&#34;
    output = evaluate_command(commands, &#39;:sweet&#39;)
    is(output, expected, &#39;Shell should warn about unknown commands&#39;)

    commands = register_command(commands, &#39;:whats-mine-say&#39;, &#39;whats_mine_say&#39;, &#34;What&#39;s mine say?&#34;)
    expected = &#34;Invalid command: :whats-mine-say points to nonexistent sub whats_mine_say&#34;
    output = evaluate_command(commands, &#39;:whats-mine-say&#39;)
    is(output, expected, &#39;Shell should warn about invalid commands&#39;)

.end

.sub say_dude
    .return(&#34;Dude!&#34;)
.end</code></pre>
</figure><p>How am I supposed to do this? Let&rsquo;s start by rewriting <code>default_help</code> the way
it should work: by preparing a sorted list of registered commands and their
summaries.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/lib/spacetrade.pir
.sub default_help
    .param pmc    commands
    .local string output
    .local pmc    command_iter
    .local pmc    command_keys
    .local string key

    command_keys = new &#39;ResizablePMCArray&#39;
    command_iter = iter commands

  NEXT_COMMAND:
    unless command_iter goto PREPARE_OUTPUT
    key = shift command_iter
    push command_keys, key
    goto NEXT_COMMAND

  PREPARE_OUTPUT:
    output = &#34;COMMANDS\n&#34;
    command_keys.&#39;sort&#39;()

    .local string command_name
    .local string command_explanation
    .local string command_summary
    command_iter = iter command_keys

  NEXT_SUMMARY:
    unless command_iter goto RETURN_OUTPUT
    command_name = shift command_iter
    command_explanation = commands[command_name;&#39;explanation&#39;]
    command_summary = command_name . &#39;    &#39;
    command_summary .= command_explanation
    command_summary .= &#34;\n&#34;
    output .= command_summary
    goto NEXT_SUMMARY

  RETURN_OUTPUT:
    .return(output)
.end</code></pre>
</figure><p>A little explanation about <code>default_help</code> couldn&rsquo;t hurt. Hashes use their own
special tricks to make storing their elements more effective, which means you
have no guarantee of getting them in any particular order. I want to see the
commands in alphabetical order, so I will have to handle the ordering myself. I
did that by first building a list of keys.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >    command_keys = new &#39;ResizablePMCArray&#39;
    command_iter = iter commands

  NEXT_COMMAND:
    unless command_iter goto PREPARE_OUTPUT
    key = shift command_iter
    push command_keys, key
    goto NEXT_COMMAND</code></pre>
</figure><p>Once that list was constructed, it needed to be put in some sort of order.
Luckily, the Array PMCs come with a prepackaged <code>sort()</code> method - a special
subroutine that works directly with the elements of the array.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >    command_keys.&#39;sort&#39;()</code></pre>
</figure><p>The default sort behavior works for me. In this case they will be sorted more
or less alphabetically.</p>
<p>Now, I could add a lot of code to <code>evaluate_command</code> that will magically
determine what sort of arguments are required by the command, and to behave
appropriately. But before I go doing a significant rewrite - how about an
experiment? Maybe I can just call every command with <code>commands</code> as a parameter,
and see what happens in the tests.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/lib/spacetrade.pir

# ...

.sub evaluate_command
    .param pmc    commands
    .param string name

    .local string sub_name
    .local pmc    command_sub
    .local string output

    sub_name = commands[name;&#39;sub_name&#39;]
    unless sub_name goto UNKNOWN_COMMAND
    command_sub = get_global sub_name
    if_null command_sub, INVALID_COMMAND
    output = command_sub(commands)
    goto RETURN_OUTPUT

  UNKNOWN_COMMAND:
    output = &#34;Unknown command: &#34; . name
    goto RETURN_OUTPUT

  INVALID_COMMAND:
    output = &#34;Invalid command: &#34; . name
    output .= &#34; points to nonexistent sub &#34;
    output .= sub_name

  RETURN_OUTPUT:
    .return(output)
.end</code></pre>
</figure><p>You have to be willing to experiment, because the results may occasionally
surprise you.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot t/01-shell-metacommands.t
1..6
ok 1 - :help should be a registered default command
ok 2 - :quit should be a registered default command that returns an empty string
ok 3 - :help should reflect registered commands
ok 4 - User command &#34;:dude&#34; should result in string &#34;Dude!&#34;
ok 5 - Shell should warn about unknown commands
ok 6 - Shell should warn about invalid commands</code></pre>
</figure><p>How about that - it worked. PIR subroutines will apparently ignore positional
parameters that they didn&rsquo;t ask for, which means that <code>evaluate_command</code> can
call <code>say_dude</code> and <code>default_help</code> with the same parameter list and nothing bad
will happen.</p>
<h3 id="the-new-and-slightly-improved-shell">The New and Slightly Improved Shell</h3>
<p>A lot of work has gone into making the shell easier to use for me and people
who want to hack on the game in the future. Let&rsquo;s apply that work to the
<code>run_shell</code> subroutine itself.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/lib/spacetrade.pir

.sub run_shell
    .local pmc    commands
    .local string input
    .local string output
    .local pmc    stdin
    .const string PROMPT     = &#39;&gt; &#39;
    .const string QUICK_HELP = &#34;Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.&#34;

    commands = register_default_commands()
    stdin = getstdin

    say &#34;Welcome to SpaceTrade!&#34;
    say QUICK_HELP

  READLINE:
    input = stdin.&#39;readline_interactive&#39;(PROMPT)
    output = evaluate_command(commands, input)
    unless output goto EXIT
    say output
    goto READLINE

  EXIT:
    say &#34;Goodbye!&#34;
.end</code></pre>
</figure><p>It&rsquo;s certainly shorter than what I started with. How well does it work?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot lib/spacetrade.pir
Welcome to SpaceTrade!
Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.
&gt; :dude
Unknown command: :dude
&gt; :help
COMMANDS
:help    This view
:quit    Exit the shell

&gt; :quit
Goodbye!</code></pre>
</figure><p>It isn&rsquo;t perfect, but it will work for the moment. This new shell has most of
the core behavior from the original, and we have shown that it will not be hard
to add new commands. There is still a large part of me that thinks the code for
the shell should be tucked into its own corner, where it cannot get mixed up
with the code for the actual game. That will have to wait for the next step,
though.</p>

  




  <section class="backlinks">
    <h2>Backlinks</h2>
    <nav>
      <ul>
      
      <li>
        <a href="/post/2010/10/parrot-babysteps-0e-parrot-namespaces/">parrot-babysteps-0e-parrot-namespaces</a>
      </li>
      
      </ul>
    </nav>
  </section>



  <hr>
  

  
  
<hr>
<div class="footer">
    
      <p>Series: <a href="/series/parrot-babysteps">Parrot Babysteps</a></p>
    
    
      <a class="previous-post" href="https://randomgeekery.org/post/2010/07/whered-he-go/?ref=footer">
        <span style="font-weight:bold;">« Previous</span>
        <br>Where&#39;d He Go?
      </a>
    
    
      <div class="next-post">
        <a href="https://randomgeekery.org/post/2010/09/rakudo/?ref=footer">
          <span style="font-weight:bold;">Next »</span>
          <br>Rakudo
        </a>
      </div>
    
</div>

  
</div>
            </main>
            
  
    <div class="article-toc ">
    <div class="toc-wrapper">
      <h4 id="contents"></h4>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#spacetrade-summary">SpaceTrade Summary</a>
      <ul>
        <li><a href="#development-tasks">Development Tasks</a></li>
      </ul>
    </li>
    <li><a href="#setting-up-the-project">Setting up the project</a>
      <ul>
        <li><a href="#the-spacetrade-interactive-shell">The SpaceTrade Interactive Shell</a></li>
        <li><a href="#creating-a-command-registry">Creating a Command Registry</a></li>
        <li><a href="#setting-up-those-default-shell-commands">Setting Up Those Default Shell Commands</a></li>
        <li><a href="#the-new-and-slightly-improved-shell">The New and Slightly Improved Shell</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
</div>

  

        </div><script defer data-domain="randomgeekery.org" src="https://plausible.io/js/script.js"></script>
    </body>
</html>
