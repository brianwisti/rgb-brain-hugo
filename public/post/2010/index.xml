<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>2010onRandom Geekery</title>
    <link>https://randomgeekery.org/post/2010/</link>
    <description>
      Recent contentin2010 on Random Geekery
    </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
      
      <lastBuildDate>Sun, 21 Jan 2024 21:46:53 -0800</lastBuildDate><atom:link href="https://randomgeekery.org/post/2010/index.xml" rel="self" type="application/rss+xml" /><item>
  <title>Post: Parrot Babysteps 0e - Parrot Namespaces</title>
  <link>https://randomgeekery.org/post/2010/10/parrot-babysteps-0e-parrot-namespaces/</link>
  <pubDate>Mon, 11 Oct 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/10/parrot-babysteps-0e-parrot-namespaces/</guid>
  <description>Where was I? In the previous Babystep, I started working out some rough ideas for a version of the old school Star Trader game written in Parrot PIR. I made a quick description and sketched up a list of the features that would need to be created. One of those features was an interactive shell to be used in developing and hacking on that Space Trade game. I wrote a simple shell that could be extended, making it easier to expand the capabilities of the shell in the future - or even use the shell in some completely unforeseen future application.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>Where was I? In the <a href="/post/2010/08/parrot-babysteps-0d-the-space-trade-project/">previous Babystep</a>, I started working out some rough ideas for a version of the old school <a href="https://en.wikipedia.org/wiki/Star_Trader">Star Trader</a> game written in Parrot PIR. I made a quick description and sketched up a list of the  features that would need to be created. One of those features was an interactive shell to be used in developing and hacking on that Space Trade game. I wrote a simple shell that could be extended, making it easier to expand the capabilities of the shell in the future - or even use the shell in some completely unforeseen future application.</p>
<p>I like that shell, but it is not perfect. Programming languages like Parrot
support <a href="http://en.wikipedia.org/wiki/Namespace_%28computer_science%29">namespaces</a>, which you can think of as dictionaries that the language uses to look up variables and subroutines. My problem with the shell today revolves around the fact that every subroutine used in defining or extending the shell exists in the global namespace. They are available everywhere - in every line of code for the SpaceTrade game and anything that uses it. This may not be a huge problem by itself, because right now there are only a few subroutines. The number of subroutines will grow as the project evolves, however. This will have a couple of different effects.</p>
<ul>
<li>Subroutine names will be harder to remember, because the global namespace is one big bucket. I like to put related subroutines into little boxes so that I can focus on shell behavior when I&rsquo;m looking at shell code, and game behavior when I&rsquo;m looking at game code.</li>
<li>Subroutine names could get rather contorted. What happens if I make Space Trade available, and against all odds it becomes a runaway success? Five, maybe even ten people download it and play it. It is likely that at least one of those people will want to write their own shell for the game. They will have to come up with some odd names for their shell code, such as <code>register_awesome_commands</code>, because I have selfishly used all the good names for my own shell.</li>
</ul>
<h2 id="namespaces">Namespaces</h2>
<p>Namespaces provide a way to insulate the parts of a computer program from each other. The subroutines and variables defined in one namespace will not interfere with the subroutines and variables in another. This means that I can have my <code>register_default_commands</code> subroutine for my own shell, and you can have a  <code>register_default_commands</code> subroutine in your own shell, and they never need to know about each other. It does mean you must take extra steps if you want to use the subroutine from my package in your own code, or I must somehow provide a means to push the subroutines that I consider appropriate into your namespace. That is what <a href="https://github.com/parrot/parrot/blob/master/runtime/parrot/include/test_more.pir">Test::More</a> does. Defining something like that is an exercise in careful judgment and reasonable coding. In other words, we will not be doing that with SpaceTrade any time soon.</p>
<p>I will try to focus on the most important elements of <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch04_variables.pod.html#Namespaces">Parrot Namespaces</a> rather than get carried away with all of the little details.</p>
<h3 id="organizing-the-namespaces">Organizing the Namespaces</h3>
<p>Even though the SpaceTrade game has very little code right now, I want to put a little thought into organizing my namespaces before I create them. The first layer is easy: all of the code supporting the SpaceTrade game will go in the &ldquo;SpaceTrade&rdquo; namespace.</p>
<ul>
<li>SpaceTrade: Code for the SpaceTrade Game</li>
</ul>
<p>Parrot supports nested namespaces, so &ldquo;SpaceTrade&rdquo; can contain any number of namespaces. I&rsquo;m sure there will be many contained namespaces for game setup and play, but I will only specify the one I am working on today: &ldquo;SpaceTrade::Shell.&rdquo;</p>
<ul>
<li>SpaceTrade: Code for the SpaceTrade Game</li>
<li>SpaceTrade::Shell: A simple interactive shell for SpaceTrade</li>
</ul>
<p>The names do not mean anything to Parrot. It does not force a particular way of organizing your namespaces. Nested namespaces are a convenience so that <em>we</em> know two chunks of code are somewhat related.</p>
<h4 id="the-namespace-directive">The <code>.namespace</code> Directive</h4>
<p>The <code>.namespace</code> directive is used to tell Parrot that the following code belongs in a particular namespace. Its argument is a hash index specifying the name.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.namespace [&#39;SpaceTrade&#39;]</code></pre>
</figure><p>Use a complex key to indicate a nested namespace.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.namespace [&#39;SpaceTrade&#39;;&#39;Shell&#39;]</code></pre>
</figure><p>All of the code after the <code>.namespace</code> directive gets filed in the namespace associated with the key you handed to it. This lasts until you declare a new namespace.</p>
<p>It&rsquo;s time to try it out in <code>spacetrade.pir</code>. All of the code written so far is for the shell, so I can probably get away with putting my <code>.namespace</code> directive at the top of the file.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-01/lib/spacetrade.pir
.namespace [&#39;SpaceTrade&#39;;&#39;Shell&#39;]

.sub &#39;main&#39; :main
    run_shell()
.end

.sub run_shell
    # ...</code></pre>
</figure><p>Why do I say &ldquo;SpaceTrade::Shell&rdquo; rather than <code>['SpaceTrade';'Shell']</code> when talking about my namespace in this article? That is mainly because I am lazy. My fingers do not enjoy typing out all the characters to say <code>['SpaceTrace';'Shell']</code>, so I want to use a shorthand. &ldquo;SpaceTrade::Shell&rdquo; mimics a convention used by some Parrot programmers when talking about namespaces. It is a convention derived from the way that namespaces - or &ldquo;packages&rdquo; - are declared in <a href="/card/perl/">Perl</a>, which is another language of choice for many Parrot developers. I will switch to another convention if I see one that is both widely used and easy to type.</p>
<p>Back to SpaceTrade. I run <code>setup.pir test</code> out of curiosity.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-shell-metacommands.t .. ok
All tests successful.
Files=1, Tests=6,  0.015 wallclock secs
Result: PASS</code></pre>
</figure><p>The tests pass, which is kind of cool. But <em>why</em> do they pass, if I have
defined a namespace in <code>spacetrade.pir</code>? The tests should complain about missing subroutines if they are in a different namespace, right?</p>
<p>Yes, that is right. However, the <code>.include</code> directive effectively dumps the
code from your included file right where you put the directive. The tests exist in the <code>['SpaceTrade';'Shell']</code> namespace because we never indicated that we were moving onto a new one.</p>
<p>That might even be okay for these tests. After all, they are just telling me
that the shell subroutines work, not that namespace handling works. The
SpaceTrade namespaces are going to get more cluttered as time goes on, though. I am going to be more explicit in the namespace handling for my tests in order to prepare for that clutter.</p>
<h3 id="the-default-namespace">The Default Namespace</h3>
<p>To specify that you are going back to the default namespace, hand an empty key to the <code>.namespace</code> directive.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.namespace [ ]</code></pre>
</figure><p>I understand the idea here. The default namespace is no namespace at all, so it gets an empty key. Let&rsquo;s put that line in <code>01-shell-metacommands.pir</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-02/t/01-shell-metacommands.pir

.include &#39;lib/spacetrade.pir&#39;

.namespace [ ]

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    # ...</code></pre>
</figure><p>What happens if I run the tests now?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-shell-metacommands.t .. Dubious, test returned 1
Failed 6/6 subtests

Test Summary Report
-------------------
t/01-shell-metacommands.t (Tests: 0 Failed: 0)
  Non-zero exit status: 1
  Parse errors: Unknown TAP token: &#34;Could not find sub register_default_commands&#34;
                Unknown TAP token: &#34;current instr.: &#39;main&#39; pc 275 (t/01-shell-metacommands.t:14)&#34;
Bad plan.  You planned 6 tests but ran 0.
Files=1, Tests=0,  0.014 wallclock secs
Result: FAIL
test fails
current instr.: &#39;setup&#39; pc 829 (runtime/parrot/library/distutils.pir:379)</code></pre>
</figure><p>This is the error I was expecting to see initially, so I am happy. I suppose I could have put that <code>.namespace [ ]</code> directive at the end of <code>spacetrade.pir</code> - Parrot does not have any rules about where to end one namespace and start another - but I feel like that would have broken the way <code>.include</code> behaves. I will probably learn a better way to handle these little namespace issues eventually.</p>
<p>Now I have library code tucked into a namespace and test code that doesn&rsquo;t know about the shell subroutines. A quick look at <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines/">07-writing-subroutines/</a> shows how to get those shell subroutines into our current namespace. The <code>get_global</code> opcode allows us to grab a variable from another namespace. We used it in to grab the <code>chomp</code> subroutine from the String::Utils namespace. Let&rsquo;s use <code>get_global</code> to make the tested subroutines available.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-03/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.namespace [ ]

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(6)

    .local pmc    register_default_commands
    .local pmc    evaluate_command
    .local pmc    register_command
    .local pmc    commands
    .local string expected
    .local string output

    register_default_commands = get_global [&#39;SpaceTrade&#39;;&#39;Shell&#39;], &#39;register_default_commands&#39;
    evaluate_command = get_global [&#39;SpaceTrade&#39;;&#39;Shell&#39;], &#39;evaluate_command&#39;
    register_command = get_global [&#39;SpaceTrade&#39;;&#39;Shell&#39;], &#39;register_command&#39;

    commands = register_default_commands()

    # ...</code></pre>
</figure><p>As we can see, that&rsquo;s <em>almost</em> good enough.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >1..6
ok 1 - :help should be a registered default command
ok 2 - :quit should be a registered default command that returns an empty string
ok 3 - :help should reflect registered commands
not ok 4 - User command &#34;:dude&#34; should result in string &#34;Dude!&#34;
# Have: Invalid command: :dude points to nonexistent sub say_dude
# Want: Dude!
ok 5 - Shell should warn about unknown commands
ok 6 - Shell should warn about invalid commands</code></pre>
</figure><p>Up until now we have been using subroutine names when registering commands, but that is not going to work anymore. SpaceTrade no longer knows exactly where it should look for the subroutines with those names. Instead of names, let&rsquo;s try using the subroutines themselves.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-04/lib/spacetrade.pir
.sub register_command
    .param pmc    commands
    .param string name
    .param pmc    code
    .param string explanation

    .local pmc    command
    .local pmc    callback

    command = new &#39;Hash&#39;
    command[&#39;code&#39;] = code
    command[&#39;explanation&#39;] = explanation

    commands[name] = command
    goto RETURN_COMMANDS

  RETURN_COMMANDS:
    .return(commands)
.end</code></pre>
</figure><p><code>register_command</code> doesn&rsquo;t look a lot different. The names have changed to show what is going on, but we are still just building a Hash of commands and relying on <code>evaluate_command</code> to sort out any problems.</p>
<p>Naturally, that means <code>evaluate_command</code> is where the changes become obvious.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-04/lib/spacetrade.pir
.sub evaluate_command
    .param pmc    commands
    .param string name

    .local int    has_command
    .local pmc    command_info
    .local pmc    code
    .local int    is_invokable
    .local pmc    command_sub
    .local string output

    has_command = exists commands[name]
    unless has_command goto UNKNOWN_COMMAND

    command_sub = commands[name;&#39;code&#39;]
    if_null command_sub, INVALID_COMMAND

    is_invokable = does command_sub, &#39;invokable&#39;
    unless is_invokable goto INVALID_COMMAND

    output = command_sub(commands)
    goto RETURN_OUTPUT

  UNKNOWN_COMMAND:
    output = &#34;Unknown command: &#34; . name
    goto RETURN_OUTPUT

  INVALID_COMMAND:
    output = &#34;Invalid command: &#34; . name
    output .= &#34; does not point to a valid subroutine&#34;

  RETURN_OUTPUT:
    .return(output)
.end</code></pre>
</figure><p>We do a few simple checks when somebody tries to evaluate a command.</p>
<ul>
<li>Do we have an entry for the command?</li>
<li>Is there something actually <em>at</em> the entry?</li>
<li>Is the thing stored for the command look like something we can treat as a subroutine?</li>
</ul>
<p>That&rsquo;s what the <code>does</code> check handles, incidentally. Right now we only know about subroutines, but later on we may get into strange creations that aren&rsquo;t subroutines but can be invoked as if they were. From what the folks on IRC <code>#parrot</code> tell me, you would ask <code>command_sub</code> if it is invokable. All I know is that it worked and that I like the folks on <code>#parrot</code> very much.</p>
<p>We should make one more change before heading over to the tests. <code>register_default_commands</code> needs to adjust to the new way of  registering commands.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-04/lib/spacetrade.pir
.sub register_default_commands
    .local pmc commands
    .local pmc help_command
    .local pmc quit_command

    commands = new &#39;Hash&#39;
    help_command = get_global &#39;default_help&#39;
    quit_command = get_global &#39;default_quit&#39;
    commands = register_command(commands, &#39;:help&#39;, help_command, &#39;This view&#39;)
    commands = register_command(commands, &#39;:quit&#39;, quit_command, &#39;Exit the shell&#39;)

    .return(commands)
.end</code></pre>
</figure><p>If you don&rsquo;t explicitly hand a namespace to <code>get_global</code>, it will use whatever namespace it&rsquo;s called from. In this case, that is the SpaceTrade::Shell namespace.</p>
<p>We have to change the tests themselves now. There is actually only one test that needs to be changed. Look in <code>01-shell-metacommands.t</code> for the line that registers the <code>:dude</code> command.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-03/t/01-shell-metacommands.t
# ...
commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)</code></pre>
</figure><p>Instead of handing a string, create a PMC to hold the <code>say_dude</code> subroutine and had <em>that</em> to <code>register_command</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-04/t/01-shell-metacommands.t
.local pmc my_sub
my_sub = get_global &#39;say_dude&#39;
commands = register_command(commands, &#39;:dude&#39;, my_sub, &#39;Say &#34;Dude!&#34;&#39;)</code></pre>
</figure><p>Once again, we&rsquo;re using <code>get_global</code> to grab from the current namespace, which is the default namespace now.</p>
<p>All right, the tests should run okay.</p>
<p>It is possible to set and get truly global variables with <code>get_root_global</code> and <code>set_root_global</code>, but I do not recommend it. What happens if you decide that the global <code>my_config</code> should be an Array instead of a Hash? Every piece of code that uses a global variable must be updated.</p>
<p>The same problem exists with package globals, even though it may be on a smaller scale. There&rsquo;s a solution - or at least a way to make the problem even smaller. Whenever I see data and several subroutines that need to work on that data, I start to see objects.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Ruby and the HYG Star Catalog</title>
  <link>https://randomgeekery.org/post/2010/10/ruby-and-the-hyg-star-catalog/</link>
  <pubDate>Tue, 05 Oct 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/10/ruby-and-the-hyg-star-catalog/</guid>
  <description>&lt;p&gt;One of my big projects over the last year has been a &lt;a href=&#34;https://randomgeekery.org/post/2009/07/parrot-babysteps/&#34;&gt;Parrot Babysteps&lt;/a&gt; tutorial. One of the more interesting tasks in that tutorial was &lt;a href=&#34;https://randomgeekery.org/post/2009/10/parrot-babysteps-06-files-and-hashes/&#34;&gt;reading a CSV file in Parrot&lt;/a&gt;. I used the &lt;a href=&#34;http://www.astronexus.com/node/34&#34;&gt;HYG Star Catalog&lt;/a&gt; as a sample &lt;a href=&#34;https://randomgeekery.org/card/csv/&#34;&gt;CSV&lt;/a&gt; file that was large enough to present some interesting data. This was fun in &lt;a href=&#34;https://randomgeekery.org/card/parrot/&#34;&gt;Parrot&lt;/a&gt;, but obviously I thought quite a bit about how I would tackle the problem in a higher level language such as &lt;a href=&#34;https://randomgeekery.org/card/ruby/&#34;&gt;Ruby&lt;/a&gt;. Today seems like a good day to find out.&lt;/p&gt;</description>
   <category>post</category> 
   <category>post</category> 
   <category>ruby</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>One of my big projects over the last year has been a <a href="/post/2009/07/parrot-babysteps/">Parrot Babysteps</a> tutorial. One of the more interesting tasks in that tutorial was <a href="/post/2009/10/parrot-babysteps-06-files-and-hashes/">reading a CSV file in Parrot</a>. I used the <a href="http://www.astronexus.com/node/34">HYG Star Catalog</a> as a sample <a href="/card/csv/">CSV</a> file that was large enough to present some interesting data. This was fun in <a href="/card/parrot/">Parrot</a>, but obviously I thought quite a bit about how I would tackle the problem in a higher level language such as <a href="/card/ruby/">Ruby</a>. Today seems like a good day to find out.</p>
<p>I am emphasizing the <em>Moderately</em> in this Moderately Interesting Ruby Exercise. After exploring the <code>csv</code> library for Ruby, we&rsquo;ll use <a href="http://sequel.rubyforge.org/">Sequel</a> to build a database that can be quickly queried. Even though I have an unhealthy love for making projects larger and more complex than they need to be, I want to keep this short and sweet.</p>
<h3 id="what-im-using">What I&rsquo;m Using</h3>
<p>My primary machine for these projects is the happy home iMac. It is running OS X 10.6 plus <a href="http://macports.org">MacPorts</a>. My default Ruby is 1.9.2, installed via <a href="http://rvm.beginrescueend.com/">rvm</a>.</p>
<p>I may revisit this exercise with other Ruby installations on other platforms to double-check that things work, but your results <em>should</em> be similar to mine as long as you are using Ruby 1.9.2.</p>
<h2 id="exploration">Exploration</h2>
<p>We will start by poking at the Ruby standard <code>csv</code> library a little bit, just to see how we use it. I already have a copy of the HYG Star Catalog from my previous efforts, but for this exercise I&rsquo;ll pretend I do not. We&rsquo;ll just download it using our favorite downloading technique. Mine is GNU <a href="http://www.gnu.org/software/wget/">wget</a>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ wget http://www.astronexus.com/files/downloads/hygxyz.csv.gz
$ tar xfvz hygxyz.csv.gz</code></pre>
</figure><p>If we open <code>hygxyz.csv</code> in our favorite <em>Editor</em>, we will see that the file is large and bewildering.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ
0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0
1,1,224700,,,,,6.079e-05,01.08901332,282.485875706215,-5.20,-1.88,,9.10,1.84501631012894,F5,0.482,282.43485,0.00449,5.36884,4.9e-08,-7.12e-06,-2.574e-06
... and so on for 119,618 lines</code></pre>
</figure><p>There are many fields. Some of them are strings, others are numbers. Quite a few are empty.</p>
<h3 id="parsing-the-csv">Parsing the CSV</h3>
<p>Let&rsquo;s start with the simplest and dumbest CSV parsing code we can manage.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="nb">require</span> <span class="s1">&#39;csv&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="no">CSV</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;hygxyz.csv&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span> <span class="nb">p</span> <span class="n">row</span> <span class="p">}</span></span></span></code></pre>
</figure><p>How does that look?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ ruby stellar
[&#34;StarID&#34;, &#34;HIP&#34;, &#34;HD&#34;, &#34;HR&#34;, &#34;Gliese&#34;, &#34;BayerFlamsteed&#34;, &#34;ProperName&#34;, &#34;RA&#34;, &#34;Dec&#34;, &#34;Distance&#34;, &#34;PMRA&#34;,
&#34;PMDec&#34;, &#34;RV&#34;, &#34;Mag&#34;, &#34;AbsMag&#34;, &#34;Spectrum&#34;, &#34;ColorIndex&#34;, &#34;X&#34;, &#34;Y&#34;, &#34;Z&#34;, &#34;VX&#34;, &#34;VY&#34;, &#34;VZ&#34;]
[&#34;0&#34;, nil, nil, nil, nil, nil, &#34;Sol&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0.000004848&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;-26.73&#34;, &#34;4.85&#34;, &#34;G2V&#34;,
&#34;0.656&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;]
[&#34;1&#34;, &#34;1&#34;, &#34;224700&#34;, nil, nil, nil, nil, &#34;6.079e-05&#34;, &#34;01.08901332&#34;, &#34;282.485875706215&#34;, &#34;-5.20&#34;, &#34;-1.88&#34;,
nil, &#34;9.10&#34;, &#34;1.84501631012894&#34;, &#34;F5&#34;, &#34;0.482&#34;, &#34;282.43485&#34;, &#34;0.00449&#34;, &#34;5.36884&#34;, &#34;4.9e-08&#34;, &#34;-7.12e-06&#34;,
&#34;-2.574e-06&#34;]
[&#34;2&#34;, &#34;2&#34;, &#34;224690&#34;, nil, nil, nil, nil, &#34;0.00025315&#34;, &#34;-19.49883745&#34;, &#34;45.662100456621&#34;, &#34;181.21&#34;,
&#34;-0.93&#34;, nil, &#34;9.27&#34;, &#34;5.97222057420059&#34;, &#34;K3V&#34;, &#34;0.999&#34;, &#34;43.04329&#34;, &#34;0.00285&#34;, &#34;-15.24144&#34;, &#34;-7.1e-08&#34;,
&#34;4.0112e-05&#34;, &#34;-1.94e-07&#34;]
[&#34;3&#34;, &#34;3&#34;, &#34;224699&#34;, nil, nil, nil, nil, &#34;0.00033386&#34;, &#34;38.85928608&#34;, &#34;355.871886120996&#34;, &#34;5.24&#34;, &#34;-2.91&#34;,
nil, &#34;6.61&#34;, &#34;-1.1464684004746&#34;, &#34;B9&#34;, &#34;-0.019&#34;, &#34;277.11358&#34;, &#34;0.02422&#34;, &#34;223.27753&#34;, &#34;3.148e-06&#34;,
&#34;9.04e-06&#34;, &#34;-3.909e-06&#34;]
...</code></pre>
</figure><p>Okay, wow. That is a lot of stuff going by. I don&rsquo;t know about you, but I&rsquo;m going to hit Control-C and make an adjustment to the code.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="nb">require</span> <span class="s1">&#39;csv&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;hygxyz.csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="no">CSV</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span> <span class="nb">p</span> <span class="n">row</span> <span class="p">}</span></span></span></code></pre>
</figure><p>There. Now we will only look at the first three entries. That should be a little easier to digest. I also shuffled the filename into its own variable. That&rsquo;s just how I like to do things. I tell myself that it will be easier to read and edit later.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ ruby stellar
[&#34;StarID&#34;, &#34;HIP&#34;, &#34;HD&#34;, &#34;HR&#34;, &#34;Gliese&#34;, &#34;BayerFlamsteed&#34;, &#34;ProperName&#34;, &#34;RA&#34;, &#34;Dec&#34;, &#34;Distance&#34;, &#34;PMRA&#34;,
&#34;PMDec&#34;, &#34;RV&#34;, &#34;Mag&#34;, &#34;AbsMag&#34;, &#34;Spectrum&#34;, &#34;ColorIndex&#34;, &#34;X&#34;, &#34;Y&#34;, &#34;Z&#34;, &#34;VX&#34;, &#34;VY&#34;, &#34;VZ&#34;]
[&#34;0&#34;, nil, nil, nil, nil, nil, &#34;Sol&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0.000004848&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;-26.73&#34;, &#34;4.85&#34;, &#34;G2V&#34;,
&#34;0.656&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;, &#34;0&#34;]
[&#34;1&#34;, &#34;1&#34;, &#34;224700&#34;, nil, nil, nil, nil, &#34;6.079e-05&#34;, &#34;01.08901332&#34;, &#34;282.485875706215&#34;, &#34;-5.20&#34;, &#34;-1.88&#34;,
nil, &#34;9.10&#34;, &#34;1.84501631012894&#34;, &#34;F5&#34;, &#34;0.482&#34;, &#34;282.43485&#34;, &#34;0.00449&#34;, &#34;5.36884&#34;, &#34;4.9e-08&#34;, &#34;-7.12e-06&#34;,
&#34;-2.574e-06&#34;]</code></pre>
</figure><p>The default behavior for <code>csv</code> is reasonable. It split up the fields correctly, and set the empty fields to <code>nil</code>. Next we need to deal with the fact that the first row is supposed to be the header, providing names for
fields in the corresponding columns.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="nb">require</span> <span class="s1">&#39;csv&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;hygxyz.csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="no">CSV</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="ss">headers</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span> <span class="nb">p</span> <span class="n">row</span> <span class="p">}</span></span></span></code></pre>
</figure><p>One small change has a big impact.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ ruby stellar.rb
#&lt;CSV::Row &#34;StarID&#34;:&#34;0&#34; &#34;HIP&#34;:nil &#34;HD&#34;:nil &#34;HR&#34;:nil &#34;Gliese&#34;:nil &#34;BayerFlamsteed&#34;:nil &#34;ProperName&#34;:&#34;Sol&#34;
&#34;RA&#34;:&#34;0&#34; &#34;Dec&#34;:&#34;0&#34; &#34;Distance&#34;:&#34;0.000004848&#34; &#34;PMRA&#34;:&#34;0&#34; &#34;PMDec&#34;:&#34;0&#34; &#34;RV&#34;:&#34;0&#34; &#34;Mag&#34;:&#34;-26.73&#34; &#34;AbsMag&#34;:&#34;4.85&#34;
&#34;Spectrum&#34;:&#34;G2V&#34; &#34;ColorIndex&#34;:&#34;0.656&#34; &#34;X&#34;:&#34;0&#34; &#34;Y&#34;:&#34;0&#34; &#34;Z&#34;:&#34;0&#34; &#34;VX&#34;:&#34;0&#34; &#34;VY&#34;:&#34;0&#34; &#34;VZ&#34;:&#34;0&#34;&gt;
#&lt;CSV::Row &#34;StarID&#34;:&#34;1&#34; &#34;HIP&#34;:&#34;1&#34; &#34;HD&#34;:&#34;224700&#34; &#34;HR&#34;:nil &#34;Gliese&#34;:nil &#34;BayerFlamsteed&#34;:nil &#34;ProperName&#34;:nil
&#34;RA&#34;:&#34;6.079e-05&#34; &#34;Dec&#34;:&#34;01.08901332&#34; &#34;Distance&#34;:&#34;282.485875706215&#34; &#34;PMRA&#34;:&#34;-5.20&#34; &#34;PMDec&#34;:&#34;-1.88&#34; &#34;RV&#34;:nil
&#34;Mag&#34;:&#34;9.10&#34; &#34;AbsMag&#34;:&#34;1.84501631012894&#34; &#34;Spectrum&#34;:&#34;F5&#34; &#34;ColorIndex&#34;:&#34;0.482&#34; &#34;X&#34;:&#34;282.43485&#34; &#34;Y&#34;:&#34;0.00449&#34;
&#34;Z&#34;:&#34;5.36884&#34; &#34;VX&#34;:&#34;4.9e-08&#34; &#34;VY&#34;:&#34;-7.12e-06&#34; &#34;VZ&#34;:&#34;-2.574e-06&#34;&gt;
#&lt;CSV::Row &#34;StarID&#34;:&#34;2&#34; &#34;HIP&#34;:&#34;2&#34; &#34;HD&#34;:&#34;224690&#34; &#34;HR&#34;:nil &#34;Gliese&#34;:nil &#34;BayerFlamsteed&#34;:nil &#34;ProperName&#34;:nil
&#34;RA&#34;:&#34;0.00025315&#34; &#34;Dec&#34;:&#34;-19.49883745&#34; &#34;Distance&#34;:&#34;45.662100456621&#34; &#34;PMRA&#34;:&#34;181.21&#34; &#34;PMDec&#34;:&#34;-0.93&#34; &#34;RV&#34;:nil
&#34;Mag&#34;:&#34;9.27&#34; &#34;AbsMag&#34;:&#34;5.97222057420059&#34; &#34;Spectrum&#34;:&#34;K3V&#34; &#34;ColorIndex&#34;:&#34;0.999&#34; &#34;X&#34;:&#34;43.04329&#34; &#34;Y&#34;:&#34;0.00285&#34;
&#34;Z&#34;:&#34;-15.24144&#34; &#34;VX&#34;:&#34;-7.1e-08&#34; &#34;VY&#34;:&#34;4.0112e-05&#34; &#34;VZ&#34;:&#34;-1.94e-07&#34;&gt;</code></pre>
</figure><p>Now <code>csv</code> is generating something that looks vaguely like a hash. Nice. However, every field is handled as a String when some of them are obviously numbers. The <code>converters</code> option should fix that.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="no">CSV</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="ss">headers</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">converters</span><span class="p">:</span> <span class="ss">:numeric</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">  <span class="nb">p</span> <span class="n">row</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span></span></span></code></pre>
</figure><p>Setting the <code>converters</code> option to <code>:numeric</code> tells CSV to convert anything that looks like a number to a Number. That is useful for comparing values, because Ruby won&rsquo;t automatically convert a String into a Number. You must tell it to convert. Anyways - I&rsquo;m babbling. It is really amazing how hard it is to pad the content of these little essays out when you are talking about Ruby code. That&rsquo;s probably why there are so many silly cartoons and insane gibberish accompanying the best Ruby tutorials.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ ruby stellar.rb
#&lt;CSV::Row &#34;StarID&#34;:0 &#34;HIP&#34;:nil &#34;HD&#34;:nil &#34;HR&#34;:nil &#34;Gliese&#34;:nil &#34;BayerFlamsteed&#34;:nil &#34;ProperName&#34;:&#34;Sol&#34; &#34;RA&#34;:0
&#34;Dec&#34;:0 &#34;Distance&#34;:4.848e-06 &#34;PMRA&#34;:0 &#34;PMDec&#34;:0 &#34;RV&#34;:0 &#34;Mag&#34;:-26.73 &#34;AbsMag&#34;:4.85 &#34;Spectrum&#34;:&#34;G2V&#34;
&#34;ColorIndex&#34;:0.656 &#34;X&#34;:0 &#34;Y&#34;:0 &#34;Z&#34;:0 &#34;VX&#34;:0 &#34;VY&#34;:0 &#34;VZ&#34;:0&gt;
#&lt;CSV::Row &#34;StarID&#34;:1 &#34;HIP&#34;:1 &#34;HD&#34;:224700 &#34;HR&#34;:nil &#34;Gliese&#34;:nil &#34;BayerFlamsteed&#34;:nil &#34;ProperName&#34;:nil
&#34;RA&#34;:6.079e-05 &#34;Dec&#34;:1.08901332 &#34;Distance&#34;:282.485875706215 &#34;PMRA&#34;:-5.2 &#34;PMDec&#34;:-1.88 &#34;RV&#34;:nil &#34;Mag&#34;:9.1
&#34;AbsMag&#34;:1.84501631012894 &#34;Spectrum&#34;:&#34;F5&#34; &#34;ColorIndex&#34;:0.482 &#34;X&#34;:282.43485 &#34;Y&#34;:0.00449 &#34;Z&#34;:5.36884
&#34;VX&#34;:4.9e-08 &#34;VY&#34;:-7.12e-06 &#34;VZ&#34;:-2.574e-06&gt;
#&lt;CSV::Row &#34;StarID&#34;:2 &#34;HIP&#34;:2 &#34;HD&#34;:224690 &#34;HR&#34;:nil &#34;Gliese&#34;:nil &#34;BayerFlamsteed&#34;:nil &#34;ProperName&#34;:nil
&#34;RA&#34;:0.00025315 &#34;Dec&#34;:-19.49883745 &#34;Distance&#34;:45.662100456621 &#34;PMRA&#34;:181.21 &#34;PMDec&#34;:-0.93 &#34;RV&#34;:nil &#34;Mag&#34;:9.27
&#34;AbsMag&#34;:5.97222057420059 &#34;Spectrum&#34;:&#34;K3V&#34; &#34;ColorIndex&#34;:0.999 &#34;X&#34;:43.04329 &#34;Y&#34;:0.00285 &#34;Z&#34;:-15.24144
&#34;VX&#34;:-7.1e-08 &#34;VY&#34;:4.0112e-05 &#34;VZ&#34;:-1.94e-07&gt;</code></pre>
</figure><p>Let&rsquo;s do something with those Numbers. How about counting the number of stars within ten light years of Earth?</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="c1"># count-neighbors.rb</span>
</span></span><span class="line"><span class="cl"><span class="nb">require</span> <span class="s1">&#39;csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;hygxyz.csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">neighbor_count</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="no">CSV</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="ss">headers</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">converters</span><span class="p">:</span> <span class="ss">:numeric</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="n">row</span><span class="o">[</span><span class="s1">&#39;Distance&#39;</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">    <span class="n">neighbor_count</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">puts</span> <span class="s2">&#34;There are </span><span class="si">#{</span><span class="n">neighbor_count</span><span class="si">}</span><span class="s2"> stars within 10 light years of Earth.&#34;</span></span></span></code></pre>
</figure><p>How many are there?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ ruby count-neighbors.rb
There are 320 stars within 10 light years of Earth.</code></pre>
</figure><p>That&rsquo;s a lot of neighbors. It took a while to count them, though. That probably has something to do with the 20 Megabyte CSV file. We are not ready to speed things up, though. Let&rsquo;s try one more task: looking for a specific star.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="c1"># find-sol.rb</span>
</span></span><span class="line"><span class="cl"><span class="nb">require</span> <span class="s1">&#39;csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;hygxyz.csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="no">CSV</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="ss">headers</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">converters</span><span class="p">:</span> <span class="ss">:numeric</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="n">row</span><span class="o">[</span><span class="s1">&#39;ProperName&#39;</span><span class="o">]</span> <span class="o">==</span> <span class="s2">&#34;Sol&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">p</span> <span class="n">row</span>
</span></span><span class="line"><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span></span></span></code></pre>
</figure><p>It better find our own Sun. It&rsquo;s the first entry, after all.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ ruby find-sol.rb
#&lt;CSV::Row &#34;StarID&#34;:0 &#34;HIP&#34;:nil &#34;HD&#34;:nil &#34;HR&#34;:nil &#34;Gliese&#34;:nil &#34;BayerFlamsteed&#34;:nil &#34;ProperName&#34;:&#34;Sol&#34; &#34;RA&#34;:0
&#34;Dec&#34;:0 &#34;Distance&#34;:4.848e-06 &#34;PMRA&#34;:0 &#34;PMDec&#34;:0 &#34;RV&#34;:0 &#34;Mag&#34;:-26.73 &#34;AbsMag&#34;:4.85 &#34;Spectrum&#34;:&#34;G2V&#34;
&#34;ColorIndex&#34;:0.656 &#34;X&#34;:0 &#34;Y&#34;:0 &#34;Z&#34;:0 &#34;VX&#34;:0 &#34;VY&#34;:0 &#34;VZ&#34;:0&gt;</code></pre>
</figure><p>Sorry, I got sleepy. Is it done? I should have put a <code>break</code> in that code after printing out the star details. Of course, that is just cheating around the fact that parsing a large CSV file is <em>slow</em>. Perhaps it is time to try a database.</p>
<h3 id="creating-a-database">Creating a Database</h3>
<p>I would imagine that stuffing these values into a database should make simple questions like &ldquo;show me the star named &lsquo;Sol&rsquo;&rdquo; or &ldquo;count the stars within 10 light years&rdquo; pretty straightforward. We can use a lightweight database such as <em>inbox/SQLite</em>. There may be nearly 120,000 stars in the catalog, but that is trivial for SQLite. I have heard anecdotal reports of it being used for tables with millions of rows.</p>
<p>First, I want to install <code>sqlite3</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ port install sqlite3</code></pre>
</figure><p>I&rsquo;m not doing this on my <a href="http://ubuntu.com">Ubuntu</a> Linux machine, but if I was I&rsquo;d install both the <code>sqlite3</code> shell and the development libraries.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sudo apt-get install sqlite3 libsqlite3-dev</code></pre>
</figure><h4 id="the-sequel-library">The Sequel Library</h4>
<p>I have already chosen Sequel as my preferred Ruby database library, so I need to install that. Oh, and I should also install <a href="http://rubyforge.org/projects/sqlite-ruby/">sqlite3-ruby</a>. Sequel provides a nice layer of abstraction, but it does not contain the code which actually speaks to the database.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ gem install sequel
$ gem install sqlite3-ruby</code></pre>
</figure><p>We can use the <code>create_table</code> database method described on the <a href="http://sequel.rubyforge.org/rdoc/files/doc/migration_rdoc.html">Sequel migrations</a> page to build the table, rather than relying on my rather lightweight knowledge of SQLite schema definition. The dump of star data from our earlier CSV parsing code provides the hints we need to build a usable schema.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-ruby" data-lang="ruby"><span class="line"><span class="cl"><span class="nb">require</span> <span class="s1">&#39;csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">require</span> <span class="s1">&#39;sequel&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;hygxyz.csv&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="no">DB</span> <span class="o">=</span> <span class="no">Sequel</span><span class="o">.</span><span class="n">sqlite</span><span class="p">(</span><span class="s1">&#39;hyg.db&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="no">DB</span><span class="o">.</span><span class="n">table_exists?</span> <span class="ss">:stars</span>
</span></span><span class="line"><span class="cl">    <span class="no">DB</span><span class="o">.</span><span class="n">drop_table</span> <span class="ss">:stars</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="no">DB</span><span class="o">.</span><span class="n">create_table</span> <span class="ss">:stars</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="n">primary_key</span> <span class="ss">:id</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Integer</span> <span class="ss">:StarID</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Integer</span> <span class="ss">:HIP</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Integer</span> <span class="ss">:HD</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Integer</span> <span class="ss">:HR</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Integer</span> <span class="ss">:Gliese</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Integer</span> <span class="ss">:BayerFlamsteed</span>
</span></span><span class="line"><span class="cl">    <span class="nb">String</span>  <span class="ss">:ProperName</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:RA</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:Dec</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:Distance</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:PMRA</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:PMDec</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:RV</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:Mag</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:AbsMag</span>
</span></span><span class="line"><span class="cl">    <span class="nb">String</span>  <span class="ss">:Spectrum</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:ColorIndex</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:X</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:Y</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:Z</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:VX</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:VY</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Float</span>   <span class="ss">:VZ</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="no">CSV</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="ss">headers</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">converters</span><span class="p">:</span> <span class="ss">:numeric</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">row</span><span class="o">|</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span> <span class="s2">&#34;.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="no">DB</span><span class="o">[</span><span class="ss">:stars</span><span class="o">].</span><span class="n">insert</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">to_hash</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl"><span class="nb">puts</span></span></span></code></pre>
</figure><p>This script will set up the database and fill it with values from the CSV file. Each row is converted to a Hash, which makes the database <code>insert</code> method happy. There is also a little check and cleanup near the beginning. This is just in case there is a typo that messes up your code later on. It doesn&rsquo;t hurt to be cautious.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ ruby stellar.rb
.......</code></pre>
</figure><p>Go take a break. Make some coffee, catch up with your family, or play one more turn of Civilization. This is going to take a while. Me, I went for some more coffee.</p>
<h3 id="searching-the-database">Searching the Database</h3>
<p>We will look at the <a href="http://sequel.rubyforge.org/rdoc/files/doc/querying_rdoc.html">Sequel querying API</a> in a moment, but first let us make sure that the database returns plausible results to direct queries.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sqlite3 hyg.db
sqlite&gt; select count(*) from stars where distance &lt; 10;
320
sqlite&gt; select * from stars where propername = &#39;Sol&#39;;
1|0||||||Sol|0.0|0.0|4.848e-06|0.0|0.0|0.0|-26.73|4.85|G2V|0.656|0.0|0.0|0.0|0.0|0.0|0.0
sqlite&gt; .quit</code></pre>
</figure><p>Hopefully you noticed a big improvement in the speed of your searches by switching to a database. I sure did.</p>
<p>What if we tried the same queries with Ruby and Sequel? Let&rsquo;s open an <code>irb</code> prompt and test it out.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ irb
ruby-1.9.2-p0 &gt; require &#39;sequel&#39;
 =&gt; true
ruby-1.9.2-p0 &gt; DB = Sequel.sqlite(&#39;hyg.db&#39;)
 =&gt; #&lt;Sequel::SQLite::Database: &#34;sqlite:/hyg.db&#34;&gt;
ruby-1.9.2-p0 &gt; DB[:stars].first(ProperName: &#39;Sol&#39;)
 =&gt; {:id=&gt;1, :StarID=&gt;0, :HIP=&gt;nil, :HD=&gt;nil, :HR=&gt;nil, :Gliese=&gt;nil, :BayerFlamsteed=&gt;nil,
:ProperName=&gt;&#34;Sol&#34;, :RA=&gt;0.0, :Dec=&gt;0.0, :Distance=&gt;4.848e-06, :PMRA=&gt;0.0, :PMDec=&gt;0.0, :RV=&gt;0.0,
:Mag=&gt;-26.73, :AbsMag=&gt;4.85, :Spectrum=&gt;&#34;G2V&#34;, :ColorIndex=&gt;0.656, :X=&gt;0.0, :Y=&gt;0.0, :Z=&gt;0.0, :VX=&gt;0.0,
:VY=&gt;0.0, :VZ=&gt;0.0}
ruby-1.9.2-p0 &gt; DB[:stars].filter { distance &lt; 10 }.count
 =&gt; 320</code></pre>
</figure><p>Yes indeed. That was much faster. Let&rsquo;s close with something a little bit fancier: showing a table of information about all the stars in the catalog that are G Spectrum and have a proper name, ordered by their distance from Earth.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >ruby-1.9.2-p0 &gt; DB[:stars].filter(:Spectrum.like(&#39;G%&#39;)).filter(&#39;ProperName not null&#39;).order(:Distance).each { |row|
ruby-1.9.2-p0 &gt;     printf(&#34;%20s\t%4.2f\t%s\n&#34;, row[:ProperName], row[:Distance], row[:Spectrum])
ruby-1.9.2-p0 ?&gt;  }
              Sol    0.00    G2V
Rigel Kentaurus A    1.35    G2V
        82 G. Eri    6.06    G8V
 Groombridge 1830    9.16    G8Vp
     Vindemiatrix    31.35   G8IIIvar
            Nihal    48.80   G5II
=&gt; #&lt;Sequel::SQLite::Dataset: &#34;SELECT * FROM `stars` WHERE ((Spectrum like &#39;G%&#39;) AND (ProperName not null))&#34;&gt;</code></pre>
</figure><p>I encourage you to explore the Sequel querying API more on your own, but I need to wrap this up.</p>
<h2 id="conclusion">Conclusion</h2>
<p>All right. You&rsquo;ve got 119,617 stars with various characteristics, all sitting there waiting for you to think of something interesting to do with them. I just wanted to see how much easier it would be to parse a CSV in a high level language. Turns out, it&rsquo;s pretty easy. Explore the Ruby standard library and the <em>many</em> Rubygems that are available out in the big world. You&rsquo;ll probably have fun, and you&rsquo;ll almost definitely learn something.</p>]]></content:encoded>
</item>
<item>
  <title>Post: Thoughts on the word &#34;Bra&#34;</title>
  <link>https://randomgeekery.org/post/2010/09/thoughts-on-the-word-bra/</link>
  <pubDate>Thu, 30 Sep 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/09/thoughts-on-the-word-bra/</guid>
  <description>No, not the bra that provides appreciated support to countless women around the world.
NOTE
Originally posted to the now-defunct Vox blog on May 4, 2007.
I have been thinking about the slang word bra, which I already know is short for brother and used pretty much the same way I, as a West coast slacker, would use the word dude. First of all, I think it is a cool word and I would use it all the time if it didnt sound so affected coming out of my lips.</description>
   <category>post</category> 
   <category>post</category> 
   <category>babblings</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>No, not the bra that provides appreciated support to countless women around the world.</p>
<blockquote>
<p><strong>NOTE</strong></p>
<p>Originally posted to the now-defunct Vox blog on May 4, 2007.</p>
</blockquote>
<p>I have been thinking about the slang word &ldquo;bra,&rdquo; which I already know is short for &ldquo;brother&rdquo; and used pretty much the same way I, as a West coast slacker, would use the word &ldquo;dude.&rdquo; First of all, I think it is a cool word and I would use it all the time if it didnt sound so affected coming out of my lips. Second, where the heck did it start?</p>
<p>The first time I heard the word &ldquo;bra&rdquo; was watching <a href="http://www.dogthebountyhunter.com">Dog the Bounty Hunter</a> a couple of years ago. Why are you looking at me like that? I enjoy cheesy, semi-moralistic entertainment as much as the next guy. I figured &ldquo;bra&rdquo; was Hawaiian surfer slang and didnt think much more about the words origin.</p>
<blockquote>
<p><strong>NOTE</strong></p>
<p>My TV close captioning and a couple of readers point out that the spelling for the Hawaiian version is &ldquo;brah.&rdquo; Im on a roll, though.</p>
</blockquote>
<p>Last year I heard the term again, listening to <a href="https://song.link/i/1441133613">Ob La Di Ob La Da</a> by <a href="http://www.beatles.com">The
Beatles</a>.</p>
<p><figure>
    <img src="/attachments/img/2010/beatles-white-album.png" title="Pause for music" alt="cover of The Beatles White Album"/><figcaption>Pause for music</figcaption></figure></p>
<p>I hadnt listened to the song since before my exposure to Pacific Island bounty hunters, but this time the chorus jumped out at me:</p>
<blockquote>
<p>Ob-la-di, ob-la-da,
Life goes on, bra</p>
</blockquote>
<p>Of course I missed it before. It was just one more nonsense word in a chorus consisting almost entirely of nonsense words. But now I am thinking of it as a word and there are a few things Im suddenly driven to do.</p>
<ul>
<li>Make sure that they really are singing &ldquo;bra&rdquo; and not something else.</li>
<li>Find out where this usage started!</li>
</ul>
<p>It was easy to confirm the lyrics. A few seconds at Google took me to
<a href="http://www.stevesbeatles.com/songs/ob_la_di_ob_la_da.asp">Steves Beatle Page</a>, which provided lyrics. The page also had some notes about the recording itself, like the fact that it was recorded in July of 1968. That is useful information. The earliest usage Ive found so far is 1968, if I make the reasonable assumption that the Beatles meant &ldquo;bra&rdquo; the way I think they meant &ldquo;bra.&rdquo; It makes a little more sense than it being a nonsense word, and a lot more sense than the idea that they suddenly start blurting out the names of womens undergarments like Jeff from <a href="http://www.imdb.com/title/tt0237123">Coupling</a>.</p>
<p>Lets see if <a href="http://en.wikipedia.org/wiki/Bra">Wikipedia</a> can provide anything useful.</p>
<blockquote>
<p>&ldquo;Bra&rdquo;, slang for <a href="http://en.wikipedia.org/wiki/Brother">Brother</a>.</p>
</blockquote>
<p>So  no. Wikipedia is not going to be helpful this time. Oh well, I wouldnt have trusted the drunken wiki monkeys if they did have more information on the subject. <a href="http://www.google.com/search?q=define:bra">Google is having trouble, too.</a> The more common usage of &ldquo;bra&rdquo; refers to a breast support contraption, but Im not worried about finding what I need to know. This will just take a couple of extra minutes to dig deeper into the Internet hive mind.</p>
<p>I thought Id give <a href="http://www.urbandictionary.com">Urban Dictionary</a> a try, but its worse than useless. One definition that especially bugs me is trying to tell me that &ldquo;bra&rdquo; is just like &ldquo;bro&rdquo; but pronounced different. No kidding. But <em>why</em> is it pronounced different? That curiosity is whats driving my little search. The entry does have a grainy picture of an attractive bosom in a lovely pink brassiere, so I guess it wasnt a complete waste.</p>
<p>Lets go back to Google, this time looking for &ldquo;bra slang brother&rdquo;. South African slang is referred to a few times. This looks promising.</p>
<blockquote>
<p><em>bru</em> - male friend (shortening of <em>broer</em> meaning brother, see also <em>bra</em> below); compare <a href="http://en.wikipedia.org/wiki/American_English">American English</a>: &ldquo;dude&rdquo;</p>
<p><em>brah</em> - male friend (shortening of <em>brother</em>, se also <em>bru</em> above)</p>
</blockquote>
<p>These were on the Wikipedia entry for <a href="http://en.wikipedia.org/wiki/List_of_South_African_slang_words">African slang words</a>  maybe the drunken wiki monkeys could link from the bra disambiguation page to the South African slang page. The exact list is on a few other sites, but I cant tell who is plagiarizing who.</p>
<p>I see that somebody else is on a similar quest, judging by a post on the
<a href="http://forum.wordreference.com/showthread.php?t=481406">wordreference.com forums</a>. One of the posters there believes that the word is Hawaiian surfer slang that couldnt have existed in 1967  or 1968, as my info has shown me  or that Paul McCartney would not have been familiar with it if it did exist. I dont think I agree with either assumption. Even if it was nothing more than Hawaiian surfer slang, it could have had its origins a long time ago. After all, <a href="http://www.coffeetimes.com/surf.htm">Hawaii</a> has been home to surfers for centuries, and to casual surfers since the 1800s. And the Beatles didnt exactly spend all their days locked up in a
Liverpool basement.</p>
<p>The &ldquo;broer&rdquo; link is really tickling my curiosity. The <a href="http://www.bbc.co.uk/dna/h2g2/A4351402">BBC h2g2</a> is willing to put its foot down and say firmly that &ldquo;bra&rdquo; derives from the Afrikaans word &ldquo;broer&rdquo; and had its first usage in Cape Town. I love listening to people speaking Afrikaans or Dutch. So many of the words are similar to their English equivalents that my brain gets very frustrated that it cant understand what is being said. Listening to Dutch as an English speaker is fairly similar to listening to English after youve had a night of intensely heavy drinking. You know the words - or you think you know the words - you just cant make sense of what anyone is saying.</p>
<p>A <a href="https://web.archive.org/web/20071212030749/http://www.wavescape.co.za/bot_bar/surfrikan/slang.html">listing of South African slang</a> suggests that the rolled &ldquo;r&rdquo; at the end of &ldquo;broer&rdquo; is too hard for lazy English speakers, and thats how it got shortened to &ldquo;bru&rdquo; and &ldquo;bra.&rdquo; I can believe that. You should hear my attempts at speaking Spanish sometime. So at this point it looks like usage of &ldquo;bra&rdquo; as equivalent to &ldquo;bro&rdquo; or &ldquo;dude&rdquo; may have from somewhere in the area of Cape Town, South Africa. Or perhaps not.</p>
<p>What about that Beatles song? Well, this one should have been obvious to me from the start. Paul McCartney was grooving on the reggae! Jamaican <a href="http://www.desmonddekker.com/">Desmond Dekker</a>, considered by some to be the first reggae star, had recently released singles in England  <a href="https://song.link/i/1147768992">007 (Shanty Town)</a> in 1967, and <a href="https://song.link/i/1147769697">Israelites</a> in 1968 (although the hit version wasnt released until 1969). There was at least one popular reggae track floating around in the ether while Ob-La-Di Ob-La-Da was being written. In fact, the Desmond referred to in the song is none other than Desmond Dekker. I highly recommend listening to Dekkers &ldquo;King of Ska&rdquo; if you can find the track. It is good stuff, and you can hear the influence he had on  pretty much every ska or reggae song that came after.</p>
<p>&ldquo;Bra&rdquo; is Jamaican slang for &ldquo;brother,&rdquo; according to the Dictionary of Jamaican English. It was first recorded in that form in 1943, which of course means that it could have been widespread in Jamaican slang by 1967-1968. Interestingly enough, &ldquo;bra&rdquo; is a shortened form of the Jamaican slang &ldquo;broer&rdquo; from 1907. &ldquo;Broer&rdquo; looks a lot like &ldquo;broer&rdquo;, but it apparently doesnt have the same roots. Remember what I was saying before about Dutch/Afrikaans and English? I think this is a good example.</p>
<p>&ldquo;Broer&rdquo; might sound more familiar to Americans as &ldquo;Brer,&rdquo; as in <a href="http://www.americanfolklore.net/brer-rabbit.html">Brer Rabbit</a>. Brer Rabbit was the source of my favorite underdog stories as a small child. Oh. Ive been pronouncing &ldquo;Brer&rdquo; wrong my whole life. First off, its supposed to be a shortened form of the English word &ldquo;brother,&rdquo; with the ending &ldquo;er&rdquo; sound softened dramatically  a Southern thing, I think. You end up with something sounding more like &ldquo;Bruh Rabbit.&rdquo; &ldquo;Bra&rdquo; may in fact have split origins: one thread coming from the Southern US and Jamaica, and the other coming from South Africa.</p>
<p>The drunken monkeys <a href="http://en.wikipedia.org/wiki/Br%27er_Rabbit">tell us</a> that the &ldquo;Brer&rdquo; in Brer Rabbits name came about due to a custom in many African cultures of people referring to each other as &ldquo;brother.&rdquo; Im too tired now to verify this  which may be the ultimate source of Wikipedias power  but its a piece of trivia that amuses me. The character Desmond (probably not named after the King of Ska) in the show <a href="http://www.losttvshow.org">Lost</a> (filmed in Hawaii, home state of that endearingly scruffy bounty hunter of basic cable who says &ldquo;bra&rdquo; all the time) also has a habit of addressing everybody as &ldquo;brother&rdquo;. I love random connections.</p>
<p>I think thats enough time spent exploring the origins of a single random slang term.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Rakudo</title>
  <link>https://randomgeekery.org/post/2010/09/rakudo/</link>
  <pubDate>Wed, 08 Sep 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/09/rakudo/</guid>
  <description>&lt;p&gt;The &lt;a href=&#34;https://randomgeekery.org/card/perl/&#34;&gt;Perl&lt;/a&gt; world has evolved over the years. Once upon a time, it was a simple glue language that made life easier for system administrators. Its grown up a lot since then, and now powers much of the Internet. The language has added new features, and the &lt;a href=&#34;http://cpan.org&#34;&gt;CPAN&lt;/a&gt; has made a dizzying number of libraries available.&lt;/p&gt;</description>
   <category>post</category> 
   <category>post</category> 
   <category>raku-lang</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>The <a href="/card/perl/">Perl</a> world has evolved over the years. Once upon a time, it was a simple glue language that made life easier for system administrators. It&rsquo;s grown up a lot since then, and now powers much of the Internet. The language has added new features, and the <a href="http://cpan.org">CPAN</a> has made a dizzying number of libraries available.</p>
<p>Yet in a way, Perl was stuck. Developers had to be careful about adding new features, for fear of breaking those scripts that power much of the Internet. The idea of a <a href="/card/raku/">new Perl</a> was <a href="http://www.perl.com/pub/2000/07/perl6.html">announced</a> in 2000, and the next few years were full of good intentions and bad arguments. People debated about what Perl 6 would be, how it would be written, or even whether or not Perl 6 was needed. Eventually, the bickering died down and the real work began. <a href="http://rakudo.org">Rakudo</a>, which runs on the <a href="/card/parrot/">Parrot</a> virtual machine, has been available as the main Perl 6 implementation for some time now. <a href="http://github.com/rakudo/star">Rakudo Star</a> is a full distribution of Rakudo for early adopters like you and me. If you hear me talk about Perl 6, I&rsquo;m probably talking about Rakudo. If you hear me talk about the Rakudo distribution, I&rsquo;m probably talking about Rakudo Star.</p>
<p>There&rsquo;s still some bickering out there. There always will be. Some people thrive on conflict. Meanwhile, Rakudo runs and it&rsquo;s pretty darn cool.</p>
<h2 id="getting-started">Getting Started</h2>
<p>There is a lot of material to get you started with Rakudo. The <a href="http://github.com/perl6/book">Perl 6 Book</a> is included with Rakudo Star. Moritz Lenz has written an amazing <a href="http://perlgeek.de/en/article/5-to-6">series of blog posts</a> helping Perl 5 programmers transition to Perl 6. There is also a <a href="http://en.wikibooks.org/wiki/Perl_6_Programming">Perl 6 wikibook</a>. If you want to learn more about the guts of Rakudo, take a look at Parrot.</p>
<p>I may start writing some Perl 6 Babysteps eventually, but it looks like that ground is pretty well covered for now.</p>]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 0d - The SpaceTrade Project</title>
  <link>https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/</link>
  <pubDate>Mon, 02 Aug 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/</guid>
  <description>I might be done with the Stellar application for the moment, but I dont think Im done with the space theme in Parrot yet.
Back in the ancient days, there was a nifty game called Star Trader. You and your friends were interstellar merchants trying to earn a few credits (or whatever) in a cold and uncaring universe. Star Trader has had many popular descendants, which have evolved over the generations into games like Trade Wars Rising, Oolite and Eve Online.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>I might be done with the <a href="/post/2010/07/parrot-babysteps-0x-the-stellar-app/">Stellar</a> application for the moment, but I don&rsquo;t think I&rsquo;m done with the space theme in <a href="/card/parrot/">Parrot</a> yet.</p>
<p>Back in the ancient days, there was a nifty game called <a href="https://en.wikipedia.org/wiki/Star_Trader">Star Trader</a>. You and your friends were interstellar merchants trying to earn a few credits (or whatever) in a cold and uncaring universe. Star Trader has had <em>many</em> popular descendants, which have evolved over the generations into games like <a href="http://tradewarsrising.com">Trade Wars Rising</a>,  <a href="http://www.oolite.org/">Oolite</a> and <a href="http://eveonline.com">Eve Online</a>. Those games are interactive and fun and great ways to kill many hours, but I&rsquo;ve got an itch for something old school. I want to revisit the joy of a text interface that demands your imagination work overtime while you figure out what is going on.</p>
<p>It is possible that I have been playing <a href="http://www.bay12games.com/dwarves/">Dwarf Fortress</a> a little bit too much for my own good.</p>
<p>This one is going to take some work. It is a fairly elaborate game. The map is random, markets change, and merchants can be haggled with. I can use the <a href="https://web.archive.org/web/20131222221016/http://www.dunnington.u-net.com/public/basicgames/TRADES">original code</a> as a resource, but not very well. The listing I could find was written in a HP-BASIC dialect that I am unfamiliar with. So I have to do more than just copy the game. I&rsquo;ll have to make a game inspired by Star Trader instead. That seems to be what all the cool kids are doing - assuming you use a rather flexible definition of &ldquo;cool.&rdquo;</p>
<p>I talked about using a text interface, but I know that eventually I will want to choose my own interface for the game. Players can choose their own approach, and bored coders will be able to create new ones. I will start by keeping the game logic as abstract as I can, and worry about the details of play later.</p>
<h2 id="spacetrade-summary">SpaceTrade Summary</h2>
<p>Space Trade is a turn-based game in which one or more players assumes the role of an interstellar merchant in the future. The game has a fixed number of turns, determined during game setup. Players are competing to have a pilot with the highest worth at the end of the game. The single player goal is to beat her own previous high scores.</p>
<p>Game play occurs on a map of star systems. Each star system has a trade classification, which makes the price of goods vary from one system to the next. There is a port in every system for traders to buy and sell goods, or to upgrade their ship&rsquo;s capabilities. Traders may attempt to haggle for a more favorable price, but this might not work. As the game progresses, markets may change based on trade activity. A glut of a particular good could temporarily reduce its value, or a run on that good could temporarily increase its value.</p>
<p>Traders may encounter hazards such as planetoids or pirates while travelling between systems. The results of these encounters could be cargo loss or damage to the trader&rsquo;s ship. If a ship accumulates enough damage without repair, it could be destroyed. Destruction of a ship ends the game for that trader.</p>
<h3 id="development-tasks">Development Tasks</h3>
<p>My summary is a little vague compared to your average game, but there are a lot of juicy programming tasks in there.</p>
<ul>
<li>Creating a star</li>
<li>Building a star map</li>
<li>Creating a new trader</li>
<li>Buying cargo</li>
<li>Selecting and travelling to a new system</li>
<li>Selling cargo</li>
<li>Dealing with changing markets</li>
<li>Haggling with merchants</li>
<li>Coping with environmental hazards (pirates, planetoids, etcetera)</li>
<li>Enabling multiple players</li>
<li>Upgrading a ship</li>
<li>Scoring the endgame</li>
<li>Tracking high scores</li>
<li>Saving a game in play</li>
<li>Loading a saved game</li>
</ul>
<p>At each stage, we will work on the simple text interface and add randomization to make gameplay interesting.</p>
<p>I have never written a game in Parrot before. I have not written many games in <em>any</em> language. I understand if one of your questions is &ldquo;why not use language X?&rdquo; - where <em>X</em> is Python, Perl, Ruby, Rakudo, D, or something else. I might use language X another time, but then it would be part of the X Babysteps rather than the Parrot Babysteps.</p>
<p>Another question might be &ldquo;Are we <em>ever</em> going to use Parrot to write a language?&rdquo; Actually, yes. I&rsquo;m going to put together a simple script language that handles game behavior. Not a powerful megasmart language for high end projects, but something for building the star map and playing the game itself. It will be used for saving and sharing games, and inevitably for hacking game details. Hey, what fun is a game if you can&rsquo;t hack it?</p>
<p>That&rsquo;s three more on-going development tasks, then:</p>
<ul>
<li>Developing an interactive user shell</li>
<li>Randomizing game play elements</li>
<li>Creating a game scripting language</li>
</ul>
<p>This is more complex than Stellar, and it will take more than a few steps to finish it. I am certain there will be a lot of new Parrot territory to explore.</p>
<p>This should be fun. Let&rsquo;s get started!</p>
<h2 id="setting-up-the-project">Setting up the project</h2>
<p>Thanks to Stellar, I already know how I like to prepare my workspace for a new project.  The setup from <a href="/post/2010/04/parrot-babysteps-09-simple-projects/">parrot-babysteps-09-simple-projects</a> will provide the starting point for SpaceTrade.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mkdir spacetrade
$ mkdir spacetrade/t
$ mkdir spacetrade/lib
$ cd spacetrade</code></pre>
</figure><p>The <code>setup.pir</code> script will start out the same as the one used for Stellar.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-01/setup.pir
.sub &#39;main&#39; :main
    .param pmc args
    $S0 = shift args # Ignore my own filename
    load_bytecode &#39;distutils.pbc&#39;

    # find out what command the user has issued.
    .local string directive
    directive = shift args

    # Used by test mode
    .local string prove_exec
    prove_exec = get_parrot()

    setup(directive, &#39;prove_exec&#39; =&gt; prove_exec)
.end</code></pre>
</figure><p>There is one basic feature I want to get out of the way before I start handling game logic. User interaction is important. Oh sure, there may eventually be interfaces in <a href="https://github.com/parrot/parrot/blob/master/runtime/parrot/library/Curses.pir">Curses</a> or <a href="https://github.com/parrot/parrot/tree/master/runtime/parrot/library/SDL">SDL</a>, but all that&rsquo;s needed for now is a simple command line <a href="http://en.wikipedia.org/wiki/Shell_%28computing%29">shell</a>. This shell will be used to examine the nuts and bolts of SpaceTrade and to play a simple text-based version of the game.</p>
<h3 id="the-spacetrade-interactive-shell">The SpaceTrade Interactive Shell</h3>
<p>I believe that every interactive shell needs a few minimal components to be useful.</p>
<ul>
<li>A command to quit</li>
<li>A command to get help</li>
<li>A reasonable way to handle invalid input</li>
</ul>
<p>A sample session with such a minimal shell might look like this:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot lib/spacetrade.pir
Welcome to SpaceTrade!
Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.
&gt; waffles!
Unknown command: waffles!
Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.
&gt; :help
COMMANDS
:help    This view
:quit    Exit the shell
&gt; :quit
Goodbye!
$</code></pre>
</figure><p>Why do I imagine this shell having commands prefixed by a <code>:</code> character? Well, &ldquo;normal&rdquo; commands would look normal, but behavior like getting help or quitting the game are only important for dealing with the shell. I want those special shell commands to look different from the normal game commands.</p>
<p>Of course, I may change my mind later. I am fickle.</p>
<p>What is the smallest amount of code I can use to get this end result and still feel comfortable?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-01/lib/spacetrade.pir
.sub &#39;main&#39; :main
    run_shell()
.end

.sub run_shell
    .local string input
    .local pmc    stdin
    .const string PROMPT     = &#39;&gt; &#39;
    .const string QUICK_HELP = &#34;Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.&#34;

    stdin = getstdin

    say &#34;Welcome to SpaceTrade!&#34;
    say QUICK_HELP

  READLINE:
    input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if input == &#39;:quit&#39; goto EXIT
    if input == &#39;:help&#39; goto SHOW_USAGE
    goto SHOW_ERROR

  SHOW_USAGE:
    say &#34;COMMANDS&#34;
    say &#34;:help    This view&#34;
    say &#34;:quit    Exit the shell&#34;
    goto READLINE

  SHOW_ERROR:
    .local string error_message
    error_message = &#34;Unknown command: &#34;
    error_message .= input
    say error_message
    say QUICK_HELP
    goto READLINE

  EXIT:
    say &#34;Goodbye!&#34;
.end</code></pre>
</figure><p>This works, but it doesn&rsquo;t look right.</p>
<p>For a start, the commands are kind of a mess. When I add commands, I will have to add both an <code>if</code> check in the <code>READLINE</code> section and a line of output in the <code>SHOW_USAGE</code> section. Then there are the blocks I would have to add to provide that actual functionality. No, I do not like this at all. The shell commands should be better organized so that adding and managing features is as easy as possible.</p>
<p>One approach would be to add a registry which stores the commands recognized by the shell.</p>
<h3 id="creating-a-command-registry">Creating a Command Registry</h3>
<p>The idea is that I could have a simple structure that stores information about available commands, and the application could add commands as needed. Let&rsquo;s start with a simple Hash and two subroutines for adding and evaluating shell commands.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-02/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(1)

    .local pmc    commands
    .local string expected
    .local string output

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)
    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)
.end

.sub say_dude
    .return(&#34;Dude!&#34;)
.end</code></pre>
</figure><p>The first sub that&rsquo;s needed is <code>register_command</code>, which will add a <code>:dude</code> entry in the <code>commands</code> Hash with appropriate information.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-02/lib/spacetrade.pir

.sub register_command
    .param pmc    commands
    .param string name
    .param string sub_name
    .param string explanation

    .local pmc    command
    .local pmc    callback

    command = new &#39;Hash&#39;
    command[&#39;sub_name&#39;] = sub_name
    command[&#39;explanation&#39;] = explanation
    commands[name] = command

  RETURN_COMMANDS:
    .return(commands)
.end</code></pre>
</figure><p>There is no special magic going on here. <code>command[':dude']</code> points to a Hash containing a subroutine name and an explanation of the command. <code>commands</code> is returned to the caller once the new command has been added.</p>
<p>You can probably figure out what I expect to happen from the test code. I have a <code>say_dude</code> sub, and somehow I expect the shell to figure out how to call that sub when I ask for it by sending the <code>:dude</code> command. We&rsquo;ve actually already done this, back when we were grabbing the <code>chomp</code> sub in <a href="/post/2009/10/parrot-babysteps-06-files-and-hashes/">/post/2009/06-files-and-hashes/</a>. The <code>get_global</code> <a href="http://docs.parrot.org/parrot/latest/html/src/ops/var.ops.html">variable opcode</a> will look for a variable with a specified name and return it to us if it exists.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-02/lib/spacetrade.pir
.sub evaluate_command
    .param pmc    commands
    .param string name

    .local string sub_name
    .local pmc    command_sub
    .local string output

    sub_name = commands[name;&#39;sub_name&#39;]
    command_sub = get_global sub_name
    output = command_sub()

    .return(output)
.end</code></pre>
</figure><p>There is one new bit of strangeness here, though:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >sub_name = commands[name;&#39;sub_name&#39;]</code></pre>
</figure><p>This is called a &ldquo;complex key,&rdquo; and lets us directly access the values in the Hash held at <code>commands[name]</code>. Each index in a complex key is separated by a semicolon (<code>;</code>) character.  Without a complex key, we might have to do something like this:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$P1 = commands[name]
sub_name = $P1[&#39;sub_name&#39;]</code></pre>
</figure><p>I did not realize I could use a complex key until I scanned the <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch04_variables.pod.html">variables chapter</a> of the Parrot PIR Book. It is important to keep reviewing documentation, even if you think you already know a solution. Remember:  regardless of what you know, there is probably a better way.</p>
<p>It is time to add basic error handling to the shell. <code>evaluate_command</code> needs to handle two major error cases.</p>
<ol>
<li>User tries a command that doesn&rsquo;t exist</li>
<li>User tries a command that points to a nonexistent subroutine.</li>
</ol>
<p>Okay, let&rsquo;s add the tests.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-03/t/01-shell-metacommands.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(3)

    .local pmc    commands
    .local string expected
    .local string output

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)
    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)

    expected = &#34;Unknown command: :sweet&#34;
    output = evaluate_command(commands, &#39;:sweet&#39;)
    is(output, expected, &#39;Shell should warn about unknown commands&#39;)

    commands = register_command(commands, &#39;:whats-mine-say&#39;, &#39;whats_mine_say&#39;, &#34;What&#39;s mine say?&#34;)
    expected = &#34;Invalid command: :whats-mine-say points to nonexistent sub whats_mine_say&#34;
    output = evaluate_command(commands, &#39;:whats-mine-say&#39;)
    is(output, expected, &#39;Shell should warn about invalid commands&#39;)
.end

# ...</code></pre>
</figure><p><code>evaluate_command</code> is a little more complicated now, but it is still manageable.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-03/lib/spacetrade.pir

# ...

.sub evaluate_command
    .param pmc    commands
    .param string name

    .local string sub_name
    .local pmc    command_sub
    .local string output

    sub_name = commands[name;&#39;sub_name&#39;]
    unless sub_name goto UNKNOWN_COMMAND
    command_sub = get_global sub_name
    if_null command_sub, INVALID_COMMAND
    output = command_sub()
    goto RETURN_OUTPUT

  UNKNOWN_COMMAND:
    output = &#34;Unknown command: &#34; . name
    goto RETURN_OUTPUT

  INVALID_COMMAND:
    output = &#34;Invalid command: &#34; . name
    output .= &#34; points to nonexistent sub &#34;
    output .= sub_name

  RETURN_OUTPUT:
    .return(output)
.end

# ...</code></pre>
</figure><p>One thing that might catch your attention is the <code>if_null</code> opcode.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >if_null command_sub, INVALID_COMMAND</code></pre>
</figure><p>This will check if <code>command_sub</code> is null, and branch to <code>INVALID_COMMAND</code> if the subroutine we just tried to grab is indeed null. To be perfectly honest with you, I&rsquo;m not sure if a branch is the same as a <code>goto</code>. It behaves the same in this code, so for now I will pretend that it is the same.</p>
<h3 id="setting-up-those-default-shell-commands">Setting Up Those Default Shell Commands</h3>
<p>This ends up working pretty much the same as the earlier code did, and it&rsquo;s a bit more flexible. Is this how we make programming languages in Parrot? Well, no. This is not how we make programming languages in Parrot. This is a very simple shell which will have a few simple commands, but try to pass everything else off to the game itself. Proper language development is still a few Babysteps away.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-04/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(5)

    .local pmc    commands
    .local string expected
    .local string output

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)
    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)

    expected = &#34;Unknown command: :sweet&#34;
    output = evaluate_command(commands, &#39;:sweet&#39;)
    is(output, expected, &#39;Shell should warn about unknown commands&#39;)

    commands = register_command(commands, &#39;:whats-mine-say&#39;, &#39;whats_mine_say&#39;, &#34;What&#39;s mine say?&#34;)
    expected = &#34;Invalid command: :whats-mine-say points to nonexistent sub whats_mine_say&#34;
    output = evaluate_command(commands, &#39;:whats-mine-say&#39;)
    is(output, expected, &#39;Shell should warn about invalid commands&#39;)

    commands = register_default_commands()

    expected =&lt;&lt;&#39;EXPECTED&#39;
COMMANDS
:help    This view
:quit    Exit the shell
EXPECTED
    output = evaluate_command(commands, &#39;:help&#39;)
    is(output, expected, &#39;:help should be a registered default command&#39;)

    expected = &#39;&#39;
    output = evaluate_command(commands, &#39;:quit&#39;)
    is(output, expected, &#39;:quit should be a registered default command that returns an empty string&#39;)
.end

.sub say_dude
    .return(&#34;Dude!&#34;)
.end</code></pre>
</figure><p>The test code that has already been written shows a clear path for registering default commands. All that&rsquo;s needed is the subroutines that will be invoked when the command is called.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >example-0d-04/lib/spacetrade.pir
.sub register_default_commands
    .local pmc commands

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:help&#39;, &#39;default_help&#39;, &#39;This view&#39;)
    commands = register_command(commands, &#39;:quit&#39;, &#39;default_quit&#39;, &#39;Exit the shell&#39;)

    .return(commands)
.end

.sub default_help
    .local string output

    output =&lt;&lt;&#39;OUTPUT&#39;
COMMANDS
:help    This view
:quit    Exit the shell
OUTPUT

    .return(output)
.end

.sub default_quit
    .local string output
    output = &#39;&#39;
    .return(output)
.end</code></pre>
</figure><p>There&rsquo;s a problem.</p>
<p>The problem is that I had to cheat on <code>default_help</code>. See, the way that I set up <code>evaluate_commands</code> is to directly invoke the registered subroutine without any arguments. I would prefer that <code>default_help</code> examined the currently registered commands and provided a real summary. It should even include my magnificent <code>:dude</code> command in the summary.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(6)

    .local pmc    commands
    .local string expected
    .local string output

    commands = register_default_commands()

    expected =&lt;&lt;&#39;EXPECTED&#39;
COMMANDS
:help    This view
:quit    Exit the shell
EXPECTED
    output = evaluate_command(commands, &#39;:help&#39;)
    is(output, expected, &#39;:help should be a registered default command&#39;)

    expected = &#39;&#39;
    output = evaluate_command(commands, &#39;:quit&#39;)
    is(output, expected, &#39;:quit should be a registered default command that returns an empty string&#39;)

    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)

    expected =&lt;&lt;&#39;EXPECTED&#39;
COMMANDS
:dude    Say &#34;Dude!&#34;
:help    This view
:quit    Exit the shell
EXPECTED
    output = evaluate_command(commands, &#39;:help&#39;)
    is(output, expected, &#39;:help should reflect registered commands&#39;)

    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)

    expected = &#34;Unknown command: :sweet&#34;
    output = evaluate_command(commands, &#39;:sweet&#39;)
    is(output, expected, &#39;Shell should warn about unknown commands&#39;)

    commands = register_command(commands, &#39;:whats-mine-say&#39;, &#39;whats_mine_say&#39;, &#34;What&#39;s mine say?&#34;)
    expected = &#34;Invalid command: :whats-mine-say points to nonexistent sub whats_mine_say&#34;
    output = evaluate_command(commands, &#39;:whats-mine-say&#39;)
    is(output, expected, &#39;Shell should warn about invalid commands&#39;)

.end

.sub say_dude
    .return(&#34;Dude!&#34;)
.end</code></pre>
</figure><p>How am I supposed to do this? Let&rsquo;s start by rewriting <code>default_help</code> the way it should work: by preparing a sorted list of registered commands and their summaries.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/lib/spacetrade.pir
.sub default_help
    .param pmc    commands
    .local string output
    .local pmc    command_iter
    .local pmc    command_keys
    .local string key

    command_keys = new &#39;ResizablePMCArray&#39;
    command_iter = iter commands

  NEXT_COMMAND:
    unless command_iter goto PREPARE_OUTPUT
    key = shift command_iter
    push command_keys, key
    goto NEXT_COMMAND

  PREPARE_OUTPUT:
    output = &#34;COMMANDS\n&#34;
    command_keys.&#39;sort&#39;()

    .local string command_name
    .local string command_explanation
    .local string command_summary
    command_iter = iter command_keys

  NEXT_SUMMARY:
    unless command_iter goto RETURN_OUTPUT
    command_name = shift command_iter
    command_explanation = commands[command_name;&#39;explanation&#39;]
    command_summary = command_name . &#39;    &#39;
    command_summary .= command_explanation
    command_summary .= &#34;\n&#34;
    output .= command_summary
    goto NEXT_SUMMARY

  RETURN_OUTPUT:
    .return(output)
.end</code></pre>
</figure><p>A little explanation about <code>default_help</code> couldn&rsquo;t hurt. Hashes use their own special tricks to make storing their elements more effective, which means you have no guarantee of getting them in any particular order. I want to see the commands in alphabetical order, so I will have to handle the ordering myself. I did that by first building a list of keys.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >    command_keys = new &#39;ResizablePMCArray&#39;
    command_iter = iter commands

  NEXT_COMMAND:
    unless command_iter goto PREPARE_OUTPUT
    key = shift command_iter
    push command_keys, key
    goto NEXT_COMMAND</code></pre>
</figure><p>Once that list was constructed, it needed to be put in some sort of order. Luckily, the Array PMCs come with a prepackaged <code>sort()</code> method - a special subroutine that works directly with the elements of the array.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >    command_keys.&#39;sort&#39;()</code></pre>
</figure><p>The default sort behavior works for me. In this case they will be sorted more or less alphabetically.</p>
<p>Now, I could add a lot of code to <code>evaluate_command</code> that will magically determine what sort of arguments are required by the command, and to behave appropriately. But before I go doing a significant rewrite - how about an experiment? Maybe I can just call every command with <code>commands</code> as a parameter, and see what happens in the tests.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/lib/spacetrade.pir

# ...

.sub evaluate_command
    .param pmc    commands
    .param string name

    .local string sub_name
    .local pmc    command_sub
    .local string output

    sub_name = commands[name;&#39;sub_name&#39;]
    unless sub_name goto UNKNOWN_COMMAND
    command_sub = get_global sub_name
    if_null command_sub, INVALID_COMMAND
    output = command_sub(commands)
    goto RETURN_OUTPUT

  UNKNOWN_COMMAND:
    output = &#34;Unknown command: &#34; . name
    goto RETURN_OUTPUT

  INVALID_COMMAND:
    output = &#34;Invalid command: &#34; . name
    output .= &#34; points to nonexistent sub &#34;
    output .= sub_name

  RETURN_OUTPUT:
    .return(output)
.end</code></pre>
</figure><p>You have to be willing to experiment, because the results may occasionally surprise you.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot t/01-shell-metacommands.t
1..6
ok 1 - :help should be a registered default command
ok 2 - :quit should be a registered default command that returns an empty string
ok 3 - :help should reflect registered commands
ok 4 - User command &#34;:dude&#34; should result in string &#34;Dude!&#34;
ok 5 - Shell should warn about unknown commands
ok 6 - Shell should warn about invalid commands</code></pre>
</figure><p>How about that - it worked. PIR subroutines will apparently ignore positional parameters that they didn&rsquo;t ask for, which means that <code>evaluate_command</code> can call <code>say_dude</code> and <code>default_help</code> with the same parameter list and nothing bad will happen.</p>
<h3 id="the-new-and-slightly-improved-shell">The New and Slightly Improved Shell</h3>
<p>A lot of work has gone into making the shell easier to use for me and people who want to hack on the game in the future. Let&rsquo;s apply that work to the <code>run_shell</code> subroutine itself.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/lib/spacetrade.pir

.sub run_shell
    .local pmc    commands
    .local string input
    .local string output
    .local pmc    stdin
    .const string PROMPT     = &#39;&gt; &#39;
    .const string QUICK_HELP = &#34;Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.&#34;

    commands = register_default_commands()
    stdin = getstdin

    say &#34;Welcome to SpaceTrade!&#34;
    say QUICK_HELP

  READLINE:
    input = stdin.&#39;readline_interactive&#39;(PROMPT)
    output = evaluate_command(commands, input)
    unless output goto EXIT
    say output
    goto READLINE

  EXIT:
    say &#34;Goodbye!&#34;
.end</code></pre>
</figure><p>It&rsquo;s certainly shorter than what I started with. How well does it work?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot lib/spacetrade.pir
Welcome to SpaceTrade!
Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.
&gt; :dude
Unknown command: :dude
&gt; :help
COMMANDS
:help    This view
:quit    Exit the shell

&gt; :quit
Goodbye!</code></pre>
</figure><p>It isn&rsquo;t perfect, but it will work for the moment. This new shell has most of the core behavior from the original, and we have shown that it will not be hard to add new commands. There is still a large part of me that thinks the code for the shell should be tucked into its own corner, where it cannot get mixed up with the code for the actual game. That will have to wait for the next step, though.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Where&#39;d He Go?</title>
  <link>https://randomgeekery.org/post/2010/07/whered-he-go/</link>
  <pubDate>Tue, 27 Jul 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/07/whered-he-go/</guid>
  <description>&lt;p&gt;I havent updated this blog in a while, and to be honest I dont really plan to. I tend to dump my thoughts of the moment on
&lt;a href=&#34;http://www.google.com/profiles/brian.wisti#buzz&#34;&gt;Google Buzz&lt;/a&gt;, while the content I intend to improve and maintain
is still at &lt;a href=&#34;https://randomgeekery.org/&#34;&gt;my site&lt;/a&gt;.&lt;/p&gt;</description>
   <category>post</category> 
   <category>post</category> 
   <category>blogspot</category> 
  <content:encoded><![CDATA[<p>I haven&rsquo;t updated this blog in a while, and to be honest I don&rsquo;t really plan to. I tend to dump my thoughts of the moment on
<a href="http://www.google.com/profiles/brian.wisti#buzz">Google Buzz</a>, while the content I intend to improve and maintain
is still at <a href="/">my site</a>.</p>
<h2 id="a-few-years-pass-">A few years pass &hellip;</h2>
<p>Heh. Google Buzz. Well I do spend time on <a href="https://plus.google.com/&#43;BrianWisti">Google+</a>, but I am elsewhere too.
Check the links in the footer for your preferred social network.</p>]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 0c - The Stellar App</title>
  <link>https://randomgeekery.org/post/2010/07/parrot-babysteps-0x-the-stellar-app/</link>
  <pubDate>Thu, 15 Jul 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/07/parrot-babysteps-0x-the-stellar-app/</guid>
  <description>Our search journey continues. We have accomplished the hard part: checking a single star to see if it has the traits were looking for. Today we just have to use that logic to search a set of stars. First well examine a handpicked selection. Guess what happens after that? We finally get back into the full HYG Catalog and search for stars from the command line. Thats right. After all this work, stellar grows up and becomes an application.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>space</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>Our search journey continues. We have accomplished the hard
part: <a href="/post/2010/06/parrot-babysteps-0b-subroutine-params">checking a single star</a> to see if it has the traits we&rsquo;re looking for.
Today we just have to use that logic to search a set of stars. First we&rsquo;ll
examine a handpicked selection. Guess what happens after that? We finally get
back into the full <a href="http://www.astronexus.com">HYG Catalog</a> and search for stars from the command line.
That&rsquo;s right. After all this work, <code>stellar</code> grows up and becomes an
application.</p>
<h3 id="note">Note</h3>
<p>There are easier ways to get searches out of a large CSV file. If
that was really all I wanted to do, I could use a higher level language like
<a href="/tags/perl/">Perl</a> or <a href="/tags/python/">Python</a> to feed the CSV into a <a href="http://sqlite.org">SQLite</a> database and directly
query the database. However, we are not building a SQL database. We are learning
how to do interesting things with <a href="/card/parrot/">Parrot</a>.</p>
<h2 id="building-a-catalog-and-searching-it">Building a Catalog and Searching It</h2>
<p>The first thing that&rsquo;s tripping me up is how to set up the catalog itself. You
know the &ldquo;set of stars&rdquo; I was talking about? The easy way to do this from a test
is to have a few CSV strings for some sample stars, apply <code>extract_from_csv</code> to
each of them, push each star into an array, then search through the array. Thing
is, I <em>know</em> that this is not going to be acceptable when I get to the real data.
I expect this application to be one where you run it from the command line,
using your search conditions as command line arguments. Loading all the data
before searching it takes time. I should write this code so that it searches
while reading in data. That would be much faster.</p>
<p>On the other hand, what if I add an interactive prompt to this application later?
Loading the full catalog into memory before applying searches could be
faster in the long run compared to reading the data file for every search.</p>
<p>That is trying to predict the future, though. I know how I want to use this
catalog today. I want to run a search and see the results as soon as the
application knows about them.</p>
<aside>
I will share a secret. I spent a day writing the "load then
search" approach to building the catalog. Guess what? It is unbearably slow at
my current Parrot skill level. I am confident that this is only
slow because my code overall is simplistic. Maybe I can revisit this idea after
learning more about Parrot.
</aside>
<h3 id="searching-the-catalog">Searching The Catalog</h3>
<p>I do not want to dig right into searching the full 119,617 entries of the real
catalog. Instead, let&rsquo;s set up a small test catalog and write some tests.</p>
<p>Where you put your test data is a matter of taste. I will be keeping my data in
a folder named <code>data</code>. That seems reasonable.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mkdir data</code></pre>
</figure><p>Only a few entries are needed in the test catalog. We just need to be sure that
the code works with a CSV file with the same structure as the HYG database.
I&rsquo;ll grab Sol, another G2V spectrum star, and a K3V star.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0c-01/data/test-catalog.csv
StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ
0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0
80,80,224817,,,,,0.01611947,-11.82353722,64.143681847338,419.04,-82.83,,8.40,4.36423057594421,G2V,0.566,62.7822,0.26494,-13.14292,-5.827e-06,0.000130277,-2.5209e-05
7358,7372,9770,,Gl  60 A,,,1.58359898,-29.91056753,23.6462520690471,85.56,96.58,34.2,7.11,5.2411884257345,K3V,0.909,18.76027,8.25627,-11.79114,2.8852e-05,2.3413e-05,-7.844e-06</code></pre>
</figure><p>The test data is out of the way, so now I feel comfortable writing the tests
that use it.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0c-01/t/05-search-catalog.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(5)

    .local string csv_filename 
    .local pmc    matches
    .local pmc    star
    
    csv_filename = &#39;data/test-catalog.csv&#39;
    matches = search_catalog(csv_filename, &#39;ProperName&#39;, &#39;Sol&#39;)
    is(matches, 1, &#39;There should be one star named &#34;Sol&#34;&#39;)
    star = matches[0]
    $S0 = star[&#39;ProperName&#39;]
    is($S0, &#39;Sol&#39;, &#39;That star should be Sol&#39;)

    matches = search_catalog(csv_filename, &#39;Spectrum&#39;, &#39;G2V&#39;)
    is(matches, 2, &#39;There are two G2V stars in the test catalog&#39;)

    matches = search_catalog(csv_filename, &#39;Spectrum&#39;, &#39;K3V&#39;)
    is(matches, 1, &#39;There should be one K3V star in the test catalog&#39;)

    matches = search_catalog(csv_filename, &#39;Spectrum&#39;, &#39;G2V&#39;, &#39;ColorIndex&#39;, &#39;0.566&#39;)
    is(matches, 1, &#39;There should be one G2V star with Spectrum G2V and ColorIndex 0.566&#39;)
.end</code></pre>
</figure><p>I am deliberately keeping the tests simple right now. The goal is to make sure
the basic functionality works rather than to guarantee behavior for every little
detail. Tests can be added for those details as they become important.</p>
<p>The actual <code>search_catalog</code> sub borrows quite a bit from <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines">step 07</a>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0c-01/lib/stellar.pir

.loadlib &#39;io_ops&#39;

# ...
.sub search_catalog
    .param string filename
    .param pmc    conditions :slurpy
    .local pmc    chomp
    .local pmc    matches
    .local pmc    catalog
    .local string current_line
    .local pmc    current_star
    .local pmc    is_match

    load_bytecode &#39;String/Utils.pbc&#39;
    chomp = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;

    matches = new &#39;ResizablePMCArray&#39;

    catalog = open filename, &#39;r&#39;
    current_line = readline catalog # Ignore header line

  READ_LINE:
    unless catalog goto RETURN_MATCHES
    current_line = readline catalog
    current_line = chomp(current_line)
    current_star = extract_from_csv_line(current_line)
    is_match = check_star(current_star, conditions :flat)
    if is_match goto REMEMBER_MATCH
    goto READ_LINE

  REMEMBER_MATCH:
    push matches, current_star
    goto READ_LINE

  RETURN_MATCHES:
    close catalog
    .return(matches)
.end</code></pre>
</figure><p><code>search_catalog</code> will handle the task of reading the file and looking for
stars that match the search conditions it has been given. After it defines
a star from the current line, it asks <code>check_star</code> to compare that star
to the set of conditions it has been given. It remembers the stars that
match, and returns them once it has reached the end of the file. It is not
the fastest approach, but it works.</p>
<p>It works well enough that I am ready to add real data and some way for people
to use it!</p>
<h3 id="searching-from-the-command-line">Searching From The Command Line</h3>
<p>Now that we know <code>stellar</code> can read a CSV and return results, it&rsquo;s time to work
on that empty <code>main</code> that has been sitting in <code>stellar.pir</code>. Oh yeah - we will
want to make <code>hygxyz.csv</code> available now. I will be pushing my copy into the
<code>data</code> folder, next to <code>test-catalog.csv</code>. You can place your copy wherever you
like, but make sure that you set the path appropriately in <code>main</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0c-02/lib/stellar.pir

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main
    .param pmc    conditions
    .local string csv_file
    .local pmc    matches
    .local pmc    matches_iter
    .local pmc    star
    .local string summary
    .local int    match_count

    $S0 = shift conditions # ignore my own filename
    csv_file = &#39;data/hygxyz.csv&#39;
    matches = search_catalog(csv_file, conditions :flat)
    matches_iter = iter matches

  NEXT_MATCH:
    star = shift matches_iter
    summary = summarize_star(star)
    say summary
    if matches_iter goto NEXT_MATCH

    match_count = matches
    print match_count
    say &#34; matches.&#34;
.end</code></pre>
</figure><p>Here is the result of all that work we have done setting up the project and
support code. The main subroutine in <code>stellar</code> is downright civilized
compared to what we had for <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines">step 07</a>. All we do is search based on the
command line parameters and display each of the matches.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot lib/stellar.pir Spectrum G2V ColorIndex 0.656
&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;
&lt;Name: HD 7186, Spectrum: G2V, Distance: 112.359550561798&gt;
&lt;Name: HD 140235, Spectrum: G2V, Distance: 60.1684717208183&gt;
&lt;Name: HD 169019, Spectrum: G2V, Distance: 108.108108108108&gt;
4 matches.</code></pre>
</figure><p>Hey, this thing is almost useful!</p>
<h2 id="conclusion">Conclusion</h2>
<p><code>stellar</code> has reached a major milestone. When I started fiddling with the <a href="http://astronexus.com/node/34">HYG
Database</a>, I wanted to write a command-line Parrot tool that could look up
stars based on specific fields. This step gives us that ability. I admit that
a lot more could be done. For example, it only does exact matches. You can
easily find a star that is <code>108.108108108108</code> light years away, but not
stars that are roughly <code>108</code> light years away. And forget about finding
stars within 20 light years.</p>
<p>I am going to take a little break from the <code>stellar</code> project, though.
<a href="http://rakudo.org">Rakudo Star</a> is almost out, and I want to play with that.</p>
<p>You can add to <code>stellar</code> yourself. Make it faster. Make it
object-oriented. Make it a library. Rewrite it in LOLCODE. Have fun. Just
remember to give <a href="http://astronexus.com/node/10">David Nash</a> credit for creating the HYG Database.
We have been having all of this fun because he took the time to put that
catalog together.</p>
<p>Enjoy yourself!</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 0b - Subroutine Params</title>
  <link>https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/</link>
  <pubDate>Tue, 15 Jun 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/</guid>
  <description>Its time to treat the star database like a database. Well, its time to treat it like something we can search, anyways. I know this is not a trivial task in Parrot, so the Babysteps have been building up to it slowly. First, we figured out how to read from the database file and display its contents in a meaningful fashion. Second, we added subroutines to massage the data a little and produce some usable names for the thousands of stars in the database that do not have proper names.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>It&rsquo;s time to treat the star database like a database. Well, it&rsquo;s time to treat
it like something we can search, anyways. I know this is not a trivial task in
Parrot, so the Babysteps have been building up to it slowly. <a href="/post/2009/10/parrot-babysteps-06-files-and-hashes">First</a>, we
figured out how to read from the database file and display its contents in a
meaningful fashion. <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines">Second</a>, we added subroutines to massage the data a
little and produce some usable names for the thousands of stars in the database
that do not have proper names. Then we suddenly spun off in a seemingly random
direction, talking about <a href="/post/2009/12/parrot-babysteps-08-testing-with-testmore">testing</a> and setting up <a href="/post/2010/04/parrot-babysteps-09-simple-projects">larger projects</a>. That
was intentional, though. This sort of project requires more work in <a href="/card/parrot/">Parrot</a> than in
a language like Perl, due to Parrot&rsquo;s lower-level nature. I wanted to be
sure we could test this application as we add search functionality. We just
pushed our script into the <a href="/post/2010/06/parrot-babysteps-0a-the-stellar-project">Stellar project</a> to get that testing foundation.</p>
<p>First I am going to describe what is being built, then I&rsquo;m going to work on the
very important detail of examining a single star. We&rsquo;ll have to wait until the
next Baby Step before we start searching the catalog.</p>
<h2 id="thinking-through-the-problem">Thinking Through The Problem</h2>
<p>We could start by creating a simple search function, testing every line in the
HYG Catalog and verifying the results by hand. That will obviously not work.
Part of the reason we have been writing this is because the catalog is not
easily read without a little computer help.</p>
<p>It might be a better idea to take a smaller set and search against it. How small
is good enough? A thousand? A hundred? Ten? We could reasonably start
by searching a set of one star. It is certainly easy to manage. Okay, so we&rsquo;ll
start with a set of one star.</p>
<p>What do I mean when I talk about searching through the catalog? The basic idea
is that we have a catalog of stars and some conditions, like &ldquo;the ProperName
is &lsquo;Sol&rsquo;.&rdquo; We build a list of matches by examining each star, seeing if the
conditions are true for that star. If they are, then that star goes in the list
of matches. Either way, we then move on to the next star.</p>
<p>How do we determine if a single star is a match? Okay, we have a single star and
some conditions. We determine if the star is a match by testing each condition.
We can stop testing when we find a condition that is not true or we have run out
of conditions to test. We know that this star is a match if every condition we
tested was true.</p>
<p>There are a lot of technical details that we would think about if this code was
intended for use in the real world. Large match lists could use a lot of memory.
The conditions would need to allow for ranges or approximate matches.
Luckily, this code is not indented for use in the real world. I can be as clumsy
as I want, as long as my program gives the right answer.</p>
<h2 id="writing-code">Writing Code</h2>
<p>Now we&rsquo;re ready to go back to the <code>stellar</code> project and write some code.</p>
<h3 id="testing-a-condition">Testing a Condition</h3>
<p>Our first approach to checking a star&rsquo;s details will be to check a single field.
The star <code>ProperName</code> is a good field to start with:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-01/t/04-check-star.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    delimiter = &#34;,&#34;
    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;

    plan(2)

    header_fields = split delimiter, header_string
    star = extract_from_csv_line(star_string, header_fields, delimiter)
    $S0 = &#39;Sol&#39;

    $I0 = check_star_proper_name(star, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_proper_name(star, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
.end</code></pre>
</figure><p><code>check_star_proper_name</code> is an easy sub to write. My version is more verbose
than necessary, to be honest:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-01/lib/stellar.pir

# ...

.sub check_star_proper_name
    .param pmc    star
    .param string desired_value
    .local string actual_value
    .local int    check_result

    actual_value = star[&#39;ProperName&#39;]
    check_result = desired_value == actual_value
    .return(check_result)
.end</code></pre>
</figure><p>The sub returns the result of comparing our desired <code>ProperName</code> with the actual
value held in the <code>star</code>. I rely on Parrot to do the right thing when comparing
<code>desired_value</code> with <code>actual_value</code>. <a href="/post/2009/07/parrot-babysteps-02-variables-and-types">Remember</a> that Parrot automatically
handles any type conversions, so we can ignore type for now.</p>
<h3 id="revisiting-the-header_string">Revisiting the <code>header_string</code></h3>
<p>I want to stop for a moment and look at my tests. One annoying fact is that
every single test file includes the full <code>header_string</code> and <code>delimiter</code>. That
is explicit behavior, which I like. Then again, it is also cluttering up my
tests. The headers never change, yet I always include them. What if I could make
the header string and delimiter optional?</p>
<p>I <em>can</em> make those parameters optional. Let&rsquo;s reopen the test file <code>03-extract-from-csv.t</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-02/03-extract-from-csv.t
.sub main &#39;:main&#39;
    # ...
    plan(4)
    # ...
    star = extract_from_csv_line(star_string, header_fields)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;delimiter should be optional&#34;)

    star = extract_from_csv_line(star_string)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;header_fields should be optional&#34;)
.end</code></pre>
</figure><p>How do we make those fields optional? We use the parameter modifiers <code>:optional</code>
and <code>:opt_flag</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub extract_from_csv_line
    .param string star_string
    .param pmc    header_fields     :optional
    .param int    has_header_fields :opt_flag
    .param string delimiter         :optional
    .param int    has_delimiter     :opt_flag

    if has_delimiter goto CHECK_HEADER_FIELDS
    delimiter = &#39;,&#39;
  CHECK_HEADER_FIELDS:
    if has_header_fields goto BEGIN_EXTRACTING
    .local string header_string
    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    header_fields = split delimiter, header_string

  BEGIN_EXTRACTING:
    .local pmc    star_fields
    .local pmc    star

    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)

    .return(star)
.end</code></pre>
</figure><p>The <code>:optional</code> modifier makes sense. Use it to tell Parrot that a particular
parameter is not required for the sub to perform its duties. <code>:opt_flag</code> might
require a little bit of explanation, though. It is a bookkeeping parameter
provided by Parrot to let you know whether or not the preceding optional
parameter was provided by the caller. You test the flag to see if the optional
parameter was set. The name of the flag doesn&rsquo;t matter.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-03.pir
.sub &#39;main&#39; :main
    .local string eggs
    .local string topping 
    .local string order

    eggs = &#39;over easy&#39;
    topping = &#34;Frank&#39;s RedHot&#34;

    order = breakfast(eggs, topping)
    say order

    order = breakfast(eggs)
    say order
.end

.sub breakfast
    .param string eggs
    .param string topping   :optional
    .param int    has_stuff :opt_flag

    .local string breakfast_order
    breakfast_order = &#39;Eggs cooked &#39; . eggs

    unless has_stuff goto SERVE_BREAKFAST
    breakfast_order .= &#39; topped with &#39;
    breakfast_order .= topping

  SERVE_BREAKFAST:
    .return(breakfast_order)
.end</code></pre>
</figure><p>This program executes without a hitch. There is nothing important about the name
of the flag.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-0b-03.pir
Eggs cooked over easy topped with Frank&#39;s RedHot
Eggs cooked over easy</code></pre>
</figure><p>Order <em>does</em> matter, though. You always want to put the flag after the optional
parameter in your <code>.param</code> directives, or bad things will happen.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-04.pir
.sub &#39;main&#39; :main
    .local string eggs
    .local string topping 
    .local string order

    eggs = &#39;over easy&#39;
    topping = &#34;Frank&#39;s RedHot&#34;

    order = breakfast(eggs, topping)
    say order

    order = breakfast(eggs)
    say order
.end

.sub breakfast
    .param string eggs
    .param int    has_stuff :opt_flag
    .param string topping   :optional

    .local string breakfast_order
    breakfast_order = &#39;Eggs cooked &#39; . eggs

    unless has_stuff goto SERVE_BREAKFAST
    breakfast_order .= &#39; topped with &#39;
    breakfast_order .= topping

  SERVE_BREAKFAST:
    .return(breakfast_order)
.end</code></pre>
</figure><p>See?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-0b-04.pir
Eggs cooked over easy
too few positional arguments: 1 passed, 2 (or more) expected
current instr.: &#39;breakfast&#39; pc 34 (example-0b-04.pir:19)
called from Sub &#39;main&#39; pc 26 (example-0b-04.pir:15)</code></pre>
</figure><p>Back to <code>stellar</code>. <code>extract_from_csv_line</code> can work the headers out for itself now. Let&rsquo;s clean up
our test code.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-05/t/04-check-star.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star

    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star = extract_from_csv_line(star_string)

    plan(2)

    $I0 = check_star_proper_name(star, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_proper_name(star, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
.end</code></pre>
</figure><p>It is a little easier now to tell what I am actually testing in this code. Good.
I know I should be all methodical and orderly about checking my star fields, but
I have not had enough sleep for that to be practical. Let&rsquo;s check <code>Spectrum</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/t/04-check-star.t

.sub &#39;main&#39; :main
    # ...
    plan(4)
    # ...
    $I0 = check_star_spectrum(star, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have Spectrum of &#34;G2V&#34;&#39;)
    $I0 = check_star_spectrum(star, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have Spectrum of &#34;K3V&#34;&#39;)
.end</code></pre>
</figure><p>Meanwhile, in <code>stellar.pir</code>:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/lib/stellar.pir
.sub check_star_spectrum
    .param pmc star
    .param string desired_value
    .local string actual_value
    .local int check_result

    actual_value = star[&#39;Spectrum&#39;]
    check_result = desired_value == actual_value
    .return(check_result)
.end</code></pre>
</figure><p>This works perfectly, but compare <code>check_star_spectrum</code> to
<code>check_star_proper_name</code>. They are almost identical. In fact, the only difference between
the code for the two subs is which field gets grabbed for <code>actual_value</code>.
It seems to me that the same behavior could be described by a single sub.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/t/04-check-star.t
.sub &#39;main&#39; :main
    # ...

    plan(8)

    # ...

    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have Spectrum of &#34;G2V&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have Spectrum of &#34;K3V&#34;&#39;)
.end</code></pre>
</figure><p><code>check_star_field</code> looks like a generic version of <code>check_star_proper_name</code> and
<code>check_star_spectrum</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/lib/stellar.pir

# ...

.sub check_star_field
    .param pmc star
    .param string field
    .param string desired_value
    .local string actual_value
    .local int check_result

    actual_value = star[field]
    check_result = desired_value == actual_value
    .return(check_result)
.end</code></pre>
</figure><p>All tests are still passing. You <em>are</em> working along with me and running tests,
right? It&rsquo;s time to decide what to do with those specific subs now that we have
a nice general purpose field checker. You could argue that those subs should
stick around but as wrappers that call <code>check_star_field</code>. That is entirely
reasonable. I am comfortable using the general purpose sub as my main checker,
though. I will delete the specific subs and their tests in my code.</p>
<h3 id="testing-multiple-conditions">Testing Multiple Conditions</h3>
<p><code>stellar</code> does a convincing job of checking a single field in a star. The next
step is figuring out how to check multiple fields.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-07/t/04-check-star.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star

    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star = extract_from_csv_line(star_string)

    plan(9)

    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have Spectrum of &#34;G2V&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have Spectrum of &#34;K3V&#34;&#39;)

    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName &#34;Sol&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Sol&#39;, &#39;Spectrum&#39;, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have ProperName &#34;Sol&#34; and Spectrum &#34;G2V&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Arcturus&#39;, &#39;Spectrum&#39;, &#39;G2V&#39;)
    nok($I0, &#39;Sol should not have ProperName &#34;Arcturus&#34; and Spectrum &#34;G2V&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Sol&#39;, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have ProperName &#34;Sol&#34; and Spectrum &#34;K3V&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Arcturus&#39;, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have ProperName &#34;Arcturus&#34; and Spectrum &#34;K3V&#34;&#39;)
.end</code></pre>
</figure><p>Yes, I did go through several variations on testing multiple fields. I wanted to
make sure that <code>check_star</code> behaved <em>exactly</em> the way I expected. How am I going
to make those tests succeed?</p>
<h4 id="slurpy-and-flat-save-the-day"><code>:slurpy</code> and <code>:flat</code> Save the Day</h4>
<p>Parrot gives us two excellent modifiers that simplify the job of checking
multiple fields. The <code>:slurpy</code> param modifier to effectively say &ldquo;Oh,
there might be some other params. Just put them in an array.&rdquo; The flip side of
that is the <code>:flat</code> modifier in subroutine calls, which lets us say &ldquo;Oh, I have
this array of stuff. Just tack its elements to the param list for the sub I&rsquo;m
about to call.&rdquo;</p>
<p>Enough imaginary dialog. Here&rsquo;s what <code>check_star</code> looks like.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-07/lib/stellar.pir
.sub check_star
    .param pmc    star
    .param string field
    .param string desired_value
    .param pmc    extra_fields :slurpy
    .local int    match_result
    .local int    extra_field_count

    match_result = check_star_field(star, field, desired_value)

    # We&#39;re done if this match fails.
    unless match_result goto RETURN_RESULT

    extra_field_count = extra_fields
    # We&#39;re done if there are no extra fields.
    unless extra_field_count goto RETURN_RESULT

    # Grab the result of checking the extra fields.
    match_result = check_star(star, extra_fields :flat)

  RETURN_RESULT:
    .return(match_result)
.end</code></pre>
</figure><p>I tried to make it clear what was going on the comments. <code>check_star</code> is given a
star and a handful of conditions. It only cares about the first condition, and
stuffs the rest into <code>extra_fields</code>. If the first condition fails, we&rsquo;re done.
There&rsquo;s no point in checking any more fields, so jump down to return the failure.
If there are no other conditions to check - which we determine by looking at
the size of <code>extra_fields</code> - we return the result, which should be a success.</p>
<p>If there <em>are</em> more conditions to check, we call <code>check_star</code> again, using the
star and the conditions we had stuffed into <code>extra_fields</code>. That goes through
the same process of testing and looking for extra conditions until it has
completed the last test. The result of all the completed tests is handed back to
<code>check_star</code>, which then hands it back to us.</p>
<p>This process of <a href="http://en.wikipedia.org/wiki/Recursion_%28computer_science%29">recursion</a> -
solving a complex problem by breaking it down into small problems - is common in
many programming languages, so it is supported by Parrot. After all, Parrot is
supposed to be used for creating new languages. It is not just for
browsing some guy&rsquo;s star catalog.</p>
<p>The &ldquo;<a href="http://en.wikipedia.org/wiki/Tail_call">tail call</a>&rdquo; pattern of evaluating a sub and immediately returning its result is so
common that Parrot provides the <code>.tailcall</code> directive to optimize its
behavior. <code>.tailcall</code> essentially tells Parrot to immediately return the result
of evaluating the sub rather than storing it in memory. It may not do much in a
case like <code>check_star</code>, but you should see a difference in complex problems.</p>
<p>Then again, it might help <code>check_star</code> immensely. I don&rsquo;t really know about
Parrot optimization effects yet.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-08/lib/stellar.pir
.sub &#39;main&#39; :main
    # ...

    # Return the result of checking the extra fields.
    .tailcall check_star(star, extra_fields :flat)

  RETURN_RESULT:
    .return(match_result)
.end</code></pre>
</figure><h2 id="conclusion">Conclusion</h2>
<p>We can now examine multiple fields to determine if a star matches a description
we&rsquo;ve provided. Along the way, we explored subroutine parameters. We learned how
to make a parameter optional. We learned how to grab all of a subroutine&rsquo;s
params and stuff them into a list. We also learned how to paste the contents of
a list onto the parameters of a subroutine call. We even dabbled in
<a href="http://en.wikipedia.org/wiki/Recursion_%28computer_science%29">recursion</a>, the fine art of breaking a big problem down with small solutions.</p>
<p>In our next step, we will use <code>check_star</code> to search through sets of stars.
That&rsquo;s the part I&rsquo;ve been looking forward to for a while!</p>
<p>In the meantime, continue your own [Parrot][] exploration. You might review the
Parrot <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch06_subroutines.pod.html">Subroutines chapter</a> a little more. I hardly left that page while
working through this step. Whatever you do, remember to have fun!</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 0a - The Stellar Project</title>
  <link>https://randomgeekery.org/post/2010/06/parrot-babysteps-0a-the-stellar-project/</link>
  <pubDate>Wed, 02 Jun 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/06/parrot-babysteps-0a-the-stellar-project/</guid>
  <description>We just learned how to create and test simple Parrot projects. The next step is to reexamine the star catalog handler weve been writing, and turn it into a testable project. There will be some changes in how this code gets its work done, but dont expect any new features.
I know - you really want to start adding features and working on cool new stuff. So do I. My workspace is scattered with half-completed steps that talked about adding new things and using new Parrot features.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>space</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>We just learned how to create and test <a href="/post/2010/04/parrot-babysteps-09-simple-projects">simple Parrot projects</a>. The next step
is to reexamine the star catalog handler we&rsquo;ve <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines">been writing</a>, and turn it
into a testable project. There will be some changes in how this code gets its
work done, but don&rsquo;t expect any new features.</p>
<p>I know - you <em>really</em> want to start adding features and working on cool new
stuff. So do I. My workspace is scattered with half-completed steps that talked
about adding new things and using new <a href="/card/parrot/">Parrot</a> features. They kept breaking,
though. They kept breaking because I wasn&rsquo;t building from a stable, testable
foundation. Today we&rsquo;re going to get that step our of the way.</p>
<h2 id="set-up-the-project">Set up the project</h2>
<p>Let&rsquo;s apply what we learned last time putting together <a href="/post/2010/04/parrot-babysteps-09-simple-projects">larger projects</a>, and
set up a project named <code>stellar</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mkdir stellar
$ mkdir stellar/t
$ mkdir stellar/lib</code></pre>
</figure><p>The <code>setup.pir</code> file is copied directly from the previous project. I&rsquo;m not ready
for anything more elaborate.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-01/setup.pir
.sub &#39;main&#39; :main
    .param pmc args
    $S0 = shift args # Ignore my own filename
    load_bytecode &#39;distutils.pbc&#39;

    # Find out what command the user has issued
    .local string directive
    directive = shift args

    # Used by the test mode
    .local string prove_exec
    prove_exec = get_parrot()

    setup(directive, &#39;prove_exec&#39; =&gt; prove_exec)
.end</code></pre>
</figure><p>The behavior will be defined in <code>lib/stellar.pir</code>, which is initially
empty. We will steadily build up all of our functionality in the Stellar library
and eventually add a very simple file to act as the face of Stellar for
Parrot. Right now, we just have an empty <code>lib/stellar.pir</code>.</p>
<h2 id="reimplementing-features">Reimplementing Features</h2>
<p>The basic skeleton is in place. Now we can start adding the features we had
written before.</p>
<h3 id="extracting-details">Extracting Details</h3>
<p>It&rsquo;s important to keep test files organized. One helpful approach is to think of
each test as a story. This story describes a single specific thing we want the
Stellar library to accomplish. All of the stories together provide a description
of everything that users should be able to get from the library.</p>
<p>I like to start with the smallest useful test story I can. For this code, I
think that would be extracting the details about a single entry in the HYG
catalog. The whole catalog isn&rsquo;t even needed. We could get away with using the
header line and the line containing a star&rsquo;s details.</p>
<p>Names for test files usually follow a common pattern. They start with a number
and summarize what feature is being tested. What purpose does the number serve?
Well, they are probably executed in the order that Parrot finds them, so that
numbering provides a clue for test order. There are no promises about the order,
though. The system looks at each story individually, and you should too. I like
to think of the numbering as simply presenting the order that I came up with the
stories. It provides a simple history of sorts. First I came up with that test,
and I wrote this test after I was comfortable with the first.</p>
<p>In that spirit, I will name the first test story <code>01-extract-details.t</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-01/t/01-extract-details.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string sol_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star_fields
    .local pmc    star

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    sol_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    delimiter = &#34;,&#34;

    header_fields = split delimiter, header_string
    star_fields = split delimiter, sol_string
    star = extract_star_details(header_fields, star_fields)

    plan(1)

    $S0 = star[&#39;Proper Name&#39;]
    is($S0, &#39;Sol&#39;, &#39;ProperName should be Sol&#39;)
.end</code></pre>
</figure><p>Yes, I know that there is a typo in this test code. The key <code>Proper Name</code> should be
<code>ProperName</code>. We&rsquo;ll come back to that.</p>
<p>What happens if this test is run while <code>stellar.pir</code> is still empty? It fails,
of course. It might be useful to look at <em>how</em> it fails.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >stellar $ parrot setup.pir test
t/01-extract-details.t .. Dubious, test returned 1
Failed 1/1 subtests

Test Summary Report
-------------------
t/01-extract-details.t (Tests: 0 Failed: 0)
XXX
Files=1, Tests=0,  0.014 wallclock secs
Result: FAIL
test fails
current instr.: &#39;setup&#39; pc 883 (runtime/parrot/library/distutils.pir:376)
called from Sub &#39;main&#39; pc 29 (setup.pir:17)</code></pre>
</figure><p><code>setup</code> told us something we already know: <code>extract_star_details</code> hasn&rsquo;t been
written yet. This is different from a regular test failure, because Parrot
couldn&rsquo;t even get to the tests. I&rsquo;m showing this so that you recognize what&rsquo;s
going on when you see errors like this in your own library.</p>
<p>Adding <code>extract_star_details</code> is easy enough. Just copy the code from the
earlier step.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># stellar/lib/stellar.pir

.sub extract_star_details
    .param pmc    headers
    .param pmc    values

    .local pmc    star
    .local int    header_count
    .local string current_header
    .local string current_value
    .local int    current_index

    current_index = 0
    header_count = headers
    star = new &#39;Hash&#39;

  ASSIGN_NEXT_STAR_FIELD:
    if current_index &gt;= header_count goto RETURN_STAR
    current_header = headers[current_index]
    current_value = values[current_index]
    star[current_header] = current_value
    current_index &#43;= 1
    goto ASSIGN_NEXT_STAR_FIELD

  RETURN_STAR:
    .return(star)
.end</code></pre>
</figure><p>Let&rsquo;s run the test again.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-extract-details.t .. Failed 1/1 subtests

Test Summary Report
-------------------
t/01-extract-details.t (Tests: 1 Failed: 1)
  Failed test:  1
Files=1, Tests=1,  0.020 wallclock secs
Result: FAIL
test fails
current instr.: &#39;setup&#39; pc 883 (runtime/parrot/library/distutils.pir:376)
called from Sub &#39;main&#39; pc 29 (setup.pir:17)</code></pre>
</figure><p>There&rsquo;s only one assertion, so we already know which one failed. This output is a
little vague for larger test stories, though. Let&rsquo;s run the test file directly.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >#!text
$ parrot t/01-extract-details.t
1..1
not ok 1 - ProperName should be Sol
# Have:
# Want: Sol</code></pre>
</figure><p>Okay, <em>now</em> we can fix the typo.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >#!parrot
# t/01-extract-details.t
.sub &#39;main&#39; :main
    ...
    $S0 = star[&#39;ProperName&#39;]
    is($S0, &#39;Sol&#39;, &#39;ProperName should be Sol&#39;)
.end</code></pre>
</figure><p>The test should pass now that the correction has been made.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >#!text
$ parrot setup.pir test
t/01-extract-details.t .. ok
All tests successful.
Files=1, Tests=1,  0.014 wallclock secs
Result: PASS</code></pre>
</figure><p>Don&rsquo;t worry. I won&rsquo;t submit you to this for every test run. It&rsquo;s just important
to know what failure looks like before we can reach success.</p>
<p>What have we accomplished so far? We now have a story in which the user, armed
with a header line and a line describing a star, gets an object that she can
examine and manipulate for her own purposes. If we wanted to be thorough, we
could test every field. I&rsquo;m not going to do that, though. One thing you want to
avoid when making test stories is predicting the future. It&rsquo;s easy to get
distracted by testing every possible aspect of a single chunk of code when you
could be working on the next story.</p>
<p>These stories aren&rsquo;t static. We will come back and add more when some
detail doesn&rsquo;t work out the way we expect it to.</p>
<p>Our first story is pretty much out of the way. Let&rsquo;s move on to the next one.</p>
<h3 id="stringifying-stars">Stringifying Stars</h3>
<p>Next up is the string representation of a star. In the original application, we
had the <code>say_star_details</code> sub, which printed the star information as soon as it
had been prepared. <code>Stellar</code> is more of a library, though. This means that we
can&rsquo;t be completely sure what folks will want to do with the star summary once
they have it. They might want to print it, but they might also want to feed it
to an unmanned orbiter for some reason.</p>
<p>Because we can&rsquo;t predict with certainty what someone will do with the string
summary of a star, this test story will focus on asking for that string.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># t/02-summarize-star.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string sol_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star_fields
    .local pmc    star
    .local string summary

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    sol_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    delimiter = &#34;,&#34;

    plan(1)

    header_fields = split delimiter, header_string
    star_fields = split delimiter, sol_string
    star = extract_star_details(header_fields, star_fields)

    summary = &#34;&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;&#34;
    $S0 = summarize_star(star)
    is($S0, summary, &#34;Sol&#39;s summary should include basic details&#34;)
.end</code></pre>
</figure><p>It&rsquo;s not hard to create the code which will make this story true, but it does
involve a little more work than the simple copy and paste for
<code>extract_star_details</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-04/lib/stellar.pir

# ...

.sub summarize_star
    .param pmc star

    .local string star_name
    .local string star_spectrum
    .local string star_distance
    .local string summary

    star_name = star[&#39;ProperName&#39;]
    star_spectrum = star[&#39;Spectrum&#39;]
    star_distance = star[&#39;Distance&#39;]

    if star_name goto PREPARE_SUMMARY

  TRY_GLIESE:
    .local string gliese_number
    gliese_number = star[&#39;Gliese&#39;]
    unless gliese_number goto TRY_BAYER_FLAMSTEED
    star_name = &#39;Gliese &#39; . gliese_number
    goto PREPARE_SUMMARY

  TRY_BAYER_FLAMSTEED:
    .local string bayer_flamsteed
    bayer_flamsteed = star[&#39;BayerFlamsteed&#39;]
    unless bayer_flamsteed goto TRY_HR
    star_name = &#34;BF &#34; . bayer_flamsteed
    goto PREPARE_SUMMARY

  TRY_HR:
    .local string hr_id
    hr_id = star[&#39;HR&#39;]
    unless hr_id goto TRY_HD
    star_name = &#34;HR &#34; . hr_id
    goto PREPARE_SUMMARY

  TRY_HD:
    .local string hd_id
    hd_id = star[&#39;HD&#39;]
    unless hd_id goto USE_STAR_ID
    star_name = &#34;HD &#34; . hd_id
    goto PREPARE_SUMMARY

  TRY_HIP:
    .local string hip_id
    hip_id = star[&#39;HIP&#39;]
    unless hip_id goto USE_STAR_ID
    star_name = &#34;HIP &#34; . hip_id
    goto PREPARE_SUMMARY

  USE_STAR_ID:
    .local string star_id
    star_id = star[&#39;StarID&#39;]
    star_name = &#34;HYG &#34; . star_id
    goto PREPARE_SUMMARY

  PREPARE_SUMMARY:
    summary = &#34;&lt;Name: &#34;
    summary .= star_name
    summary .= &#34;, Spectrum: &#34;
    summary .= star_spectrum
    summary .= &#34;, Distance: &#34;
    summary .= star_distance
    summary .= &#34;&gt;&#34;

    .return(summary)
.end</code></pre>
</figure><p>Yes, this is mostly a copy and paste of <code>say_star_details</code>. The new details
change the focus from displaying the details to returning them as a simple
string.</p>
<p>What&rsquo;s most important is that this test passes when handed Sol. How about some
of those stars that don&rsquo;t have proper names?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-04/t/02-summarize-star.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star_fields
    .local pmc    star
    .local string summary

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    delimiter = &#34;,&#34;

    plan(3)

    header_fields = split delimiter, header_string

    summary = &#34;&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;&#34;
    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;Sol&#39;s summary should include basic details&#34;)

    summary = &#34;&lt;Name: HD 224693, Spectrum: G2V, Distance: 94.0733772342427&gt;&#34;
    star_string = &#34;117952,118319,224693,,,,,23.99826083,-22.42818030,94.0733772342427,148.74,27.53,,8.23,3.36266632261649,G2V,0.639,86.95751,-0.03959,-35.89135,4.82e-06,6.7829e-05,1.1605e-05&#34;
    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;HD identifier can be used if ProperName is unavailable&#34;)

    summary = &#34;&lt;Name: HYG 117782, Spectrum: G2V, Distance: 139.275766016713&gt;&#34;
    star_string = &#34;117782,118149,,,,,,23.96625102,15.95292997,139.275766016713,-46.50,-53.88,,9.59,3.8706222212115,G2V,0.648,133.90672,-1.18315,38.2796,9.72e-06,-3.1482e-05,-3.4977e-05&#34;
    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;HYG identifier can be used if ProperName is unavailable&#34;)
.end</code></pre>
</figure><p>It does indeed work.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-extract-details.t .. ok
t/02-summarize-star.t ... ok
All tests successful.
Files=2, Tests=4,  0.030 wallclock secs
Result: PASS</code></pre>
</figure><p>I am concerned about the heft of this test code. The concern is that I
had to split the CSV text, extract star details, and summarize the star
manually for each star string. Each of those times is an opportunity for me to
make a mistake. I <em>think</em> I would like to have a subroutine which would take the
header fields and a CSV line of star data, and return the extracted details.
Let&rsquo;s make a new test story for that.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-04/t/03-extract-from-csv.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star_fields
    .local pmc    star
    .local string summary

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    delimiter = &#34;,&#34;

    plan(3)

    header_fields = split delimiter, header_string

    summary = &#34;&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;&#34;
    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star = extract_from_csv_line(star_string, header_fields, delimiter)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;Sol&#39;s summary should include basic details&#34;)

    summary = &#34;&lt;Name: HD 224693, Spectrum: G2V, Distance: 94.0733772342427&gt;&#34;
    star_string = &#34;117952,118319,224693,,,,,23.99826083,-22.42818030,94.0733772342427,148.74,27.53,,8.23,3.36266632261649,G2V,0.639,86.95751,-0.03959,-35.89135,4.82e-06,6.7829e-05,1.1605e-05&#34;
    star = extract_from_csv_line(star_string, header_fields, delimiter)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;HD identifier can be used if ProperName is unavailable&#34;)

    summary = &#34;&lt;Name: HYG 117782, Spectrum: G2V, Distance: 139.275766016713&gt;&#34;
    star_string = &#34;117782,118149,,,,,,23.96625102,15.95292997,139.275766016713,-46.50,-53.88,,9.59,3.8706222212115,G2V,0.648,133.90672,-1.18315,38.2796,9.72e-06,-3.1482e-05,-3.4977e-05&#34;
    star = extract_from_csv_line(star_string, header_fields, delimiter)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;HYG identifier can be used if ProperName is unavailable&#34;)
.end</code></pre>
</figure><p>The code to make this work is simple enough.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-04/lib/stellar.pir

# ...

.sub extract_from_csv_line
    .param string star_string
    .param pmc    header_fields
    .param string delimiter
    .local pmc    star_fields
    .local pmc    star

    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)

    .return(star)
.end</code></pre>
</figure><p>I do not know if I have saved much work, but it is easier for me to read the
test story. That is important to me, because debugging and improving the code is
easier if I can easily understand what is happening.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is time to take a break. The script we wrote a while back is evolving into a
tested library that can be used by others. Now that we have our foundation, we
can start building up. Our next step will involve adding some simple search
behavior to the library, and that is a significant improvement. For the moment,
take a little time to relax.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 09 - Simple Projects</title>
  <link>https://randomgeekery.org/post/2010/04/parrot-babysteps-09-simple-projects/</link>
  <pubDate>Thu, 29 Apr 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/04/parrot-babysteps-09-simple-projects/</guid>
  <description>Introduction I spent a lot of time exploring Parrot testing with Test::More in the last step. Thats because I want to start building larger projects, and testing is a vital part of most projects. Another major part is a properly organized workspace with a script that can simplify testing or other tasks.
Creating a Simple Project A nice Parrot project layout includes a t folder for tests, a lib folder for library code, and a setup.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I spent a lot of time exploring <a href="/card/parrot/">Parrot</a> testing with <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> in the <a href="/post/2009/12/parrot-babysteps-08-testing-with-testmore">last step</a>. That&rsquo;s because
I want to start building larger projects, and testing is a vital part of most
projects. Another major part is a properly organized workspace with a script that
can simplify testing or other tasks.</p>
<h2 id="creating-a-simple-project">Creating a Simple Project</h2>
<p>A nice Parrot project layout includes a <code>t</code> folder for tests, a <code>lib</code> folder for
library code, and a <code>setup.pir</code> file to drive the whole thing.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mkdir simple-pir
$ mkdir simple-pir/t
$ mkdir simple-pir/lib
$ cd simple-pir</code></pre>
</figure><p>What gets placed in <code>setup.pir</code>? Not much, considering how much it does.
<code>setup.pir</code> takes advantage of the Parrot <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/distutils.pir">distutils</a> module for a whole range
of tasks. All I&rsquo;m concerned about today is <em>testing</em>, so my setup is going to be
rather lightweight.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-01/setup.pir
.sub &#39;main&#39; :main
    .param pmc args
    $S0 = shift args # Ignore my own filename
    load_bytecode &#39;distutils.pbc&#39;

    # Find out what command the user has issued
    .local string directive
    directive = shift args

    setup(directive)
.end</code></pre>
</figure><p>This is not exciting code, but it is enough to see what distutils <em>can</em> give me.
The first command line parameter is shifted onto a dummy register variable,
because I don&rsquo;t really care about the name of <code>setup.pir</code> from within
<code>setup.pir</code>.  Then I load the <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/distutils.pir">distutils</a> bytecode so I can get access to the <code>setup</code> subroutine.</p>
<p>This <code>setup.pir</code> will get more complicated as we go on, and you will
<em>definitely</em> see more complex <code>setup.pir</code> files out in the wild, but this will
get us started.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir help
usage: parrot setup.pir [target|--key value]*

    Default targets are :

        build:          Build the library.

        test:           Run the test suite.

        install:        Install the library.

        uninstall:      Uninstall the library.

        clean:          Basic cleaning up.

        update:         Update from the repository.

        plumage:        Output a skeleton for Plumage

        sdist:          Create a source distribution

        bdist:          Create a binary distribution

        help:           Print this help message.</code></pre>
</figure><p>What happens when I tell <code>setup.pir</code> that I want to test?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
Files=0, Tests=0,  0.000 wallclock secs
Result: NOTESTS</code></pre>
</figure><p>Well of course it failed. There aren&rsquo;t any test files, and <code>setup.pir</code> wouldn&rsquo;t
know how to run them if there were!</p>
<p>I&rsquo;ll fix the second part first.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-02/setup.pir
.sub &#39;main&#39; :main
    .param pmc args
    $S0 = shift args # Ignore my own filename
    load_bytecode &#39;distutils.pbc&#39;

    # Find out what command the user has issued
    .local string directive
    directive = shift args

    # Used by the test mode
    .local string prove_exec
    prove_exec = get_parrot()

    setup(directive, &#39;prove_exec&#39; =&gt; prove_exec)
.end</code></pre>
</figure><p>Parrot allows you to use <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch06_subroutines.pod.html#Named_Parameters">named parameters</a> for some subroutines, and <code>setup</code>
takes full advantage of that feature. If you&rsquo;re used to <a href="/tags/perl/">Perl</a> or <a href="/tags/ruby/">Ruby</a>,
named parameters look a lot like a hash. That&rsquo;s close enough for our purposes. A
named parameter generally follows a simple format:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&#39;&lt;key-1&gt;&#39; =&gt; &#39;&lt;value-1&gt;&#39;</code></pre>
</figure><p>Thankfully, <code>distutils.pir</code> is a well-documented module, and you
can find details about the many options by checking the documentation.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ perldoc /usr/local/lib/parrot/3.0.0/library/distutils.pir</code></pre>
</figure><p>I only care about a single option: <code>prove_exec</code>, which tells <code>setup</code> what program
will be used to run the tests. Why does <code>setup</code> care? Well, Parrot is a VM. Your
tests can be in PIR, NQP, <a href="/tags/raku-lang/">Rakudo</a>, or even a language of your own design.
These <a href="/post/2009/07/parrot-babysteps">Babysteps</a> are about Parrot PIR, so it makes sense that the tests will be in
the same language.</p>
<p>Oh yes, the tests. Let&rsquo;s write one. I&rsquo;ll follow the convention I see in the Perl
world of a number followed by a description for the test filename, and the test
itself will be for a simple area calculating function.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-02/t/01-radius.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local num radius
    .local num expected_area, actual_area

    plan(1)

    radius = 1.0
    expected_area = 3.1415926
    actual_area = area_of_circle(radius)
    is(expected_area, actual_area, &#39;Circle with radius 1 should have area PI&#39;, 1e-6)
.end</code></pre>
</figure><p>So - this should fail, right?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-radius.t .. Dubious, test returned 1
Failed 1/1 subtests 

Test Summary Report
-------------------
t/01-radius.t (Tests: 0 Failed: 0)
  Non-zero exit status: 1
  Parse errors: Unknown TAP token: &#34;Could not find sub area_of_circle&#34;
                Unknown TAP token: &#34;current instr.: &#39;main&#39; pc 40
(t/01-radius.t:13)&#34;
                Bad plan.  You planned 1 tests but ran 0.
Files=1, Tests=0,  0.021 wallclock secs
Result: FAIL
test fails
current instr.: &#39;setup&#39; pc 883 (runtime/parrot/library/distutils.pir:376)
called from Sub &#39;main&#39; pc 29 (setup.pir:18)</code></pre>
</figure><p>Excellent. Parrot didn&rsquo;t just tell us that the test failed. It also told us
about some unexpected output from our test script. What&rsquo;s that unexpected
output? Oh, something about not having a subroutine called <code>area_of_circle</code>.
Let&rsquo;s fix that by adding a new library file called <code>lib/area.pir</code>, and adding
the missing subroutine.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-03/lib/area.pir

.sub area_of_circle
    .param num radius
    .const num PI = 3.1415926
    .local num area

    area = PI
    area *= radius
    area *= radius

    .return(area)
.end</code></pre>
</figure><p>This is code borrowed from <a href="/post/2009/07/parrot-babysteps-02-variables-and-types">step 2</a> and dropped into a subroutine.</p>
<p>Don&rsquo;t forget to include this library code from your test file.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-03/lib/area.pir

.include &#39;lib/area.pir&#39;

.sub &#39;main&#39; :main
    # ...
.end</code></pre>
</figure><p>Did it work?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-radius.t .. ok
All tests successful.
Files=1, Tests=1,  0.016 wallclock secs
Result: PASS</code></pre>
</figure><p>Yay!</p>
<p>Hold on a second. I snuck an extra argument back when I wrote the <code>is</code> assertion. What was that
all about? Well, <a href="http://leto.net">Jonathan Leto</a> explained to me that <code>is</code> takes an additional argument
for precision, which is useful in the fuzzy world of <a href="http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">floating point
math</a> on
a modern computer. The <code>1e-6</code> requirement asks Parrot to make sure <code>expected_area</code>
and <code>actual_area</code> look the same down to six places past the decimal point.</p>
<p>This approach of writing the tests before you write the code is called TDD, for
<a href="http://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a>. I like TDD because I&rsquo;m basically describing the next
thing I want my library or application to do. That&rsquo;s perfect for me, since I&rsquo;m such
a chatty person. Well, I&rsquo;m chatty when typing at the computer.</p>
<p>You don&rsquo;t need to follow a
test driven approach, but other developers will like you more if you consistently
test the code you write. The easiest way to consistently test it is to write the
test before you write the code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Combining what we&rsquo;ve learned about <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> with <code>setup.pir</code> allows us to
confidently build more complicated applications, testing as we go along. It is
true that all we know how to do with <code>setup.pir</code> at this point is ask it to run
tests for us, but even that can save a lot of work.</p>
<p>I don&rsquo;t know about you, but I&rsquo;m ready to take another look at that star catalog.</p>
]]></content:encoded>
</item>
</channel>
</rss>
