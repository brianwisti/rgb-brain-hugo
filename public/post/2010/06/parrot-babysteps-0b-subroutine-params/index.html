<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
    










    







<script defer language="javascript" type="text/javascript" src="/js/bundle.min.60856f0f2ed73fb3cd2820ee548c4698ffbc4d743736e852c0e27ce4f52dfd9c.js"></script>






    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    <link rel="icon" href=/favicon.png>

    
    





  





  
  
  

<meta property="og:url" content="https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/">
<meta property="og:title" content="Parrot Babysteps 0b - Subroutine Params">
<meta name="twitter:title" content="Parrot Babysteps 0b - Subroutine Params">


  <meta name="twitter:site" content="@brianwisti">



  
    <meta name="twitter:description" content="It&rsquo;s time to treat the star database like a database. Well, it&rsquo;s time to treat it like something we can search, anyways. I know this is not a trivial task in Parrot, so the Babysteps have been building up to it slowly. First, we figured out how to read from the database file and display its contents in a meaningful fashion. Second, we added subroutines to massage the data a little and produce some usable names for the thousands of stars in the database that do not have proper names.">
    <meta property="og:description" content="It&rsquo;s time to treat the star database like a database. Well, it&rsquo;s time to treat it like something we can search, anyways. I know this is not a trivial task in Parrot, so the Babysteps have been building up to it slowly. First, we figured out how to read from the database file and display its contents in a meaningful fashion. Second, we added subroutines to massage the data a little and produce some usable names for the thousands of stars in the database that do not have proper names.">
  



<title itemprop="name">Parrot Babysteps 0b - Subroutine Params - Random Geekery</title>
<meta property="og:title" content=Parrot&#32;Babysteps&#32;0b&#32;-&#32;Subroutine&#32;Params&#32;-&#32;Random&#32;Geekery />
<meta name="twitter:title" content=Parrot&#32;Babysteps&#32;0b&#32;-&#32;Subroutine&#32;Params&#32;-&#32;Random&#32;Geekery />
<meta itemprop="name" content=Parrot&#32;Babysteps&#32;0b&#32;-&#32;Subroutine&#32;Params&#32;-&#32;Random&#32;Geekery />
<meta name="application-name" content=Parrot&#32;Babysteps&#32;0b&#32;-&#32;Subroutine&#32;Params&#32;-&#32;Random&#32;Geekery />
<meta property="og:site_name" content="Random Geekery" />


<meta name="description" content="" />
<meta itemprop="description" content="" />
<meta property="og:description" content="" />
<meta name="twitter:description" content="" />


<base href="https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/" />
<link rel="canonical" href="https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/" itemprop="url" />
<meta name="url" content="https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/" />
<meta name="twitter:url" content="https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/" />
<meta property="og:url" content="https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/" />


<meta property="og:updated_time" content=15006-15-12T60:00:10-0700 />


<link rel="sitemap" type="application/xml" title="Sitemap" href='https://randomgeekery.org/sitemap.xml' />

  <link
      rel="alternate"
      type="application/rss+xml"
    
        href="/index.xml"
    
      title="Random Geekery"/>



<meta name="robots" content="index,follow" />
<meta name="googlebot" content="index,follow" />


<meta name="twitter:site" content="" />
<meta name="twitter:creator" content="" />
<meta property="fb:admins" content="" />


<meta name="apple-mobile-web-app-title" content="Random Geekery" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />






<meta name="generator" content="Hugo 0.121.2">


    
    

<link
    rel="stylesheet"
    href="/css/style.fe9735814e6394fb590ff4fd2eb036a13152e6808ad90dd06ba181d89087b5d3.css"
    integrity="sha256-/pc1gU5jlPtZD/T9LrA2oTFS5oCK2Q3Qa6GB2JCHtdM=" 
    crossorigin="anonymous">


</head>

    <body class="">
        <div class="wrapper">
            <aside class="sidebar">
    <div class="container sidebar-sticky">
        <div class="light-dark" align="right">
    <button class="btn-light-dark" title="Toggle light/dark mode">
        <svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M6 .278a.768.768 0 0 1 .08.858a7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277c.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316a.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71C0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
        </svg>
        <svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M8 12a4 4 0 1 0 0-8a4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
        </svg>
    </button>
</div>

        <div class="sidebar-about">
    <h1 class="brand">
        
        
            <a href="https://randomgeekery.org">
                <h1>Random Geekery</h1>
            </a>
        
    </h1>
    <p class="lead">
    Collecting my attempts to improve at tech, art, and life
    </p>
</div>

        <nav>
    <ul class="sidebar-nav">
      
        <li class="bullet">
          <a href="/post/">Posts</a>
        </li>
      
        <li class="bullet">
          <a href="/card/">Cards</a>
        </li>
      
        <li class="bullet">
          <a href="/now/">Now</a>
        </li>
      
        <li class="bullet">
          <a href="/follow/">Follow</a>
        </li>
      
        <li class="bullet">
          <a href="/neighborhood/">Neighborhood</a>
        </li>
      
        <li class="bullet">
          <a href="/config/">Config</a>
        </li>
      
    </ul>
</nav>

        
  <div class="related">
    <div class="related-posts">
      <h3>Related</h3>
      <ul>
        
          <li><a href="/post/2010/10/parrot-babysteps-0e-parrot-namespaces/">Parrot Babysteps 0e - Parrot Namespaces</a></li>
        
          <li><a href="/post/2010/08/parrot-babysteps-0d-the-space-trade-project/">Parrot Babysteps 0d - The SpaceTrade Project</a></li>
        
          <li><a href="/post/2010/07/parrot-babysteps-0x-the-stellar-app/">Parrot Babysteps 0c - The Stellar App</a></li>
        
          <li><a href="/post/2010/06/parrot-babysteps-0a-the-stellar-project/">Parrot Babysteps 0a - The Stellar Project</a></li>
        
          <li><a href="/post/2010/04/parrot-babysteps-09-simple-projects/">Parrot Babysteps 09 - Simple Projects</a></li>
        
      </ul>
    </div>
  </div>



        
















        <p class="footnote">
powered by <a target="_blank" href="https://gohugo.io">Hugo</a> | themed with <a target="_blank" href="https://github.com/lukeorth/poison">poison</a>
    <br>
    &copy; 2024 Brian Wisti. All rights reserved.
</p>
<p class="footnote">
  This work is licensed under a
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    Creative Commons Attribution 4.0 International License
  </a>.
</p>

  </div>
</aside>

            <main class="content container">
                <div class="post">
  <nav class="masthead">
    <ul>
    
  
    
  
    
  
    
  

    <li><a href="https://randomgeekery.org/">Random Geekery</a></li>
  

    <li><a href="https://randomgeekery.org/post/">Posts</a></li>
  

    <li><a href="https://randomgeekery.org/post/2010/">2010</a></li>
  

    <li><a class="active" href="https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/">Parrot Babysteps 0b - Subroutine Params</a></li>
</nav>



  <div class="info">
    <h1 class="post-title">
        <a href="https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/">Parrot Babysteps 0b - Subroutine Params</a>
    </h1>
    
        <time datetime="2010-06-15T00:00:00-0700" class="post-date">
            June 15, 2010
        </time>
    
    
    <ul class="tags">
        
        <li class="tag-parrot">
            <a href="https://randomgeekery.org/tags/parrot">parrot</a>
        </li>
        
        <li class="tag-learn">
            <a href="https://randomgeekery.org/tags/learn">learn</a>
        </li>
        
        <li class="tag-coolnamehere">
            <a href="https://randomgeekery.org/tags/coolnamehere">coolnamehere</a>
        </li>
        
    </ul>
    
    
    
    
        <p class="seriesname">
            Series: <a href="https://randomgeekery.orgseries/">[Parrot Babysteps]</a>
        </p>
    
    
    
</div>

  <p>It&rsquo;s time to treat the star database like a database. Well, it&rsquo;s time to treat
it like something we can search, anyways. I know this is not a trivial task in
Parrot, so the Babysteps have been building up to it slowly. <a href="/post/2009/10/parrot-babysteps-06-files-and-hashes">First</a>, we
figured out how to read from the database file and display its contents in a
meaningful fashion. <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines">Second</a>, we added subroutines to massage the data a
little and produce some usable names for the thousands of stars in the database
that do not have proper names. Then we suddenly spun off in a seemingly random
direction, talking about <a href="/post/2009/12/parrot-babysteps-08-testing-with-testmore">testing</a> and setting up <a href="/post/2010/04/parrot-babysteps-09-simple-projects">larger projects</a>. That
was intentional, though. This sort of project requires more work in <a href="/card/parrot/">Parrot</a> than in
a language like Perl, due to Parrot&rsquo;s lower-level nature. I wanted to be
sure we could test this application as we add search functionality. We just
pushed our script into the <a href="/post/2010/06/parrot-babysteps-0a-the-stellar-project">Stellar project</a> to get that testing foundation.</p>
<p>First I am going to describe what is being built, then I&rsquo;m going to work on the
very important detail of examining a single star. We&rsquo;ll have to wait until the
next Baby Step before we start searching the catalog.</p>
<h2 id="thinking-through-the-problem">Thinking Through The Problem</h2>
<p>We could start by creating a simple search function, testing every line in the
HYG Catalog and verifying the results by hand. That will obviously not work.
Part of the reason we have been writing this is because the catalog is not
easily read without a little computer help.</p>
<p>It might be a better idea to take a smaller set and search against it. How small
is good enough? A thousand? A hundred? Ten? We could reasonably start
by searching a set of one star. It is certainly easy to manage. Okay, so we&rsquo;ll
start with a set of one star.</p>
<p>What do I mean when I talk about searching through the catalog? The basic idea
is that we have a catalog of stars and some conditions, like &ldquo;the ProperName
is &lsquo;Sol&rsquo;.&rdquo; We build a list of matches by examining each star, seeing if the
conditions are true for that star. If they are, then that star goes in the list
of matches. Either way, we then move on to the next star.</p>
<p>How do we determine if a single star is a match? Okay, we have a single star and
some conditions. We determine if the star is a match by testing each condition.
We can stop testing when we find a condition that is not true or we have run out
of conditions to test. We know that this star is a match if every condition we
tested was true.</p>
<p>There are a lot of technical details that we would think about if this code was
intended for use in the real world. Large match lists could use a lot of memory.
The conditions would need to allow for ranges or approximate matches.
Luckily, this code is not indented for use in the real world. I can be as clumsy
as I want, as long as my program gives the right answer.</p>
<h2 id="writing-code">Writing Code</h2>
<p>Now we&rsquo;re ready to go back to the <code>stellar</code> project and write some code.</p>
<h3 id="testing-a-condition">Testing a Condition</h3>
<p>Our first approach to checking a star&rsquo;s details will be to check a single field.
The star <code>ProperName</code> is a good field to start with:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-01/t/04-check-star.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    delimiter = &#34;,&#34;
    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;

    plan(2)

    header_fields = split delimiter, header_string
    star = extract_from_csv_line(star_string, header_fields, delimiter)
    $S0 = &#39;Sol&#39;

    $I0 = check_star_proper_name(star, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_proper_name(star, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
.end</code></pre>
</figure><p><code>check_star_proper_name</code> is an easy sub to write. My version is more verbose
than necessary, to be honest:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-01/lib/stellar.pir

# ...

.sub check_star_proper_name
    .param pmc    star
    .param string desired_value
    .local string actual_value
    .local int    check_result

    actual_value = star[&#39;ProperName&#39;]
    check_result = desired_value == actual_value
    .return(check_result)
.end</code></pre>
</figure><p>The sub returns the result of comparing our desired <code>ProperName</code> with the actual
value held in the <code>star</code>. I rely on Parrot to do the right thing when comparing
<code>desired_value</code> with <code>actual_value</code>. <a href="/post/2009/07/parrot-babysteps-02-variables-and-types">Remember</a> that Parrot automatically
handles any type conversions, so we can ignore type for now.</p>
<h3 id="revisiting-the-header_string">Revisiting the <code>header_string</code></h3>
<p>I want to stop for a moment and look at my tests. One annoying fact is that
every single test file includes the full <code>header_string</code> and <code>delimiter</code>. That
is explicit behavior, which I like. Then again, it is also cluttering up my
tests. The headers never change, yet I always include them. What if I could make
the header string and delimiter optional?</p>
<p>I <em>can</em> make those parameters optional. Let&rsquo;s reopen the test file <code>03-extract-from-csv.t</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-02/03-extract-from-csv.t
.sub main &#39;:main&#39;
    # ...
    plan(4)
    # ...
    star = extract_from_csv_line(star_string, header_fields)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;delimiter should be optional&#34;)

    star = extract_from_csv_line(star_string)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;header_fields should be optional&#34;)
.end</code></pre>
</figure><p>How do we make those fields optional? We use the parameter modifiers <code>:optional</code>
and <code>:opt_flag</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub extract_from_csv_line
    .param string star_string
    .param pmc    header_fields     :optional
    .param int    has_header_fields :opt_flag
    .param string delimiter         :optional
    .param int    has_delimiter     :opt_flag

    if has_delimiter goto CHECK_HEADER_FIELDS
    delimiter = &#39;,&#39;
  CHECK_HEADER_FIELDS:
    if has_header_fields goto BEGIN_EXTRACTING
    .local string header_string
    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    header_fields = split delimiter, header_string

  BEGIN_EXTRACTING:
    .local pmc    star_fields
    .local pmc    star

    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)

    .return(star)
.end</code></pre>
</figure><p>The <code>:optional</code> modifier makes sense. Use it to tell Parrot that a particular
parameter is not required for the sub to perform its duties. <code>:opt_flag</code> might
require a little bit of explanation, though. It is a bookkeeping parameter
provided by Parrot to let you know whether or not the preceding optional
parameter was provided by the caller. You test the flag to see if the optional
parameter was set. The name of the flag doesn&rsquo;t matter.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-03.pir
.sub &#39;main&#39; :main
    .local string eggs
    .local string topping 
    .local string order

    eggs = &#39;over easy&#39;
    topping = &#34;Frank&#39;s RedHot&#34;

    order = breakfast(eggs, topping)
    say order

    order = breakfast(eggs)
    say order
.end

.sub breakfast
    .param string eggs
    .param string topping   :optional
    .param int    has_stuff :opt_flag

    .local string breakfast_order
    breakfast_order = &#39;Eggs cooked &#39; . eggs

    unless has_stuff goto SERVE_BREAKFAST
    breakfast_order .= &#39; topped with &#39;
    breakfast_order .= topping

  SERVE_BREAKFAST:
    .return(breakfast_order)
.end</code></pre>
</figure><p>This program executes without a hitch. There is nothing important about the name
of the flag.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-0b-03.pir
Eggs cooked over easy topped with Frank&#39;s RedHot
Eggs cooked over easy</code></pre>
</figure><p>Order <em>does</em> matter, though. You always want to put the flag after the optional
parameter in your <code>.param</code> directives, or bad things will happen.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-04.pir
.sub &#39;main&#39; :main
    .local string eggs
    .local string topping 
    .local string order

    eggs = &#39;over easy&#39;
    topping = &#34;Frank&#39;s RedHot&#34;

    order = breakfast(eggs, topping)
    say order

    order = breakfast(eggs)
    say order
.end

.sub breakfast
    .param string eggs
    .param int    has_stuff :opt_flag
    .param string topping   :optional

    .local string breakfast_order
    breakfast_order = &#39;Eggs cooked &#39; . eggs

    unless has_stuff goto SERVE_BREAKFAST
    breakfast_order .= &#39; topped with &#39;
    breakfast_order .= topping

  SERVE_BREAKFAST:
    .return(breakfast_order)
.end</code></pre>
</figure><p>See?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-0b-04.pir
Eggs cooked over easy
too few positional arguments: 1 passed, 2 (or more) expected
current instr.: &#39;breakfast&#39; pc 34 (example-0b-04.pir:19)
called from Sub &#39;main&#39; pc 26 (example-0b-04.pir:15)</code></pre>
</figure><p>Back to <code>stellar</code>. <code>extract_from_csv_line</code> can work the headers out for itself now. Let&rsquo;s clean up
our test code.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-05/t/04-check-star.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star

    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star = extract_from_csv_line(star_string)

    plan(2)

    $I0 = check_star_proper_name(star, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_proper_name(star, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
.end</code></pre>
</figure><p>It is a little easier now to tell what I am actually testing in this code. Good.
I know I should be all methodical and orderly about checking my star fields, but
I have not had enough sleep for that to be practical. Let&rsquo;s check <code>Spectrum</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/t/04-check-star.t

.sub &#39;main&#39; :main
    # ...
    plan(4)
    # ...
    $I0 = check_star_spectrum(star, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have Spectrum of &#34;G2V&#34;&#39;)
    $I0 = check_star_spectrum(star, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have Spectrum of &#34;K3V&#34;&#39;)
.end</code></pre>
</figure><p>Meanwhile, in <code>stellar.pir</code>:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/lib/stellar.pir
.sub check_star_spectrum
    .param pmc star
    .param string desired_value
    .local string actual_value
    .local int check_result

    actual_value = star[&#39;Spectrum&#39;]
    check_result = desired_value == actual_value
    .return(check_result)
.end</code></pre>
</figure><p>This works perfectly, but compare <code>check_star_spectrum</code> to
<code>check_star_proper_name</code>. They are almost identical. In fact, the only difference between
the code for the two subs is which field gets grabbed for <code>actual_value</code>.
It seems to me that the same behavior could be described by a single sub.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/t/04-check-star.t
.sub &#39;main&#39; :main
    # ...

    plan(8)

    # ...

    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have Spectrum of &#34;G2V&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have Spectrum of &#34;K3V&#34;&#39;)
.end</code></pre>
</figure><p><code>check_star_field</code> looks like a generic version of <code>check_star_proper_name</code> and
<code>check_star_spectrum</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/lib/stellar.pir

# ...

.sub check_star_field
    .param pmc star
    .param string field
    .param string desired_value
    .local string actual_value
    .local int check_result

    actual_value = star[field]
    check_result = desired_value == actual_value
    .return(check_result)
.end</code></pre>
</figure><p>All tests are still passing. You <em>are</em> working along with me and running tests,
right? It&rsquo;s time to decide what to do with those specific subs now that we have
a nice general purpose field checker. You could argue that those subs should
stick around but as wrappers that call <code>check_star_field</code>. That is entirely
reasonable. I am comfortable using the general purpose sub as my main checker,
though. I will delete the specific subs and their tests in my code.</p>
<h3 id="testing-multiple-conditions">Testing Multiple Conditions</h3>
<p><code>stellar</code> does a convincing job of checking a single field in a star. The next
step is figuring out how to check multiple fields.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-07/t/04-check-star.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star

    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star = extract_from_csv_line(star_string)

    plan(9)

    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have Spectrum of &#34;G2V&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have Spectrum of &#34;K3V&#34;&#39;)

    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName &#34;Sol&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Sol&#39;, &#39;Spectrum&#39;, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have ProperName &#34;Sol&#34; and Spectrum &#34;G2V&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Arcturus&#39;, &#39;Spectrum&#39;, &#39;G2V&#39;)
    nok($I0, &#39;Sol should not have ProperName &#34;Arcturus&#34; and Spectrum &#34;G2V&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Sol&#39;, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have ProperName &#34;Sol&#34; and Spectrum &#34;K3V&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Arcturus&#39;, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have ProperName &#34;Arcturus&#34; and Spectrum &#34;K3V&#34;&#39;)
.end</code></pre>
</figure><p>Yes, I did go through several variations on testing multiple fields. I wanted to
make sure that <code>check_star</code> behaved <em>exactly</em> the way I expected. How am I going
to make those tests succeed?</p>
<h4 id="slurpy-and-flat-save-the-day"><code>:slurpy</code> and <code>:flat</code> Save the Day</h4>
<p>Parrot gives us two excellent modifiers that simplify the job of checking
multiple fields. The <code>:slurpy</code> param modifier to effectively say &ldquo;Oh,
there might be some other params. Just put them in an array.&rdquo; The flip side of
that is the <code>:flat</code> modifier in subroutine calls, which lets us say &ldquo;Oh, I have
this array of stuff. Just tack its elements to the param list for the sub I&rsquo;m
about to call.&rdquo;</p>
<p>Enough imaginary dialog. Here&rsquo;s what <code>check_star</code> looks like.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-07/lib/stellar.pir
.sub check_star
    .param pmc    star
    .param string field
    .param string desired_value
    .param pmc    extra_fields :slurpy
    .local int    match_result
    .local int    extra_field_count

    match_result = check_star_field(star, field, desired_value)

    # We&#39;re done if this match fails.
    unless match_result goto RETURN_RESULT

    extra_field_count = extra_fields
    # We&#39;re done if there are no extra fields.
    unless extra_field_count goto RETURN_RESULT

    # Grab the result of checking the extra fields.
    match_result = check_star(star, extra_fields :flat)

  RETURN_RESULT:
    .return(match_result)
.end</code></pre>
</figure><p>I tried to make it clear what was going on the comments. <code>check_star</code> is given a
star and a handful of conditions. It only cares about the first condition, and
stuffs the rest into <code>extra_fields</code>. If the first condition fails, we&rsquo;re done.
There&rsquo;s no point in checking any more fields, so jump down to return the failure.
If there are no other conditions to check - which we determine by looking at
the size of <code>extra_fields</code> - we return the result, which should be a success.</p>
<p>If there <em>are</em> more conditions to check, we call <code>check_star</code> again, using the
star and the conditions we had stuffed into <code>extra_fields</code>. That goes through
the same process of testing and looking for extra conditions until it has
completed the last test. The result of all the completed tests is handed back to
<code>check_star</code>, which then hands it back to us.</p>
<p>This process of <a href="http://en.wikipedia.org/wiki/Recursion_%28computer_science%29">recursion</a> -
solving a complex problem by breaking it down into small problems - is common in
many programming languages, so it is supported by Parrot. After all, Parrot is
supposed to be used for creating new languages. It is not just for
browsing some guy&rsquo;s star catalog.</p>
<p>The &ldquo;<a href="http://en.wikipedia.org/wiki/Tail_call">tail call</a>&rdquo; pattern of evaluating a sub and immediately returning its result is so
common that Parrot provides the <code>.tailcall</code> directive to optimize its
behavior. <code>.tailcall</code> essentially tells Parrot to immediately return the result
of evaluating the sub rather than storing it in memory. It may not do much in a
case like <code>check_star</code>, but you should see a difference in complex problems.</p>
<p>Then again, it might help <code>check_star</code> immensely. I don&rsquo;t really know about
Parrot optimization effects yet.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-08/lib/stellar.pir
.sub &#39;main&#39; :main
    # ...

    # Return the result of checking the extra fields.
    .tailcall check_star(star, extra_fields :flat)

  RETURN_RESULT:
    .return(match_result)
.end</code></pre>
</figure><h2 id="conclusion">Conclusion</h2>
<p>We can now examine multiple fields to determine if a star matches a description
we&rsquo;ve provided. Along the way, we explored subroutine parameters. We learned how
to make a parameter optional. We learned how to grab all of a subroutine&rsquo;s
params and stuff them into a list. We also learned how to paste the contents of
a list onto the parameters of a subroutine call. We even dabbled in
<a href="http://en.wikipedia.org/wiki/Recursion_%28computer_science%29">recursion</a>, the fine art of breaking a big problem down with small solutions.</p>
<p>In our next step, we will use <code>check_star</code> to search through sets of stars.
That&rsquo;s the part I&rsquo;ve been looking forward to for a while!</p>
<p>In the meantime, continue your own [Parrot][] exploration. You might review the
Parrot <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch06_subroutines.pod.html">Subroutines chapter</a> a little more. I hardly left that page while
working through this step. Whatever you do, remember to have fun!</p>

  






  <hr>
  

  
  
<hr>
<div class="footer">
    
      <p>Series: <a href="/series/parrot-babysteps">Parrot Babysteps</a></p>
    
    
      <a class="previous-post" href="https://randomgeekery.org/post/2010/06/parrot-babysteps-0a-the-stellar-project/?ref=footer">
        <span style="font-weight:bold;">« Previous</span>
        <br>Parrot Babysteps 0a - The Stellar Project
      </a>
    
    
      <div class="next-post">
        <a href="https://randomgeekery.org/post/2010/07/parrot-babysteps-0x-the-stellar-app/?ref=footer">
          <span style="font-weight:bold;">Next »</span>
          <br>Parrot Babysteps 0c - The Stellar App
        </a>
      </div>
    
</div>

  
</div>
            </main>
            
  
    <div class="article-toc ">
    <div class="toc-wrapper">
      <h4 id="contents"></h4>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#thinking-through-the-problem">Thinking Through The Problem</a></li>
    <li><a href="#writing-code">Writing Code</a>
      <ul>
        <li><a href="#testing-a-condition">Testing a Condition</a></li>
        <li><a href="#revisiting-the-header_string">Revisiting the <code>header_string</code></a></li>
        <li><a href="#testing-multiple-conditions">Testing Multiple Conditions</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
</div>

  

        </div><script defer data-domain="randomgeekery.org" src="https://plausible.io/js/script.js"></script>
    </body>
</html>
