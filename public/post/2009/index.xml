<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>2009onRandom Geekery</title>
    <link>https://randomgeekery.org/post/2009/</link>
    <description>
      Recent contentin2009 on Random Geekery
    </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
      
      <lastBuildDate>Sat, 20 Jan 2024 22:42:33 -0800</lastBuildDate><atom:link href="https://randomgeekery.org/post/2009/index.xml" rel="self" type="application/rss+xml" /><item>
  <title>Post: Parrot Babysteps 08 - Testing With Test::More</title>
  <link>https://randomgeekery.org/post/2009/12/parrot-babysteps-08-testing-with-testmore/</link>
  <pubDate>Wed, 16 Dec 2009 00:00:00 -0800</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/12/parrot-babysteps-08-testing-with-testmore/</guid>
  <description>&lt;p&gt;Co-written by &lt;a href=&#34;http://leto.net&#34;&gt;Jonathan “Duke” Leto&lt;/a&gt;, &lt;a href=&#34;https://randomgeekery.org/card/parrot/&#34;&gt;Parrot&lt;/a&gt; core developer
and author of &lt;a href=&#34;http://github.com/leto/tapir&#34;&gt;Tapir&lt;/a&gt;.&lt;/p&gt;</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>Co-written by <a href="http://leto.net">Jonathan &ldquo;Duke&rdquo; Leto</a>, <a href="/card/parrot/">Parrot</a> core developer
and author of <a href="http://github.com/leto/tapir">Tapir</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>I&rsquo;ll be creating more complex PIR programs soon, but first I want to stop for a minute and look at
testing in Parrot. Why? Code is a weird thing. You need to pin
down its behavior as specifically as you can, or it&rsquo;ll become
unreadable before you realize what&rsquo;s going on. Good tests help you describe
how your program should behave. Tests aren&rsquo;t a magic pill that will guarantee
perfect programs, but they <em>will</em> help you check that your program behaves the
way you claim it does.</p>
<p>There are many testing libraries in the programming world, but I will focus
on <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> for Parrot.</p>
<h2 id="using-testmore-to-write-tests">Using Test::More to Write Tests</h2>
<p><a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> is more or less an implementation of <a href="http://perldoc.perl.org/Test/More.html">Perl&rsquo;s Test::More</a>. It provides a set of simple
assertions such as <code>ok</code>, <code>is</code>, and <code>isnt</code>, along with a few testing-specific
commands like <code>skip</code> and <code>todo</code>. I&rsquo;ll be looking at some of those simple assertions, but
not spending so much time on the testing commands. This <em>is</em> a Babystep, after all.</p>
<p>Test::More is already included in the standard Parrot runtime, so we don&rsquo;t need
to do anything special to install it. Even better - there&rsquo;s a <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">test_more.pir</a> include
file that you can include to import all of the important Test::More subroutines
automatically.</p>
<p>Let&rsquo;s start writing tests.</p>
<h3 id="plan"><code>plan</code></h3>
<p>Every test needs a plan. The <code>plan</code> subroutine in Test::More tells the world
one simple thing: how many tests are in this file. Accuracy is important,
because it&rsquo;s no fun when you are told to expect ten tests but only five run.
The other five might not have run for a number of reasons: the test script failed,
Parrot failed in some mysterious way, or you just forgot to mention that you
removed half of your tests.</p>
<p>We don&rsquo;t plan to have any tests yet, so let&rsquo;s be honest.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-01.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(0)
.end</code></pre>
</figure><p>The <code>.include</code> directive will insert the contents of <code>test_more.pir</code> into the
subroutine, which saves us a lot of namespace wrangling. The testing starts
when a <em>plan</em> is declared.</p>
<p>Of course, this is <em>not</em> the most exciting test plan in the world to run.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-01.pir
$</code></pre>
</figure><p>What if we lie?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-02.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(10)
.end</code></pre>
</figure><p>Running this is a little different.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-02.pir
1..10</code></pre>
</figure><p>Now Parrot is telling whoever cares that there will be ten tests in this file.
It&rsquo;s true that nothing exploded. For right now, you&rsquo;re going to have to trust me
when I say that honesty is the best policy. You&rsquo;ll see later that some tools
do care about how many tests you claim to run.</p>
<h3 id="diag"><code>diag</code></h3>
<p>All right. Sometimes we want to make a comment in our test for the world to see.
We could just <code>say</code> what we want to say, but Test::More provides the <code>diag</code>
subroutine to produce those comments in a manner that will make testers happy later.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-03.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(10)
    diag(&#39;There are no tests. The plan is a lie.&#39;)
.end</code></pre>
</figure><p>What does this produce?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-03.pir
1..10
# There are no tests. The plan is a lie.</code></pre>
</figure><p>See the <code>#</code>? That&rsquo;s supposed to make our diagnostic comment stand out from
the test results without confusing anyone. But the diagnostic makes me sad.
Let&rsquo;s write an actual test.</p>
<h3 id="ok"><code>ok</code></h3>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-04.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(1)
    ok(1, &#39;`ok` tests for simple truth&#39;)
.end</code></pre>
</figure><p><code>ok</code> takes two arguments:</p>
<ul>
<li>The value you are testing</li>
<li>A description of the test</li>
</ul>
<p>The value being tested is obviously the most important part, but don&rsquo;t underestimate
the helpfulness of those descriptions. They are a form of documentation.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-04.pir
1..1
ok 1 - `ok` tests for simple truth</code></pre>
</figure><p>The test in <code>ok</code> is one of simple truth as seen by Parrot. <a href="/post/2009/09/parrot-babysteps-03-simple-control-structures/">parrot-babysteps-03-simple-control-structures</a> showed us that anything which looks like <code>0</code> or an empty string is considered false by Parrot, while everything else is considered true.</p>
<p>What happens when we introduce a test that we know will fail?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-05.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(2)
    ok(1, &#39;`ok` tests for simple truth&#39;)
    ok(0, &#39;0 is false, so this should fail.&#39;)
.end</code></pre>
</figure><p>You updated your plan, right? Anyways, let&rsquo;s see what this produces.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-05.pir
1..2
ok 1 - `ok` tests for simple truth
not ok 2 - 0 is false, so this should fail.</code></pre>
</figure><p>Oh hey, this is starting to get interesting! Now we can see clearly that the output
from <code>ok</code> is a line split into three parts:</p>
<ul>
<li>The result of the test: &ldquo;<code>ok</code>&rdquo; or &ldquo;<code>not ok</code>&rdquo;</li>
<li>The test number</li>
<li>Our description string</li>
</ul>
<p><code>ok</code> has shown us what a test result line looks like. Let&rsquo;s look at
some of the other simple assertions.</p>
<h3 id="nok"><code>nok</code></h3>
<p>Sometimes you are more concerned if something is true which shouldn&rsquo;t be. For
example, let&rsquo;s say we have a Web site building script. It builds temporary
cache files to save time when building subpage links, but those cache files
need to go away when it&rsquo;s done. So we would test for existence of a cache file
and fail if the file exists.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-06.pir

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local int cache_file_exists

    plan(1)
    cache_file_exists = stat &#39;subpages.data&#39;, 0
    nok(cache_file_exists, &#39;Cache files should be cleaned up&#39;)
.end</code></pre>
</figure><p>The assertion may be <code>nok</code>, but the output is still <code>ok</code> or not based on whether
the assertion was true.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-06.pir
1..1
ok 1 - Cache files should be cleaned up</code></pre>
</figure><p>What does it look like if we deliberately confuse things?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ touch subpages.data
$ parrot example-08-06.pir
1..1
not ok 1 - Cache files should be cleaned up</code></pre>
</figure><p>Yes. That&rsquo;s what I hoped to see. Let&rsquo;s clean up after ourselves to avoid future
confusion.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ rm subpages.data</code></pre>
</figure><h3 id="is"><code>is</code></h3>
<p>There are many times where we want to compare two values. Let&rsquo;s continue with our Web site
building tool. This tool sets the title of a page in metadata. We obviously want to be
certain that it reads the metadata correctly. We would use the <code>is</code> assertion for
that kind of test.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-07.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local string expected_title
    .local string actual_title

    expected_title = &#39;08 - Test::More and Tapir&#39;

    plan(1)

    # Okay, let&#39;s pretend we got this result by running the builder.
    actual_title = &#39;08 - Test::More and Tapir&#39;
    is(actual_title, expected_title, &#39;The title should be correct.&#39;)
.end</code></pre>
</figure><p>Anybody know what we should see?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-07.pir
1..1
ok 1 - The title should be correct.</code></pre>
</figure><p>Let&rsquo;s deliberately mess things up again so we know what failure of <code>is</code> looks like.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-08.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local string expected_title
    .local string actual_title

    expected_title = &#39;08 - Test::More and Tapir&#39;

    plan(1)

    # Okay, let&#39;s pretend we got this result by running the builder.
    actual_title = &#39;I am a Walrus&#39;
    is(actual_title, expected_title, &#39;The title should be correct.&#39;)
.end</code></pre>
</figure><p>A failed <code>is</code> produces some useful information.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-08.pir
1..1
not ok 1 - The title should be correct.
# Have: I am a Walrus
# Want: 08 - Test::More and Tapir</code></pre>
</figure><p>There&rsquo;s the test result line, which shows &rsquo;not ok&rsquo;, just like we expected.
We also have a couple of diagnostic lines describing what we want and what we
actually have.</p>
<p><code>ok</code> has its opposite assertion <code>nok</code>, so there must be an opposite for <code>is</code>, right?
There sure is.</p>
<h3 id="isnt"><code>isnt</code></h3>
<p>Occasionally we care less about what a value is than making sure it&rsquo;s <em>not</em> something
in particular. Maybe we have a user registration process that uses social security numbers
to satisfy an obscure corporate tracking requirement, but can&rsquo;t save them as-is because of
privacy concerns. In this case we don&rsquo;t care what the stored value is. We want to be certain
that it&rsquo;s not the social security number.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-09.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local string provided_ssn
    .local string stored_ssn

    provided_ssn = &#39;5551234567&#39;

    plan(1)

    # Okay, let&#39;s pretend we got this result via user registration
    stored_ssn = &#39;wxdfk$!&#39;
    isnt(provided_ssn, stored_ssn, &#39;SSN should not be stored as-is&#39;)
.end</code></pre>
</figure><p>Really, nobody should be surprised by the output at this point.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >1..1
ok 1 - SSN should not be stored as-is</code></pre>
</figure><p>What does a failed <code>isnt</code> look like?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-10.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local string provided_ssn
    .local string stored_ssn

    provided_ssn = &#39;5551234567&#39;

    plan(1)

    # Okay, let&#39;s pretend we got this result via user registration
    stored_ssn = provided_ssn
    isnt(provided_ssn, stored_ssn, &#39;SSN should not be stored as-is&#39;)
.end</code></pre>
</figure><p>The output diagnostic is once again straightforward.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-10.pir
1..1
not ok 1 - SSN should not be stored as-is
# Have: 5551234567
# Want: not 5551234567</code></pre>
</figure><h3 id="is_deeply"><code>is_deeply</code></h3>
<p><code>is</code> fails us when we need to compare PMCs. Well, it <em>sort of</em> works:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-11.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local pmc expected_details
    .local pmc actual_details

    expected_details = new &#39;Hash&#39;
    expected_details[&#39;first&#39;] = &#39;Super&#39;
    expected_details[&#39;last&#39;] = &#39;Man&#39;

    actual_details = new &#39;Hash&#39;
    actual_details[&#39;first&#39;] = &#39;Super&#39;
    actual_details[&#39;last&#39;] = &#39;Woman&#39;

    plan(1)

    is(expected_details, actual_details, &#39;Super Man is not Super Woman&#39;)
.end</code></pre>
</figure><p>The output isn&rsquo;t incredibly useful, though.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-11.pir
1..1
not ok 1 - Super Man is not Super Woman
# Have: Hash[0x25ee84]
# Want: Hash[0x25ee48]</code></pre>
</figure><p>Thankfully, we have the <code>is_deeply</code> assertion to tell use exactly how a test
has failed.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-12.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local pmc expected_details
    .local pmc actual_details

    expected_details = new &#39;Hash&#39;
    expected_details[&#39;first&#39;] = &#39;Super&#39;
    expected_details[&#39;last&#39;] = &#39;Man&#39;

    actual_details = new &#39;Hash&#39;
    actual_details[&#39;first&#39;] = &#39;Super&#39;
    actual_details[&#39;last&#39;] = &#39;Woman&#39;

    plan(1)

    is_deeply(expected_details, actual_details, &#39;Super Man is not Super Woman&#39;)
.end</code></pre>
</figure><p>Now we can see exactly which value in the PMC was different.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-12.pir
1..1
not ok 1 - Super Man is not Super Woman
# Mismatch at [last]: expected Man, received Woman</code></pre>
</figure><p>With <code>is_deeply</code> under our belt, we now know enough assertions to get started putting them to use in real
projects.</p>
<h3 id="what-about-the-other-assertions-and-commands">What About The Other Assertions and Commands?</h3>
<p>We won&rsquo;t be talking about them. I may eventually visit more as we get
the hang of Parrot, but this is a good enough core to start with. Do
you want to dig deeper? Go right ahead. The best resource for the
moment is the documentation within <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> itself.</p>
<h3 id="tap---the-test-anything-protocol">TAP - The Test Anything Protocol</h3>
<p>All of this output has looked remarkably consistent. There&rsquo;s a reason
for that. <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> formats its result in a format known as TAP - the
<a href="http://en.wikipedia.org/wiki/Test_Anything_Protocol">Test Anything Protocol</a>. All of the output can be read by another program
to provide you with a summary report. This other program is usually referred
to as a <a href="http://en.wikipedia.org/wiki/Test_harness">test harness</a>. The
test harness runs your tests and then tells you how many of them failed, or
if there were any surprises.</p>
<p>All I need is a test harness. I&rsquo;ll be back to talk about <a href="http://github.com/leto/tapir">Tapir</a> very soon.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Hey, we can test now! We learned how to use the <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> library, making
simple assertions and reporting the results using the <a href="http://en.wikipedia.org/wiki/Test_Anything_Protocol">Test Anything Protocol</a>.
As long as we stay disciplined and run our tests regularly, we will learn
immediately when we have an &ldquo;inspired&rdquo; moment that breaks existing code. Since
I&rsquo;m such a huge fan of Test-Driven Development, you can be assured of seeing many assertions in
future Parrot Babysteps.</p>]]></content:encoded>
</item>
<item>
  <title>Post: NQP - Not Quite Perl</title>
  <link>https://randomgeekery.org/post/2009/12/nqp-not-quite-perl/</link>
  <pubDate>Wed, 09 Dec 2009 00:00:00 -0800</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/12/nqp-not-quite-perl/</guid>
  <description>&lt;p&gt;&lt;a href=&#34;https://randomgeekery.org/card/parrot/&#34;&gt;Parrot&lt;/a&gt; is more than just PIR and PASM. I’m not talking about the
ability to use languages like &lt;a href=&#34;http://rakudo.org&#34;&gt;Rakudo&lt;/a&gt; written for the Parrot virtual
machine. I am also not talking about the ability to write your own language.
Both of those are quite nifty, of course. It is fair to say that those two
items are probably why you are experimenting with Parrot in the first place.
However, the Parrot distribution also ships with an extra language: NQP.&lt;/p&gt;</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>perl</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p><a href="/card/parrot/">Parrot</a> is more than just PIR and PASM. I&rsquo;m not talking about the
ability to use languages like <a href="http://rakudo.org">Rakudo</a> written for the Parrot virtual
machine. I am also not talking about the ability to write your own language.
Both of those are quite nifty, of course. It is fair to say that those two
items are probably why you are experimenting with Parrot in the first place.
However, the Parrot distribution also ships with an extra language: NQP.</p>
<p><a href="http://docs.parrot.org/parrot/latest/html/docs/book/pct/ch05_nqp.pod.html">NQP</a> - Not Quite Perl - is an implementation of a small subset of Perl 6 that
can be used as a higher level Parrot language than PIR. It is especially useful
in defining the grammars for your Parrot languages.</p>
<h2 id="getting-nqp">Getting NQP</h2>
<p>You already have NQP if you have a fresh installation of Parrot. You can
find directions for installing in <a href="/post/2009/07/parrot-babysteps-01-getting-started/">parrot-babysteps-01-getting-started</a> if
you do not yet have Parrot installed.</p>
<h2 id="example">Example</h2>
<p>Let&rsquo;s just do a brutally fast NQP example.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >#!/usr/local/bin/parrot-nqp

my $name := get_input(&#34;What is your name?&#34;);
say(&#34;Hello $name&#34;);

my $valid_input := 0;

while ($valid_input == 0) {
    my $in_good_mood := get_input(&#34;Are you in a good mood?[y/n]&#34;);
    if ($in_good_mood eq &#34;y&#34;) {
        say(&#34;Glad to hear it! Must be all the Parrot hacking.&#34;);
        $valid_input := 1;
    } elsif ($in_good_mood eq &#34;n&#34;) {
        say(&#34;Oh, that&#39;s too bad. Try hacking on Parrot.&#34;);
        $valid_input := 1;
    } else {
        say(&#34;Sorry, I&#39;m not too bright. Please answer &#39;y&#39; or &#39;n&#39;.&#34;);
    }
}

sub get_input($prompt) {
    print(&#34;$prompt &#34;);
    my $name := Q:PIR{
        .local pmc stdin
        stdin = getstdin
        %r = stdin.&#39;readline_interactive&#39;()
    };

    return $name
}</code></pre>
</figure><p>We see that NQP variables look a little like Perl variables, and familiar
control structures like <code>if</code> and <code>while</code> are supported. Another bit of niftiness
is that inline PIR is supported.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot-nqp hello.nqp
What is your name? Brian
Hello Brian
Are you in a good mood?[y/n] waffles
Sorry, I&#39;m not too bright. Please answer &#39;y&#39; or &#39;n&#39;.
Are you in a good mood?[y/n] y
Glad to hear it! Must be all the Parrot hacking.</code></pre>
</figure><p>Mind you, NQP is not really great for casual scripting. It&rsquo;s intended to be
a higher level bootstrap language that makes it easier to define grammars.
I wouldn&rsquo;t go complaining to anybody that it&rsquo;s missing Feature X. Unless you
know how to implement it. Maybe. If you want Feature X, it might be better
to use Rakudo or implement it in your own Parrot language.</p>
<p>You could even use NQP to implement it. Is my logic circular enough for
you?</p>
<h2 id="learning-nqp">Learning NQP</h2>
<p>There is a good overview of NQP available at
<a href="http://en.wikibooks.org/wiki/Parrot_Virtual_Machine/Not_Quite_Perl">wikibooks</a>.</p>]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 07 - Writing Subroutines</title>
  <link>https://randomgeekery.org/post/2009/10/parrot-babysteps-07-writing-subroutines/</link>
  <pubDate>Tue, 06 Oct 2009 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/10/parrot-babysteps-07-writing-subroutines/</guid>
  <description>Introduction We accomplished quite a bit in parrot-babysteps-06-files-and-hashes. We figured out how to parse a 20 MB star catalog and search for information that we thought could be important. The only problem is that it was turning to spaghetti. Even though it had barely 100 lines of code, it was becoming a bigger challenge to figure out what was going on or how to add new features.
Today we’re going to streamline the code somewhat by wrapping that complexity in subroutines.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>We accomplished quite a bit in <a href="/post/2009/10/parrot-babysteps-06-files-and-hashes/">parrot-babysteps-06-files-and-hashes</a>.
We figured out how to parse a 20 MB star catalog and search for information that
we thought could be important. The only problem is that it was turning to
spaghetti. Even though it had barely 100 lines of code, it was becoming a bigger
challenge to figure out what was going on or how to add new features.</p>
<p>Today we&rsquo;re going to streamline the code somewhat by wrapping that complexity
in subroutines.  The <a href="/card/parrot/">Parrot</a> Book has a <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch06_subroutines.pod.html">sizable chapter discussing subroutines</a>.
I won&rsquo;t be spending much time exploring the depths of subroutines, because
that would take me far beyond what is appropriate for a babystep. However, a
quick glance at the chapter should suggest that Parrot subroutines are quite
powerful and worth deeper exploration on your own.</p>
<h2 id="subroutines">Subroutines</h2>
<p>We&rsquo;ve been working with subroutines since <a href="/post/2009/07/parrot-babysteps-01-getting-started/">parrot-babysteps-01-getting-started</a> Every Parrot application has a subroutine tagged as <code>:main</code> to show that it contains the main logic for the program. Let&rsquo;s start adding our own supplementary subroutines.</p>
<p>Our first function will encapsulate the display of star highlights.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-07-01

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main

    load_bytecode &#39;String/Utils.pbc&#39;

    .const string DELIMITER  = &#39;,&#39;
    .local pmc    chomp
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local int    field_count
    .local int    current_field_index
    .local string current_field_name
    .local string current_field_value
    .local pmc    star_data
    .local pmc    star
    .local string star_name
    .local string star_spectrum
    .local pmc    sol
    .local string sol_spectrum
    .local int    matching_count
    .local int    unnamed_match_count

    chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;
    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    current_line  = chomp(current_line)
    field_names   = split DELIMITER, current_line
    field_count   = field_names

    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    current_field_index = 0
    sol = new &#39;Hash&#39;

  ASSIGN_NEXT_SOL_FIELD:
    if current_field_index &gt;= field_count goto FIND_MATCHING_STARS
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    sol[current_field_name] = current_field_value
    current_field_index &#43;= 1
    goto ASSIGN_NEXT_SOL_FIELD

  FIND_MATCHING_STARS:
    sol_spectrum = sol[&#39;Spectrum&#39;]
    matching_count = 0
    unnamed_match_count = 0
    # We want to show Sol&#39;s details as well as other matches.
    say_star_details(sol)

  LOAD_NEXT_STAR:
    unless data_file goto END
    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    current_field_index = 0
    star = new &#39;Hash&#39;

  ASSIGN_NEXT_STAR_FIELD:
    if current_field_index &gt;= field_count goto EXAMINE_STAR
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    star[current_field_name] = current_field_value
    current_field_index &#43;= 1
    goto ASSIGN_NEXT_STAR_FIELD

  EXAMINE_STAR:
    star_spectrum = star[&#39;Spectrum&#39;]
    if star_spectrum == sol_spectrum goto REMEMBER_MATCH
    goto LOAD_NEXT_STAR

  REMEMBER_MATCH:
    matching_count &#43;= 1
    star_name = star[&#39;ProperName&#39;]
    if star_name goto DISPLAY_STAR_DETAILS
    unnamed_match_count &#43;= 1
    goto LOAD_NEXT_STAR

  DISPLAY_STAR_DETAILS:
    say_star_details(star)
    goto LOAD_NEXT_STAR

  END:
    close data_file
    print matching_count
    print &#34; stars exactly matched Sol&#39;s spectrum &#34;
    say sol_spectrum
    print unnamed_match_count
    say &#39; have no proper name&#39;

.end

.sub say_star_details
    .param pmc star

    .local string star_name
    .local string star_spectrum
    .local string star_distance

    star_name = star[&#39;ProperName&#39;]
    star_spectrum = star[&#39;Spectrum&#39;]
    star_distance = star[&#39;Distance&#39;]

    print &#34;&lt;Name: &#34;
    print star_name
    print &#34;, Spectrum: &#34;
    print star_spectrum
    print &#34;, Distance: &#34;
    print star_distance
    say &#34;&gt;&#34;
.end</code></pre>
</figure><p>To create a subroutine that will get used by your <code>:main</code> sub, all
you need to do is declare a <code>.sub</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub say_star_details
.end</code></pre>
</figure><p>I like my subroutine names to clearly describe the task being accomplished,
to minimize the guesswork when I come back to code later.</p>
<p>This subroutine accepts a single parameter: a Hash describing the star to be
printed. We learned <a href="/post/2009/09/parrot-babysteps-04-adding-command-line-arguments/">a few steps ago</a>
that the <code>.param</code> directive declares a parameter for your subroutine.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub say_star_details
    .param pmc star
.end</code></pre>
</figure><p>The subroutine body in this case is going to be a copy and paste of the
<code>DISPLAY_STAR_DETAILS</code> code chunk, along with declarations of <code>.local</code>
variables needed to make it work.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub say_star_details
    .param pmc star

    .local string star_name
    .local string star_spectrum
    .local string star_distance

    star_name = star[&#39;ProperName&#39;]
    star_spectrum = star[&#39;Spectrum&#39;]
    star_distance = star[&#39;Distance&#39;]

    print &#34;&lt;Name: &#34;
    print star_name
    print &#34;, Spectrum: &#34;
    print star_spectrum
    print &#34;, Distance: &#34;
    print star_distance
    say &#34;&gt;&#34;
.end</code></pre>
</figure><p>We no longer care about stellar distances in our main code, so we can safely
remove the <code>.local string star_distance</code> directive from <code>main</code>.</p>
<p>Now we can rewrite our code to display Sol&rsquo;s details. Remember that subroutines
require that their parameters be wrapped in parentheses.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># We want to show Sol&#39;s details as well as other matches.
say_star_details(sol)</code></pre>
</figure><p>We could have also wrapped <code>say_star_details</code> in quotes, but it&rsquo;s only required
when our subroutines have non-ASCII characters - that is, characters outside the
range of what we consider &ldquo;normal&rdquo; characters in the United States. Still, I won&rsquo;t
complain if you&rsquo;re devoted to good form and prefer to show those subroutine calls
as:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&#39;say_star_details&#39;(sol)</code></pre>
</figure><p>The <code>DISPLAY_STAR_DETAILS</code> chunk becomes just a few lines:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >DISPLAY_STAR_DETAILS:
  say_star_details(star) # or &#39;say_star_details&#39;(star)
  goto LOAD_NEXT_STAR</code></pre>
</figure><p>Does it produce the same result as the code we ran before?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-07-01.pir 
&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;
&lt;Name: Rigel Kentaurus A, Spectrum: G2V, Distance: 1.34749097181049&gt;
568 stars exactly matched Sol&#39;s spectrum G2V
567 have no proper name</code></pre>
</figure><p>It sure does. The code is still rather awkward, though. How about we add a
subroutine for transforming a line from the text file into star data?</p>
<h2 id="returning-values">Returning Values</h2>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-07-02

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main

    load_bytecode &#39;String/Utils.pbc&#39;

    .const string DELIMITER  = &#39;,&#39;
    .local pmc    chomp
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local pmc    star_data
    .local pmc    star
    .local string star_name
    .local string star_spectrum
    .local pmc    sol
    .local string sol_spectrum
    .local int    matching_count
    .local int    unnamed_match_count

    chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;
    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    current_line  = chomp(current_line)
    field_names   = split DELIMITER, current_line

    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    sol = extract_star_details(field_names, star_data)

  FIND_MATCHING_STARS:
    sol_spectrum = sol[&#39;Spectrum&#39;]
    matching_count = 0
    unnamed_match_count = 0
    # We want to show Sol&#39;s details as well as other matches.
    say_star_details(sol)

  LOAD_NEXT_STAR:
    unless data_file goto END
    current_line = readline data_file
    current_line = chomp(current_line)
    star_data    = split DELIMITER, current_line
    star         = extract_star_details(field_names, star_data)

  EXAMINE_STAR:
    star_spectrum = star[&#39;Spectrum&#39;]
    if star_spectrum == sol_spectrum goto REMEMBER_MATCH
    goto LOAD_NEXT_STAR

  REMEMBER_MATCH:
    matching_count &#43;= 1
    star_name = star[&#39;ProperName&#39;]
    unless star_name goto LOAD_NEXT_STAR
    if star_name goto DISPLAY_STAR_DETAILS
    unnamed_match_count &#43;= 1
    goto LOAD_NEXT_STAR

  DISPLAY_STAR_DETAILS:
    say_star_details(star)
    goto LOAD_NEXT_STAR

  END:
    close data_file
    print matching_count
    print &#34; stars exactly matched Sol&#39;s spectrum &#34;
    say sol_spectrum
    print unnamed_match_count
    say &#39; have no proper name&#39;

.end

.sub extract_star_details
    .param pmc headers
    .param pmc values

    .local pmc star
    .local int header_count
    .local string current_header
    .local string current_value
    .local int current_index

    current_index = 0
    header_count = headers
    star = new &#39;Hash&#39;

  ASSIGN_NEXT_STAR_FIELD:
    if current_index &gt;= header_count goto RETURN_STAR
    current_header = headers[current_index]
    current_value = values[current_index]
    star[current_header] = current_value
    current_index &#43;= 1
    goto ASSIGN_NEXT_STAR_FIELD


  RETURN_STAR:
    .return(star)
.end

.sub say_star_details
    # ...
.end</code></pre>
</figure><p>The code is starting to get a little long, so I am adopting the habit
of replacing subroutine blocks with <code># ...</code> when the code is unchanged from
the previous example.</p>
<p>Most of the code in our new <code>extract_star_details</code> subroutine looks familiar, but we do
have one noteworthy addition:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.return(star)</code></pre>
</figure><p>This directive hands the Hash we&rsquo;ve just built back to whoever called the function.</p>
<p>Is our application cleaner? Yes, a little bit. I&rsquo;m tired of having so many unnamed
stars, though. Let&rsquo;s add a little logic to attempt an alternate name if no proper
name is available.</p>
<h3 id="making-say_star_details-smarter">Making <code>say_star_details</code> Smarter</h3>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-07-03
.sub &#39;main&#39; :main

    load_bytecode &#39;String/Utils.pbc&#39;

    .const string DELIMITER  = &#39;,&#39;
    .local pmc    chomp
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local pmc    star_data
    .local pmc    star
    .local string star_spectrum
    .local pmc    sol
    .local string sol_spectrum
    .local int    matching_count

    chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;
    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    current_line  = chomp(current_line)
    field_names   = split DELIMITER, current_line

    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    sol = extract_star_details(field_names, star_data)

  FIND_MATCHING_STARS:
    sol_spectrum = sol[&#39;Spectrum&#39;]
    matching_count = 0
    # We want to show Sol&#39;s details as well as other matches.
    say_star_details(sol)

  LOAD_NEXT_STAR:
    unless data_file goto END
    current_line = readline data_file
    current_line = chomp(current_line)
    star_data    = split DELIMITER, current_line
    star         = extract_star_details(field_names, star_data)

  EXAMINE_STAR:
    star_spectrum = star[&#39;Spectrum&#39;]
    if star_spectrum == sol_spectrum goto REMEMBER_MATCH
    goto LOAD_NEXT_STAR

  REMEMBER_MATCH:
    matching_count &#43;= 1
    say_star_details(star)
    goto LOAD_NEXT_STAR

  END:
    close data_file
    print matching_count
    print &#34; stars exactly matched Sol&#39;s spectrum &#34;
    say sol_spectrum
.end

.sub extract_star_details
    # ...
.end

.sub say_star_details
    .param pmc star

    .local string star_name
    .local string star_spectrum
    .local string star_distance

    star_name = star[&#39;ProperName&#39;]
    star_spectrum = star[&#39;Spectrum&#39;]
    star_distance = star[&#39;Distance&#39;]

    if star_name goto DISPLAY_DETAILS

  TRY_GLIESE:
    .local string gliese_number
    gliese_number = star[&#39;Gliese&#39;]
    unless gliese_number goto TRY_BAYER_FLAMSTEED
    star_name = &#39;Gliese &#39; . gliese_number
    goto DISPLAY_DETAILS

  TRY_BAYER_FLAMSTEED:
    .local string bayer_flamsteed
    bayer_flamsteed = star[&#39;BayerFlamsteed&#39;]
    unless bayer_flamsteed goto TRY_HR
    star_name = &#34;BF &#34; . bayer_flamsteed
    goto DISPLAY_DETAILS

  TRY_HR:
    .local string hr_id
    hr_id = star[&#39;HR&#39;]
    unless hr_id goto TRY_HD
    star_name = &#34;HR &#34; . hr_id
    goto DISPLAY_DETAILS

  TRY_HD:
    .local string hd_id
    hd_id = star[&#39;HD&#39;]
    unless hd_id goto USE_STAR_ID
    star_name = &#34;HD &#34; . hd_id
    goto DISPLAY_DETAILS

  TRY_HIP:
    .local string hip_id
    hip_id = star[&#39;HIP&#39;]
    unless hip_id goto USE_STAR_ID
    star_name = &#34;HIP &#34; . hip_id
    goto DISPLAY_DETAILS

  USE_STAR_ID:
    .local string star_id
    star_id = star[&#39;StarID&#39;]
    star_name = &#34;HYG &#34; . star_id
    goto DISPLAY_DETAILS

  DISPLAY_DETAILS:
    print &#34;&lt;Name: &#34;
    print star_name
    print &#34;, Spectrum: &#34;
    print star_spectrum
    print &#34;, Distance: &#34;
    print star_distance
    say &#34;&gt;&#34;
.end</code></pre>
</figure><p>Now <em>this</em> version of the app displays everything along with some kind of
designation. The order I look for names is arbitrary, and is based
roughly in order of how familiar they looked to me. The tediousness of
determining which reference to use has been hidden away in the <code>say_star_details</code>
subroutine, and consists of simply checking each field for a value until
something useful is found. I knew there would be some kind of name to display,
so I removed the name-counting functionality from <code>main</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-07-03.pir | more
# ... much text omitted
&lt;Name: HYG 117782, Spectrum: G2V, Distance: 139.275766016713&gt;
&lt;Name: HD 224693, Spectrum: G2V, Distance: 94.0733772342427&gt;
568 stars exactly matched Sol&#39;s spectrum G2V</code></pre>
</figure><h2 id="conclusion">Conclusion</h2>
<p>Right. Our script has grown to the point where it shows every <code>G2V</code> star
in the HYG database, and some of the complexity of this task has been
tucked away behind subroutines. Is there more to be done? You bet! I would
love to add user search features to the code. That&rsquo;s going to a fair step
on its own, so I think I will close my Vim window and push this page.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 06 - Files and Hashes</title>
  <link>https://randomgeekery.org/post/2009/10/parrot-babysteps-06-files-and-hashes/</link>
  <pubDate>Fri, 02 Oct 2009 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/10/parrot-babysteps-06-files-and-hashes/</guid>
  <description>This one’s a bit more bloggy than the earlier steps, but that’s just the mood I was in when writing it. You can ignore the commentary and focus on the code if that’s your preference.
Introduction We have inched our way forward in our understanding of Parrot and PIR. I think that it’s time to take a big step, though. We’re going to add file handling to our toolkit. Reading and writing files are easy tasks in Parrot - so easy that I could probably discuss both in a couple of paragraphs and be more or less done.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>space</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p><img src="/post/2009/10/../../../attachments/img/2009/cover-2009-10-02.jpg" alt="attachments/img/2009/cover-2009-10-02.jpg"/></p>
<p>This one&rsquo;s a bit more bloggy than the earlier steps, but that&rsquo;s just the mood I was in when writing it. You can ignore the commentary and focus on the code if that&rsquo;s your preference.</p>
<h2 id="introduction">Introduction</h2>
<p>We have inched our way forward in our understanding of <a href="/card/parrot/">Parrot</a> and PIR. I think that it&rsquo;s time to take a big step, though. We&rsquo;re going to add file handling to our toolkit. Reading and writing files are easy tasks in Parrot - so easy that I could probably discuss both in a couple of paragraphs and be more or less done. But I&rsquo;m hungry for something meatier. I want to work with a lot of data and get curious trivia from that data. Hashes are good, too. Let&rsquo;s look at Parrot hashes at some point today as well.</p>
<h2 id="first-get-the-data">First, Get the Data</h2>
<p>It took me some time to decide exactly what sort of data I wanted to look at. I was thinking of <a href="http://www.ars.usda.gov/Services/docs.htm?docid=8964">nutritional data</a>, but I&rsquo;m not ready  for all of the cross-referencing I&rsquo;d have to do in order to produce information that would be meaningful to me.</p>
<p>Then it hit me. I love astronomy. Wait a moment. That&rsquo;s not completely true. I like astronomy. It teaches us a lot about our place in the universe, and exactly how freaking small we really are. What I love is random trivia about space: the name of the closest star to our solar system, how many of our neighboring stars are sort of like ours, stuff like that. I want to write a program that will help me get those juicy tidbits.</p>
<p>The next challenge was finding a data source that would be useful for me. There are plenty of <a href="http://en.wikipedia.org/wiki/List_of_Star_catalogues">star catalogs</a> available. The problem is that I like astronomy - I don&rsquo;t love it. Much of modern astronomy is incomprehensible to me unless it has a pretty picture of a penny next to a football field illustrating interplanetary distances or some other thing I can pretend to understand. Oh, and remember that I barely know Parrot. I need something simple and easy to parse, but big enough to have interesting data.</p>
<p>After nearly 15 minutes of dedicated research - once you subtract the hours spent admiring the <a href="http://apod.nasa.gov/apod/archivepix.html">Astronomy Picture of the Day archives</a> - I came across David Nash&rsquo;s <a href="http://astronexus.com">Astronomy Nexus</a>. This is a great resource for amateur astronomers, space trivia buffs, and people who enjoy geeky pictures like the view of Earth from <a href="http://astronexus.com/node/157">Gliese 581</a>. It also has a nice, easily parsed file listing almost 120,000 stars. At roughly 20 Megabytes uncompressed, that&rsquo;s big enough to be interesting.</p>
<p>Enough jabbering. Let&rsquo;s start downloading. The latest version of the catalog is available from the <a href="http://www.astronexus.com/node/34">HYG Database</a> page. I grabbed <a href="http://astronexus.com/files/downloads/hygxyz.csv.gz">version 2.0</a>, which is currently the most recent.</p>
<p>The file is compressed in <code>gz</code> format. Uncompressing it on Linux or OS X is easy:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ gunzip hygxyz.csv.gz</code></pre>
</figure><p>You&rsquo;re going to have to install an archive utility on Windows, though. I suggest  <a href="http://www.7-zip.org/">7-Zip</a>.</p>
<p>Put the resulting <a href="/card/csv/">CSV</a> (Comma-Separated Values) file in your project directory after uncompressing. Now  we have a file full of comma-separated values which look something like this:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PM\
Dec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ
0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0
1,1,224700,,,,,6.079e-05,01.08901332,282.485875706215,-5.20,-1.88,,9.10,1\
.84501631012894,F5,0.482,282.43485,0.00449,5.36884,4.9e-08,-7.12e-06,-2.5\
74e-06</code></pre>
</figure><p>My goodness, there are a lot of commas and numbers in there. The structure is sensible, though. We have a header line that tells us what each field represents, followed by <em>many</em> lines of data.</p>
<p>Let&rsquo;s start small, by counting the number of stars listed in the HYG database.</p>
<h2 id="counting-stars">Counting Stars</h2>
<p>To count stars, we can read each line of the file and count the number of lines read. Remember not to count the header line!</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-06-01

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main
    .local string filename
    .local pmc    data_file
    .local int    star_count
    .local string current_line

    filename = &#39;hygxyz.csv&#39;
    star_count = 0
    data_file = open filename, &#39;r&#39;

    # Avoid counting the header line as a star
    current_line = readline data_file

  NEXT_STAR:
    unless data_file goto SHOW_STAR_COUNT
    current_line = readline data_file
    star_count &#43;= 1
    goto NEXT_STAR

  SHOW_STAR_COUNT:
    close data_file
    print &#39;There are &#39;
    print star_count
    say &#39; stars in the HYG catalog.&#39;

.end</code></pre>
</figure><p>We use Parrot&rsquo;s <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch08_io.pod.html">I/O library</a> to handle opening and reading files. <code>open</code> will actually open the file for us.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >data_file = open filename, &#39;r&#39;</code></pre>
</figure><p>The <code>open</code> opcode accepts two arguments: the name of the file and a mode indicator. We are reading the file, so we specify mode <code>r</code>.</p>
<p>What will we use to read a line from the file? How about the <code>readline</code>?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >current_line = readline data_file</code></pre>
</figure><p>A file that reached EOF (End Of File) and has nothing left to read looks false to Parrot. That means we can use the filehandle to test if we should keep reading.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >unless data_file goto SHOW_STAR_COUNT</code></pre>
</figure><p>Finally, it is polite to close a file when we&rsquo;re done using it.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >close data_file</code></pre>
</figure><p>Is it <em>necessary</em> to close the file, though? That&rsquo;s a reasonable question. Many modern languages close files automatically when their handle goes out of scope — for example, when the program ends. The Parrot Book <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch08_io.pod.html">I/O chapter</a> does not make it clear what Parrot&rsquo;s approach is, though. I&rsquo;m going to keep closing those finished files until somebody tells me otherwise.</p>
<p>I&rsquo;ll probably continue closing finished files even after somebody tells me otherwise, truthfully.  I am one of those people who likes explicit code and ties his shoelaces with a tidy little double-knot. I can&rsquo;t help it - it&rsquo;s in my nature.</p>
<p>That&rsquo;s all the important information about reading files. Oh sure, there are details we&rsquo;ll need to look at eventually, such as what happens when the file doesn&rsquo;t exist or you don&rsquo;t have permission. But for reading a file that we know exists and that we can read, <code>open</code>, <code>readline</code>, and <code>close</code> are the main bits.</p>
<p>How many stars are in HYG?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ example-06-01.pir
There are 119618 stars in the HYG catalog.</code></pre>
</figure><p>That is a big number. Nowhere near the billions of stars in our universe, but I think we can stay busy for quite some time with nearly one hundred twenty thousand stars.</p>
<h3 id="intermission-file-mode-indicators">Intermission: File Mode Indicators</h3>
<p>Now is as good a time as any to summarize the indicator codes that <code>open</code> accepts.</p>
<table>
<thead>
<tr>
<th>Indicator</th>
<th>Mode</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r</code></td>
<td>read</td>
</tr>
<tr>
<td><code>w</code></td>
<td>write</td>
</tr>
<tr>
<td><code>a</code></td>
<td>append</td>
</tr>
<tr>
<td><code>p</code></td>
<td>pipe</td>
</tr>
</tbody>
</table>
<p>Indicators can be combined. For example, <code>rw</code> indicates that you plan to read and write to a file. In fact, <code>a</code> should not be used alone - specify that you will be write-appending to the file with <code>wa</code>.</p>
<p>Order doesn&rsquo;t matter, either. <code>rw</code> and <code>wr</code> are both valid ways to say you plan to read and write a file.</p>
<p>We will just be reading files today, but you might as well remember it now. It will come up eventually.</p>
<h2 id="counting-names">Counting Names</h2>
<p>All right. I&rsquo;m manually counting commas in HYG. It looks like &ldquo;ProperName&rdquo; is the seventh field. It also looks like there are quite a few stars in the catalog that have no proper name. How many?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-06-02

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    star_data
    .local string star_name
    .local int    star_count
    .local int    named_count
    .local int    unnamed_count

    filename = &#39;hygxyz.csv&#39;
    star_count = 0
    named_count = 0
    unnamed_count = 0
    data_file = open filename, &#39;r&#39;

    # Avoid counting the header line as a star
    current_line = readline data_file

  NEXT_STAR:
    unless data_file goto SHOW_STAR_COUNT
    current_line = readline data_file
    star_count &#43;= 1
    star_data = split &#39;,&#39;, current_line
    star_name = star_data[6]
    if star_name goto COUNT_NAMED_STAR
    unnamed_count &#43;= 1
    goto NEXT_STAR

  COUNT_NAMED_STAR:
    named_count &#43;= 1
    goto NEXT_STAR

  SHOW_STAR_COUNT:
    close data_file
    print &#39;There are &#39;
    print star_count
    say &#39; stars in the HYG catalog.&#39;
    print named_count
    say &#39; of them have proper names.&#39;
    print unnamed_count
    say &#39; of them do not have proper names.&#39;

.end</code></pre>
</figure><p>There is one new opcode in this code: the <code>split</code> <a href="http://docs.parrot.org/parrot/latest/html/src/ops/string.ops.html">String opcode</a>. It accepts a string delimiter and a target string, and returns the list of strings that result from splitting the target string with the delimiter.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >star_data = split &#39;,&#39;, current_line</code></pre>
</figure><p><code>star_data</code> is a normal array, so we can access the ProperName field by the index we came to in hand-counting the fields.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >star_name = star_data[6]</code></pre>
</figure><p>It is very clumsy to rely on hand-counting fields, so we will come back to that in a moment. First, let&rsquo;s look at what this application tells us.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-06-02.pir
There are 119618 stars in the HYG catalog.
87 of them have proper names.
119531 of them do not have proper names.</code></pre>
</figure><p>Only 87 of them have names? Huh. I thought there would be more than that. It&rsquo;s possible that the number is wrong because I was relying on hand-counting the fields. Let&rsquo;s tell Parrot to figure out the fields for us.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-06-03

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main
    .const string DELIMITER  = &#39;,&#39;
    .const string NAME_FIELD = &#39;ProperName&#39;
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local int    field_count
    .local string current_field
    .local int    name_index
    .local pmc    star_data
    .local string star_name
    .local int    star_count
    .local int    named_count
    .local int    unnamed_count

    filename      = &#39;hygxyz.csv&#39;
    name_index    = 0
    star_count    = 0
    named_count   = 0
    unnamed_count = 0
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    field_names   = split DELIMITER, current_line
    field_count   = field_names

  FIND_NAME_INDEX:
    if name_index &gt;= field_count goto NAME_INDEX_ERROR
    current_field = field_names[name_index]
    if current_field == NAME_FIELD goto NEXT_STAR
    name_index &#43;= 1
    goto FIND_NAME_INDEX

  NAME_INDEX_ERROR:
    say &#39;Went through available fields without finding name index!&#39;
    goto END

  NEXT_STAR:
    unless data_file goto SHOW_STAR_COUNT
    current_line = readline data_file
    star_count &#43;= 1
    star_data = split DELIMITER, current_line
    star_name = star_data[name_index]
    if star_name goto COUNT_NAMED_STAR
    unnamed_count &#43;= 1
    goto NEXT_STAR

  COUNT_NAMED_STAR:
    named_count &#43;= 1
    goto NEXT_STAR

  SHOW_STAR_COUNT:
    close data_file
    print &#39;There are &#39;
    print star_count
    say &#39; stars in the HYG catalog.&#39;
    print named_count
    say &#39; of them have proper names.&#39;
    print unnamed_count
    say &#39; of them do not have proper names.&#39;
    goto END

  END:
.end</code></pre>
</figure><p>Quite a few changes have been made. One of the first was to define constants for some important values which I know will never change.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.const string DELIMITER  = &#39;,&#39;
.const string NAME_FIELD = &#39;ProperName&#39;</code></pre>
</figure><p>Yes, <code>DELIMITER</code> uses more characters than <code>','</code>. I prefer referring to things by name when practical. This gives two benefits in my mind.</p>
<ol>
<li>I know the purpose of the value. The semantics of it appeals to me: &ldquo;split with    DELIMITER, which is <code>','</code>&rdquo; rather than &ldquo;split with <code>','</code> which is the delimiter&rdquo;.</li>
<li>I only have to change one spot. If someday David Nash wants to switch to tab    delimited files, I will not have to find and replace <code>','</code> throughout my code.</li>
</ol>
<p>As far as <code>NAME_FIELD</code>, that&rsquo;s just because I prefer referring to things by name. It doesn&rsquo;t really serve any other purpose. Choose your own style, but make sure others can read it.</p>
<p>The next task is to find which field holds the star name. We&rsquo;ll split the header line and step through each field until we either find the field we&rsquo;re looking for or hit the end.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >  current_line  = readline data_file
  field_names   = split DELIMITER, current_line
  field_count   = field_names

FIND_NAME_INDEX:
  if name_index &gt;= field_count goto NAME_INDEX_ERROR
  current_field = field_names[name_index]
  if current_field == NAME_FIELD goto NEXT_STAR
  name_index &#43;= 1
  goto FIND_NAME_INDEX

NAME_INDEX_ERROR:
  say &#39;Went through available fields without finding name index!&#39;
  goto END</code></pre>
</figure><p>Why did I finally throw some error-checking into this? I won&rsquo;t say, but believe me when I tell you to always look for typos in your code. And if your loop doesn&rsquo;t check if it&rsquo;s time to quit, that loop might never quit.</p>
<p>Now that Parrot knows which field holds the names, we can use it in our name counting.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >star_name = star_data[name_index]</code></pre>
</figure><p>Let&rsquo;s run the new code.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-06-03.pir
There are 119618 stars in the HYG catalog.
87 of them have proper names.
119531 of them do not have proper names.</code></pre>
</figure><p>I get the same result. The hand-counting of fields I did earlier worked. That&rsquo;s a relief, but I&rsquo;m much happier now that Parrot is counting for me.</p>
<h2 id="understanding-the-data-by-looking-at-sol">Understanding the Data by Looking at Sol</h2>
<p>I want to get a lot more information from this data, but in order to do that I&rsquo;ll need a nice way to understand the information about each star in the set. We&rsquo;re going to go about that by focusing on Sol, our own sun.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-06-04

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main
    .const string DELIMITER  = &#39;,&#39;
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local int    field_count
    .local int    current_field_index
    .local string current_field_name
    .local string current_field_value
    .local pmc    star_data

    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    field_names   = split DELIMITER, current_line
    field_count   = field_names

    current_line = readline data_file
    star_data = split DELIMITER, current_line
    close data_file
    current_field_index = 0

  DISPLAY_NEXT_FIELD:
    if current_field_index &gt;= field_count goto END
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    print current_field_name
    print &#39;: &#39;
    say current_field_value
    current_field_index &#43;= 1
    goto DISPLAY_NEXT_FIELD

  END:

.end</code></pre>
</figure><p>Sol is the first star listed after the header line, so we don&rsquo;t have to do anything clever to find it.</p>
<p>In order to display the field names and values together, we step through the header and star data arrays at the same time.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >  DISPLAY_NEXT_FIELD:
    if current_field_index &gt;= field_count goto END
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    print current_field_name
    print &#39;: &#39;
    say current_field_value
    current_field_index &#43;= 1
    goto DISPLAY_NEXT_FIELD</code></pre>
</figure><p>What does the HYG data for Sol look like?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-06-04.pir
StarID: 0
HIP:
HD:
HR:
Gliese:
BayerFlamsteed:
ProperName: Sol
RA: 0
Dec: 0
Distance: 0.000004848
PMRA: 0
PMDec: 0
RV: 0
Mag: -26.73
AbsMag: 4.85
Spectrum: G2V
ColorIndex: 0.656
X: 0
Y: 0
Z: 0
VX: 0
VY: 0
VZ
: 0

$</code></pre>
</figure><p>That&rsquo;s a fair amount of trivia, which makes me happy. Granted, I only understand what five of those fields actually mean - although I can guess at a few more. The data isn&rsquo;t what&rsquo;s jumping out at me, though. This is:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >VZ
: 0

$</code></pre>
</figure><p><code>readline</code> reads the <em>full</em> line from the file, including the special newline characters that mark the end of the line. That newline becomes part of the string, which means it also gets printed out when we display the header and final field for our data. I knew I&rsquo;d have to deal with this eventually.</p>
<p>Perl has the builtin <a href="http://perldoc.perl.org/functions/chomp.html"><code>chomp</code></a> function which is perfect for exactly this situation. Parrot doesn&rsquo;t have <code>chomp</code> as a builtin, but it is available via the standard <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/String/Utils.pir">String/Utils</a> library. There&rsquo;s no need to download anything extra, because &ldquo;String/Utils&rdquo; ships with Parrot.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-06-05

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main

    load_bytecode &#39;String/Utils.pbc&#39;
    .local pmc    chomp

    .const string DELIMITER  = &#39;,&#39;
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local int    field_count
    .local int    current_field_index
    .local string current_field_name
    .local string current_field_value
    .local pmc    star_data

    chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;
    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    current_line  = chomp(current_line)
    field_names   = split DELIMITER, current_line
    field_count   = field_names

    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    close data_file
    current_field_index = 0

  DISPLAY_NEXT_FIELD:
    if current_field_index &gt;= field_count goto END
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    print current_field_name
    print &#39;: &#39;
    say current_field_value
    current_field_index &#43;= 1
    goto DISPLAY_NEXT_FIELD

  END:

.end</code></pre>
</figure><p>Since &ldquo;String/Utils&rdquo; is a library, we need to load it.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >load_bytecode &#39;String/Utils.pbc&#39;</code></pre>
</figure><p>Parrot compiles its library PIR files into Parrot Compiled Byte Code. PBC has been processed enough that the Parrot interpreter can load and execute its code a little faster. The <code>load_bytecode</code> <a href="http://docs.parrot.org/parrot/latest/html/src/ops/core.ops.html">core opcode</a> tells Parrot that we are going to load a bytecode file and we need its capabilities to be added to the system.</p>
<p>The actual <code>chomp</code> functionality is still just beyond our reach, though. We need to make room for it in our own program by reserving a PMC.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.local pmc    chomp</code></pre>
</figure><p>Now we can reach over into the &ldquo;String/Utils&rdquo; namespace and grab <code>chomp</code> for our own use.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;</code></pre>
</figure><p><code>get_global</code> is a <a href="http://docs.parrot.org/parrot/latest/html/src/ops/var.ops.html">variable opcode</a> that allows us to get a PMC from the global namespace. Used like this, it allows us to grab a PMC from a specific available namespace. What makes namespaces great is the fact that they can have any number of variable names without cluttering the globally available list of names. On the other hand, you need to take an extra step to make that name available for your own use. That is fairly consistent with other languages that I&rsquo;ve used, although maybe a little lower level than I care for. Oh well. This is a low-level language, after all.</p>
<p>Now that we&rsquo;ve got that loading business out of the way, we can actually use <code>chomp</code>.  <code>chomp</code> is a subroutine, and not an opcode. You&rsquo;ll need to use parentheses when you use it.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >current_line  = chomp(current_line)</code></pre>
</figure><p><code>chomp</code> returns a copy of <code>current_line</code> with that annoying newline removed. We want to reuse that copy immediately, so we just assign the result right back  to <code>current_line</code>.</p>
<p>Remember to use it again when reading the data line for Sol.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >current_line  = chomp(current_line)</code></pre>
</figure><p>How does the data look now?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-06-05.pir
StarID: 0
HIP:
HD:
HR:
Gliese:
BayerFlamsteed:
ProperName: Sol
RA: 0
Dec: 0
Distance: 0.000004848
PMRA: 0
PMDec: 0
RV: 0
Mag: -26.73
AbsMag: 4.85
Spectrum: G2V
ColorIndex: 0.656
X: 0
Y: 0
Z: 0
VX: 0
VY: 0
VZ: 0</code></pre>
</figure><p>That&rsquo;s better.</p>
<p>Now it would be nice to ask for specific data for our star in a meaningful way. For example, I want to just see the name and spectrum information. We could dig through the fields the way we have been, but I think it would be better if we could just ask for them by name.</p>
<p>One way to do that is with a <a href="http://docs.parrot.org/parrot/latest/html/src/pmc/hash.pmc.html">Hash</a>. This is a collection structure similar to an array. The difference is that you get data from the hash using string keys instead of looking things up by index. Python programmers know it as a &ldquo;dictionary&rdquo;.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-06-06

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main

    load_bytecode &#39;String/Utils.pbc&#39;

    .const string DELIMITER  = &#39;,&#39;
    .local pmc    chomp
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local int    field_count
    .local int    current_field_index
    .local string current_field_name
    .local string current_field_value
    .local pmc    star_data
    .local pmc    star

    chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;
    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    current_line  = chomp(current_line)
    field_names   = split DELIMITER, current_line
    field_count   = field_names

    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    close data_file
    current_field_index = 0
    star = new &#39;Hash&#39;

  ASSIGN_NEXT_FIELD:
    if current_field_index &gt;= field_count goto DISPLAY_STAR_DETAILS
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    star[current_field_name] = current_field_value
    current_field_index &#43;= 1
    goto ASSIGN_NEXT_FIELD

  DISPLAY_STAR_DETAILS:
    $S0 = star[&#39;ProperName&#39;]
    $S1 = star[&#39;Spectrum&#39;]
    $S2 = star[&#39;Distance&#39;]
    print &#34;&lt;Name: &#34;
    print $S0
    print &#34;, Spectrum: &#34;
    print $S1
    print &#34;, Distance: &#34;
    print $S2
    say &#34;&gt;&#34;

  END:

.end</code></pre>
</figure><p>We didn&rsquo;t have to go through so many contortions to add a hash, thank goodness. Hashes are built-in, so we just have to allocate a PMC and call <code>new</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.local pmc star
# ...
star = new &#39;Hash&#39;</code></pre>
</figure><p>Instead of reading and printing the fields, we assign them to the hash.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >ASSIGN_NEXT_FIELD:
  if current_field_index &gt;= field_count goto DISPLAY_STAR_DETAILS
  current_field_name = field_names[current_field_index]
  current_field_value = star_data[current_field_index]
  star[current_field_name] = current_field_value
  current_field_index &#43;= 1
  goto ASSIGN_NEXT_FIELD</code></pre>
</figure><p>On the display side of things, I did get a little lazy and use register variables. There&rsquo;s nothing wrong with that, but it&rsquo;s not consistent with my normal style. We can fix that in the next round.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >DISPLAY_STAR_DETAILS:
  $S0 = star[&#39;ProperName&#39;]
  $S1 = star[&#39;Spectrum&#39;]
  $S2 = star[&#39;Distance&#39;]
  print &#34;&lt;Name: &#34;
  print $S0
  print &#34;, Spectrum: &#34;
  print $S1
  print &#34;, Distance: &#34;
  print $S2
  say &#34;&gt;&#34;</code></pre>
</figure><p>Hash indexes look a lot like array indexes. The keys can get complicated, but let&rsquo;s stick with simple strings.</p>
<p>What does our output look like now?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      > $ parrot example-06-06.pir
 &lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;</code></pre>
</figure><p>I&rsquo;m tempted to print out all the data this way, but there are well over a hundred thousand. Printing takes a while. Reading takes a lot of whiles. How about just printing the information for stars with a matching spectrum?</p>
<h2 id="stars-like-ours">Stars Like Ours</h2>
<p>Now that we have a Hash to describe characteristics of our own Sun, we can build Hashes for other stars and look for the ones that are similar to ours. We&rsquo;ll use the spectrum as our guideline, and look for an exact match rather than just a vague similarity. We&rsquo;re also going to filter out the ones that don&rsquo;t have a name, because we know that many of the stars in this set don&rsquo;t have proper names.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-06-07.pir

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main

    load_bytecode &#39;String/Utils.pbc&#39;

    .const string DELIMITER  = &#39;,&#39;
    .local pmc    chomp
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local int    field_count
    .local int    current_field_index
    .local string current_field_name
    .local string current_field_value
    .local pmc    star_data
    .local pmc    star
    .local string star_name
    .local string star_spectrum
    .local string star_distance
    .local pmc    sol
    .local string sol_spectrum
    .local int    matching_count
    .local int    unnamed_match_count

    chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;
    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    current_line  = chomp(current_line)
    field_names   = split DELIMITER, current_line
    field_count   = field_names

    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    current_field_index = 0
    sol = new &#39;Hash&#39;

  ASSIGN_NEXT_SOL_FIELD:
    if current_field_index &gt;= field_count goto FIND_MATCHING_STARS
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    sol[current_field_name] = current_field_value
    current_field_index &#43;= 1
    goto ASSIGN_NEXT_SOL_FIELD

  FIND_MATCHING_STARS:
    sol_spectrum = sol[&#39;Spectrum&#39;]
    matching_count = 0
    unnamed_match_count = 0
    # We want to show Sol&#39;s details as well as other matches.
    star = sol
    goto DISPLAY_STAR_DETAILS

  LOAD_NEXT_STAR:
    unless data_file goto END
    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    current_field_index = 0
    star = new &#39;Hash&#39;

  ASSIGN_NEXT_STAR_FIELD:
    if current_field_index &gt;= field_count goto EXAMINE_STAR
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    star[current_field_name] = current_field_value
    current_field_index &#43;= 1
    goto ASSIGN_NEXT_STAR_FIELD

  EXAMINE_STAR:
    star_spectrum = star[&#39;Spectrum&#39;]
    if star_spectrum == sol_spectrum goto REMEMBER_MATCH
    goto LOAD_NEXT_STAR

  REMEMBER_MATCH:
    matching_count &#43;= 1
    star_name = star[&#39;ProperName&#39;]
    if star_name goto DISPLAY_STAR_DETAILS
    unnamed_match_count &#43;= 1
    goto LOAD_NEXT_STAR

  DISPLAY_STAR_DETAILS:
    star_name = star[&#39;ProperName&#39;]
    star_spectrum = star[&#39;Spectrum&#39;]
    star_distance = star[&#39;Distance&#39;]
    print &#34;&lt;Name: &#34;
    print star_name
    print &#34;, Spectrum: &#34;
    print star_spectrum
    print &#34;, Distance: &#34;
    print star_distance
    say &#34;&gt;&#34;
    goto LOAD_NEXT_STAR

  END:
    close data_file
    print matching_count
    print &#34; stars exactly matched Sol&#39;s spectrum &#34;
    say sol_spectrum
    print unnamed_match_count
    say &#39; have no proper name&#39;

.end</code></pre>
</figure><p>We look at each star as we go, checking to see if it exactly matches Sol&rsquo;s. I know that we&rsquo;re missing a couple of entries designated as &ldquo;G1/G2V&rdquo;, but I am not going to worry about it today.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >  EXAMINE_STAR:
    star_spectrum = star[&#39;Spectrum&#39;]
    if star_spectrum == sol_spectrum goto REMEMBER_MATCH
    goto LOAD_NEXT_STAR</code></pre>
</figure><p>We&rsquo;re remembering stars with the same spectrum, but will only be displaying those with proper names. We&rsquo;ll just count the others.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >  REMEMBER_MATCH:
    matching_count &#43;= 1
    star_name = star[&#39;ProperName&#39;]
    if star_name goto DISPLAY_STAR_DETAILS
    unnamed_match_count &#43;= 1
    goto LOAD_NEXT_STAR</code></pre>
</figure><p>You may have noticed that I reassign some variables with the same value they probably already had. This may not be efficient, but it&rsquo;s for my own sanity. I want to be certain about the values held in those variables. I am also pretending these little labelled regions are like distinct blocks of code. It&rsquo;s a lie, but a useful one.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >DISPLAY_STAR_DETAILS:
  star_name = star[&#39;ProperName&#39;]
  star_spectrum = star[&#39;Spectrum&#39;]
  star_distance = star[&#39;Distance&#39;]
  print &#34;&lt;Name: &#34;
  print star_name
  print &#34;, Spectrum: &#34;
  print star_spectrum
  print &#34;, Distance: &#34;
  print star_distance
  say &#34;&gt;&#34;
  goto LOAD_NEXT_STAR</code></pre>
</figure><p>On the other hand, this program does take a couple of seconds to run on my machine now.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      > $ parrot example-06-07.pir
 &lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;
 &lt;Name: Rigel Kentaurus A, Spectrum: G2V, Distance: 1.34749097181049&gt;
 568 stars exactly matched Sol&#39;s spectrum G2V
 567 have no proper name</code></pre>
</figure><p>Those are disappointing results. It looks like we have many neighbors that look like our Sun, but only one with a name. I would love to use one of the alternate references if available, such as the <a href="http://www.ari.uni-heidelberg.de/datenbanken/aricns/gliese.htm">Gliese</a> or <a href="http://www.skyviewcafe.com/bayer_flamsteed.html">Bayer-Flamsteed</a> designations. I don&rsquo;t think that&rsquo;s practical with how we&rsquo;re writing our Parrot application today.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Wow. There has been a lot of new stuff today. Not only did we learn how to read files and use Hashes, we also saw how to load bytecode libraries. We counted, searched through, and displayed data from a 20 Megabyte text file with nearly 120,000 entries. We also learned that <a href="http://en.wikipedia.org/wiki/Alpha_Centauri">Rigel Kentaurus A</a> is the only named neighbor in the database that is the same spectral type as our Sun.</p>
<p>I think we&rsquo;re reaching the limits of what I want to do with <code>goto</code> as my primary  tool for guiding program flow. PIR Code is getting harder to write and edit. The next step really should be creating subroutines to abstract some of the more complicated or tedious processes.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 05 - More About Arrays</title>
  <link>https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/</link>
  <pubDate>Tue, 29 Sep 2009 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/</guid>
  <description>Introduction We started looking at arrays in the last step. We’re going to take a closer look today, exploring different ways of looking at Parrot arrays to build an averaging calculator. We’ll start with no array at all, to build the basic flow of our program and to demonstrate that an array is not always needed. Then we’ll move on to more interesting stuff, with array indexing, stack opcodes, and iterators.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>We started looking at arrays in the <a href="/post/2009/09/parrot-babysteps-04-adding-command-line-arguments/">last step</a>. We&rsquo;re going to take a closer look today, exploring different ways of looking at <a href="/card/parrot/">Parrot</a> arrays to build an averaging calculator. We&rsquo;ll start with no array at all, to build the basic flow of our program and to demonstrate that an array is not always needed. Then we&rsquo;ll move on to more interesting stuff, with array indexing, stack opcodes, and iterators.</p>
<h2 id="building-the-basic-flow">Building the Basic Flow</h2>
<p>Our averaging program is going to get its input from the user, and will take an
arbitrary quantity of Numbers. Basically, it will keep accepting Numbers until the
user indicates that she&rsquo;s done. It will then display the average of all Numbers
and exit.</p>
<p>Sounds simple enough. How will the user tell the program that she&rsquo;s done? I like
the idea of using the string &ldquo;done&rdquo;. It&rsquo;s easy to remember and to the point.
Wait. Let me think about that for a moment. The phrase &ldquo;done&rdquo; may be easy
to remember, but &ldquo;quit&rdquo; is more common for leaving an interactive shell. I guess
we should use &ldquo;quit&rdquo;.</p>
<p>Okay, let&rsquo;s make the basic shell.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-05-01.pir
.sub &#39;main&#39; :main
	.const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
	.const string EXIT_STRING = &#39;quit&#39;
	.local string user_input
	.local num    latest_number
	.local pmc    stdin

	stdin = getstdin

  GET_INPUT:
	user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
	if user_input == EXIT_STRING goto SHOW_AVERAGE
	latest_number = user_input
	say latest_number
	goto GET_INPUT

  SHOW_AVERAGE:
	say &#34;Average goes here&#34;
	goto EXIT

  EXIT:

.end</code></pre>
</figure><p>There&rsquo;s a little debugging output that won&rsquo;t be necessary once the program is
filled out a little more, but we&rsquo;ve got the basics.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-05-01.pir
Enter a number (or &#34;quit&#34; to quit): 23
23
Enter a number (or &#34;quit&#34; to quit): 12
12
Enter a number (or &#34;quit&#34; to quit): q
0
Enter a number (or &#34;quit&#34; to quit): quit
Average goes here
$</code></pre>
</figure><p>Notice that the string is converted to a number using normal Perl rules: if it
doesn&rsquo;t have any numbers, it&rsquo;s treated as zero. We could put in some error
checking to chastise the user for bad input, but I don&rsquo;t feel like it right now.</p>
<h2 id="averaging-with-no-arrays">Averaging With No Arrays</h2>
<p>I would like to point something out before we start digging into array features.
We don&rsquo;t <em>need</em> to use arrays when calculating something like an average. Here&rsquo;s
a perfectly useful example that never uses a single array:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-05-02.pir
.sub &#39;main&#39; :main
	.const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
	.const string EXIT_STRING = &#39;quit&#39;
	.local string user_input
	.local num    latest_number
	.local num    total
	.local int    numbers_entered
	.local num    average
	.local pmc    stdin

	stdin = getstdin
	total = 0
	numbers_entered = 0

  GET_INPUT:
	user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
	if user_input == EXIT_STRING goto SHOW_AVERAGE
	latest_number = user_input
	numbers_entered &#43;= 1
	total &#43;= latest_number
	goto GET_INPUT

  SHOW_AVERAGE:
	average = total / numbers_entered
	say average
	goto EXIT

  EXIT:

.end</code></pre>
</figure><p>Here&rsquo;s what it looks like in action.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-05-02.pir
Enter a number (or &#34;quit&#34; to quit): 5
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): 15
Enter a number (or &#34;quit&#34; to quit): 20
Enter a number (or &#34;quit&#34; to quit): quit
12.5</code></pre>
</figure><p>Why did I show this? Well, basically because &ldquo;write an averaging program
without using an Array in the language of your choice&rdquo; is an interview
question I&rsquo;ve been asked a couple of times. It&rsquo;s been a while, but I
thought I&rsquo;d be ready in case somebody asked me again. They&rsquo;ll probably
expect me to use Java or Ruby or something. This will show them. This
will show them all! This will show them - uhh -</p>
<p>I&rsquo;m not sure what it&rsquo;ll show them.</p>
<p>Anyways - I wrote this version because I felt like it. Let&rsquo;s start writing
code that uses arrays, okay?</p>
<h2 id="stacks---pushing-and-popping">Stacks - Pushing and Popping</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Stack_%28data_structure%29">stack</a> is one of
the fundamental data structures. The mental image is straightforward: you have
a stack of things. You can <em>push</em> a new thing onto the stack, or you can <em>pop</em>
the top thing from the stack into your hand. Stacks provide a simple way to
handle every item in a collection. One thing you need to keep in mind is
consistent with that stack image: once you&rsquo;ve popped an item from the stack,
it&rsquo;s not in the collection anymore. So popping all the way through a stack
results in what? Yes, that&rsquo;s right. It results in an empty stack.</p>
<p>Still, the stack structure is good enough for a lot of collection handling,
and will definitely work for our averaging application.</p>
<p>I&rsquo;ll show you the code first, then we can talk about it.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-05-03
.sub &#39;main&#39; :main
	.const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
	.const string EXIT_STRING = &#39;quit&#39;
	.local string user_input
	.local num    latest_number
	.local num    total
	.local int    number_count
	.local pmc    numbers
	.local num    average
	.local pmc    stdin

	stdin = getstdin
	numbers = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
	user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
	if user_input == EXIT_STRING goto SETUP_CALCULATE_SUM
	latest_number = user_input
	push numbers, latest_number
	goto GET_INPUT

  SETUP_CALCULATE_SUM:
	total = 0
	number_count = 0

  CALCULATE_SUM:
	latest_number = pop numbers
	total &#43;= latest_number
	number_count &#43;= 1
	if numbers goto CALCULATE_SUM

	average = total / number_count
	say average

.end</code></pre>
</figure><p>We use the <a href="http://docs.parrot.org/parrot/devel/html/src/pmc/resizablefloatarray.pmc.html">ResizableFloatArray</a> PMC to hold our user&rsquo;s numeric input. That is a built-in PMC, so we don&rsquo;t need to do any special includes to access it. Just create a new one with the <code>new</code> opcode.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.local pmc    numbers
# ...
numbers = new &#39;ResizableFloatArray&#39;</code></pre>
</figure><p>After creating <code>numbers</code>, we can push new values onto the array with the <code>push</code>
opcode. We use this to collect user input.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >push numbers, latest_number</code></pre>
</figure><p>Later on, when we&rsquo;re calculating the average, we use <code>pop</code> to grab the most
recently pushed value from the stack. We keep doing that until we&rsquo;re out of
numbers, as judged by a simple <code>if</code> test.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >  CALCULATE_SUM:
	latest_number = pop numbers
	total &#43;= latest_number
	number_count &#43;= 1
	if numbers goto CALCULATE_SUM</code></pre>
</figure><p>If <code>numbers</code> is empty and that test looks false to Parrot, the program falls
through to the next statement. That next statement is where we actually
calculate the average.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-05-03.pir
Enter a number (or &#34;quit&#34; to quit): 1e&#43;5
Enter a number (or &#34;quit&#34; to quit): 1e&#43;3
Enter a number (or &#34;quit&#34; to quit): 1e&#43;1
Enter a number (or &#34;quit&#34; to quit): quit
33670</code></pre>
</figure><p>Yes, I was being more clever than I needed to with this example session, but I wanted to remind you that Parrot accepts <a href="http://en.wikipedia.org/wiki/Scientific_notation#E_notation">E notation</a> for numbers. Here&rsquo;s the same session with the numbers looking more like you might have expected.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-05-03.pir
Enter a number (or &#34;quit&#34; to quit): 100000
Enter a number (or &#34;quit&#34; to quit): 1000
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): quit
33670</code></pre>
</figure><h3 id="shift-and-unshift---the-bottom-of-the-stack"><code>shift</code> and <code>unshift</code> - The Bottom of the Stack</h3>
<p>While <code>push</code> and <code>pop</code> work on the end of an array, Parrot also provides <code>unshift</code>
and <code>shift</code> which handle corresponding functionality on the front of an array.
Let&rsquo;s go back to the stack image for a moment. We already have the basic idea
of pushing onto and popping off of the top of a stack. We can also <em>shift</em> an
item from the bottom of that stack. What used to be the first item is now in our
hands, and the rested of the stack has <em>shifted</em> down so that the old second
item is the new first item. We can <em>unshift</em> an item into the bottom of the
stack. Now that unshifted item is the new first in the collection, and the old
first item is now the second.</p>
<p>I really need to get some illustrations in here. The idea is very easy to show,
but my language skills aren&rsquo;t adequate for the task.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-05-04
.sub &#39;main&#39; :main
    .const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
    .const string EXIT_STRING = &#39;quit&#39;
    .local string user_input
    .local num    latest_number
    .local num    total
    .local int    number_count
    .local pmc    numbers
    .local num    average
    .local pmc    stdin

    stdin = getstdin
    numbers = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
    user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if user_input == EXIT_STRING goto SETUP_CALCULATE_SUM
    latest_number = user_input
    unshift numbers, latest_number
    goto GET_INPUT

  SETUP_CALCULATE_SUM:
    total = 0
    number_count = 0

  CALCULATE_SUM:
    latest_number = shift numbers
    total &#43;= latest_number
    number_count &#43;= 1
    if numbers goto CALCULATE_SUM

    average = total / number_count
    say average

.end</code></pre>
</figure><p>Which is better? I&rsquo;ll be honest with you. I don&rsquo;t really know. I stick to pushing
and popping because it&rsquo;s easier to visualize.</p>
<p>However, when you combine <code>push</code> and <code>shift</code> you get a whole new structure called
a queue.</p>
<h2 id="queues">Queues</h2>
<p>A <a href="http://en.wikipedia.org/wiki/Queue_%28data_structure%29">queue</a> is yet another way of looking at your array when you are concerned about order. Stacks are LIFO: when you pop an item from the stack, you&rsquo;re getting the last item that was pushed. Queues are FIFO: when you shift an item from the queue, you get the first item that was pushed. Okay - the technical term for placing an item in the queue is <em>enqueue</em> and for grabbing an item is <em>dequeue</em>. Pushing and shifting refer to the opcodes we&rsquo;re using. Use whatever term you&rsquo;re happier with.</p>
<p>The actual code for using a queue instead of a stack still doesn&rsquo;t look all that
different, because they&rsquo;re still producing the same final result.
Let&rsquo;s write an example that clearly demonstrates the difference
between a queue and a stack:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-05-05
.sub &#39;main&#39; :main
    .const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
    .const string EXIT_STRING = &#39;quit&#39;
    .local pmc    stdin
    .local string user_input
    .local num    latest_number
    .local pmc    stack
    .local int    stack_count
    .local num    stack_popped
    .local num    stack_sum
    .local num    stack_average
    .local pmc    queue
    .local int    queue_count
    .local num    queue_dequeued
    .local num    queue_sum
    .local num    queue_average

    stdin = getstdin
    stack = new &#39;ResizableFloatArray&#39;
    queue = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
    user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if user_input == EXIT_STRING goto SETUP_SUM_CALCULATIONS
    latest_number = user_input
    push stack, latest_number  # Push onto the stack
    push queue, latest_number  # Enqueue onto the queue
    goto GET_INPUT

  SETUP_SUM_CALCULATIONS:
    stack_count = 0
    stack_sum   = 0
    queue_count = 0
    queue_sum   = 0

  CALCULATE_STACK_SUM:
    stack_popped = pop stack
    print &#34;Popped: &#34;
    say stack_popped
    stack_sum &#43;= stack_popped
    stack_count &#43;= 1
    if stack goto CALCULATE_STACK_SUM

  CALCULATE_QUEUE_SUM:
    queue_dequeued = shift queue
    print &#34;Dequeued: &#34;
    say queue_dequeued
    queue_sum &#43;= queue_dequeued
    queue_count &#43;= 1
    if queue goto CALCULATE_QUEUE_SUM

    stack_average = stack_sum / stack_count
    queue_average = queue_sum / queue_count
    print &#34;Stack average: &#34;
    say stack_average
    print &#34;Queue average: &#34;
    say queue_average

.end</code></pre>
</figure><p>Now we can see exactly what numbers are being grabbed as our program calculates
the sums.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-05-05.pir
Enter a number (or &#34;quit&#34; to quit): 5
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): 15
Enter a number (or &#34;quit&#34; to quit): 20
Enter a number (or &#34;quit&#34; to quit): quit
Popped: 20
Popped: 15
Popped: 10
Popped: 5
Dequeued: 5
Dequeued: 10
Dequeued: 15
Dequeued: 20
Stack average: 12.5
Queue average: 12.5</code></pre>
</figure><p>That output could fill up the screen if I had a lot of values. I might want to
fine-tune the debug output. Then again, I might want to just move on to the next
subject.</p>
<h2 id="accessing-by-index">Accessing by Index</h2>
<p>Stacks and queues are a practical solution to a wide range of collection-handling
problems. They do have one shortcoming, though. Both of them are destructive.
When you <code>pop</code> or <code>shift</code> a value from an array, you are actually removing that value.
There is nothing left after you haved popped or shifted the last value. Sometimes
that is okay, but sometimes you want to use the array for some other calculation.
Those are the situations where you want a way to access the contents of the array
without changing them. One way to do that is by accessing contents via an index.</p>
<p>The Parrot <a href="http://docs.parrot.org/parrot/devel/html/docs/pmc/array.pod.html">Array documentation</a> shows a few things about setting up fixed-size arrays and setting individual values within arrays, but what I care about is the fact that array elements are accessed pretty much the same as in other languages I&rsquo;m familiar with. We use square brackets <code>[]</code> to access a specific element, and the count is zero-based. Yes, zero-based indexing can be a little confusing sometimes. Think of it as &ldquo;how many items from the front is the element I want?&rdquo; and you should be fine.</p>
<p>We&rsquo;ll build up our array in the same way that we have been, because I want the user
to have some flexibility in deciding how many numbers to average. After that we&rsquo;ll
step through the array by incrementing an index.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-05-06
.sub &#39;main&#39; :main
    .const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
    .const string EXIT_STRING = &#39;quit&#39;
    .local string user_input
    .local num    latest_number
    .local num    total
    .local int    number_count
    .local int    number_index
    .local pmc    numbers
    .local num    average
    .local pmc    stdin

    stdin = getstdin
    numbers = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
    user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if user_input == EXIT_STRING goto SETUP_CALCULATE_SUM
    latest_number = user_input
    push numbers, latest_number
    goto GET_INPUT

  SETUP_CALCULATE_SUM:
    total = 0
    number_count = numbers
    number_index = 0

  CALCULATE_SUM:
    if number_index &gt;= number_count goto CALCULATE_AVERAGE
    latest_number = numbers[number_index]
    total &#43;= latest_number
    number_index &#43;= 1
    goto CALCULATE_SUM

  CALCULATE_AVERAGE:
    average = total / number_count
    
  DISPLAY_VALUES:
    print &#34;Values entered: &#34;
    say number_count
    print &#34;Sum of values:  &#34;
    say total
    print &#34;Average:        &#34;
    say average
.end</code></pre>
</figure><p>A little more information is displayed in this version.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-05-06.pir
Enter a number (or &#34;quit&#34; to quit): 5
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): 15
Enter a number (or &#34;quit&#34; to quit): 20
Enter a number (or &#34;quit&#34; to quit): quit
Values entered: 4
Sum of values:  50
Average:        12.5</code></pre>
</figure><p>Notice that we check to see if we&rsquo;ve stepped outside of bounds right away. We
could test at the end of that section, but the truth is that I don&rsquo;t trust my
own code. The sooner I can see if I need to move on, the happier I&rsquo;ll be. I
could even test if we&rsquo;ve somehow gone below zero if I was feeling especially
paranoid. I won&rsquo;t do that today, though. You&rsquo;re welcome.</p>
<h2 id="using-an-iterator">Using an Iterator</h2>
<p>We&rsquo;re nearly done. There is only one more way of traversing arrays that I want to look at. Parrot <a href="http://docs.parrot.org/parrot/devel/html/src/pmc/iterator.pmc.html">Iterators</a> allow you to step through the contents of an array without doing anything to the array itself, while ignoring the details of array indexing.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-05-07
.sub &#39;main&#39; :main
    .const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
    .const string EXIT_STRING = &#39;quit&#39;
    .local string user_input
    .local num    latest_number
    .local num    total
    .local int    number_count
    .local pmc    numbers
    .local pmc    numbers_iterator
    .local num    average
    .local pmc    stdin

    stdin = getstdin
    numbers = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
    user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if user_input == EXIT_STRING goto SETUP_CALCULATE_SUM
    latest_number = user_input
    push numbers, latest_number
    goto GET_INPUT

  SETUP_CALCULATE_SUM:
    total = 0
    numbers_iterator = iter numbers

  CALCULATE_SUM:
    unless numbers_iterator goto CALCULATE_AVERAGE
    latest_number = shift numbers_iterator
    total &#43;= latest_number
    goto CALCULATE_SUM

  CALCULATE_AVERAGE:
    number_count = numbers
    average = total / number_count

  DISPLAY_VALUES:
    print &#34;Values entered: &#34;
    say number_count
    print &#34;Sum of values:  &#34;
    say total
    print &#34;Average:        &#34;
    say average

.end</code></pre>
</figure><p>All right. This example is easier for me to read than the others for some reason.
That could be due to the simple fact that I&rsquo;ve been looking at Parrot arrays for
a couple of hours now. Maybe it&rsquo;s because my blocks are more clearly labelled.
Maybe it&rsquo;s because using an iterator allowed me to build up a sum and still get
the length the length of <code>numbers</code> later, rather than building up two values
at the same time. I&rsquo;m not really sure. I do know that I feel like the iterator
has given me a nice little convenience layer for handling my array. The output
is still the same.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-05-07.pir
Enter a number (or &#34;quit&#34; to quit): 5
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): 15
Enter a number (or &#34;quit&#34; to quit): 20
Enter a number (or &#34;quit&#34; to quit): quit
Values entered: 4
Sum of values:  50
Average:        12.5</code></pre>
</figure><h2 id="conclusion">Conclusion</h2>
<p>We had already taken a glance at arrays when we worked with the command line. Today we dove a little deeper, looking into different ways we can access the contents of an array. Now you understand how to treat a &lsquo;ResizableFloatArray&rsquo; like a stack, a queue, a plain old array, or an iterable collection. These principles should work for other array types as well. Parrot has many array PMCs, and you can find them on the list of core PMCs <a href="http://docs.parrot.org/parrot/devel/html/pmc.html">here</a>.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Perl Hacks In My Workspace</title>
  <link>https://randomgeekery.org/post/2009/09/perl-hacks-in-my-workspace/</link>
  <pubDate>Mon, 21 Sep 2009 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/09/perl-hacks-in-my-workspace/</guid>
  <description>&lt;p&gt;Looking at some specific hacks from the O’Reilly &lt;a href=&#34;http://oreilly.com/catalog/9780596526740/&#34;&gt;Perl Hacks&lt;/a&gt; book for my own &lt;a href=&#34;https://randomgeekery.org/card/perl/&#34;&gt;Perl&lt;/a&gt; workflow. It should be obvious from the tone and content that this is not intended to replace any of the  original material or take credit for anything in the book.&lt;/p&gt;</description>
   <category>post</category> 
   <category>post</category> 
   <category>perl</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>Looking at some specific hacks from the O&rsquo;Reilly <a href="http://oreilly.com/catalog/9780596526740/">Perl Hacks</a> book for my own <a href="/card/perl/">Perl</a> workflow. It should be obvious from the tone and content that this is not intended to replace any of the  original material or take credit for anything in the book.</p>
<p>Perl Hacks is a great book. I catch something new every time I open it. That&rsquo;s
at least partly because I still haven&rsquo;t read it from cover to cover. The &ldquo;Hacks&rdquo;
series of books is written in such a way that cover-to-cover reading is not
needed, thankfully.</p>
<p>The browser hacks from the beginning are an especially convenient way
to add some Perl-friendly functionality to [Firefox][].
One minor issue is that I spend a lot of my time in <a href="http://elinks.cz/">ELinks</a>,
a text-based Web browser. Why? Well, most of my work is done over an ssh
connection, so I&rsquo;m already using <a href="/post/2007/01/gnu-screen/">gnu-screen</a> and <a href="/card/vim/">Vim</a>. Keeping my Web
browser within my <code>screen</code> session reduces context switching. <code>screen</code> also
keeps my sessions alive, so everything including my ELinks browser session is
intact when I come back to my workspace the next morning.</p>
<p>Naturally, I had to examine Hack #1 in the context of ELinks.</p>
<h2 id="hack-1-add-cpan-shortcuts-to-elinks">Hack #1: Add CPAN Shortcuts to ELinks</h2>
<p>There are a couple of preliminary steps to get out of the way before adding
CPAN shortcuts to ELinks. First, install ELinks. Second, make sure smart
prefixes are enabled.</p>
<h3 id="installing-elinks">Installing ELinks</h3>
<p>The first requirement for this hack is ELinks. The <a href="http://elinks.cz/download.html">ELinks download page</a> shows all sorts of nifty ways to install it. I went the easy way and just used my system package managers.</p>
<p>That&rsquo;s <code>apt-get</code> on <a href="http://www.ubuntu.com">Ubuntu</a> Linux:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sudo apt-get install elinks</code></pre>
</figure><p>Or <a href="http://www.macports.org/">MacPorts</a> on OS X:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sudo port install elinks</code></pre>
</figure><p>Windows folks are left to their own devices, since most of my Windows <code>elinks</code>  usage is on other systems via <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/">Putty</a>. I do know that ELinks is available in <a href="/post/2004/07/cygwin/">cygwin</a>.</p>
<h3 id="enable-smart-prefixes">Enable Smart Prefixes</h3>
<p>The easiest way to test if smart prefixes are enabled is by trying to use
one that&rsquo;s already been defined. Try opening the following URL in ELinks:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >g Modern::Perl</code></pre>
</figure><p>The resulting page should look something like <a href="http://www.google.com/search?q=Modern%3a%3aPerl&amp;btnG=Google&#43;Search">this</a>.
Follow these steps if that is not the case:</p>
<ul>
<li>Enter <code>o</code> to open the Options Manager</li>
<li>Open Protocols / URI Rewriting / Enable Smart Prefixes
** Use the space bar to expand the tree as you go.</li>
<li>Select <code>[Edit]</code></li>
<li>Make sure the text field is set to <code>1</code>.</li>
<li>Select <code>[OK]</code></li>
<li>Select <code>[Save]</code></li>
</ul>
<p>Now go back and try to open <code>g Modern::Perl</code> again. That did the trick for me.</p>
<p>On to the CPAN shortcuts.</p>
<h3 id="adding-a-smart-prefix">Adding a Smart Prefix</h3>
<ul>
<li>Enter <code>o</code> to open the Options Manager</li>
<li>Open Protocols / URI Rewriting / Smart Prefixes
<ul>
<li>Use the space bar to expand the tree as you go.</li>
</ul>
</li>
<li>Select <code>[Add]</code></li>
<li>Enter the name of the smart prefix, then select <code>[OK]</code></li>
<li>Select <code>[Edit]</code></li>
<li>Enter the URL for the smart prefix, then select <code>[OK]</code></li>
<li>Select <code>[Save]</code></li>
</ul>
<h3 id="the-smart-prefixes">The Smart Prefixes</h3>
<table>
<thead>
<tr>
<th>Description</th>
<th>Prefix</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>Search CPAN</td>
<td>cpan</td>
<td><code>http://search.cpan.org/search?mode=module;query=%s</code></td>
</tr>
<tr>
<td>Show Module Documentation</td>
<td>cpod</td>
<td><code>http://search.cpan.org/perldoc/%s</code></td>
</tr>
<tr>
<td>AnnoCPAN Module Documentation</td>
<td>apod</td>
<td><code>http://www.annocpan.org/?mode=search;field=Module;latest=1;name=%s</code></td>
</tr>
</tbody>
</table>
<h3 id="try-them-out">Try Them Out!</h3>
<p>Try the following URLs to get you started.</p>
<ul>
<li><code>cpan Modern::Perl</code></li>
<li><code>cpod Acme::Python</code></li>
<li><code>apod Moose</code></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="http://oreilly.com/catalog/9780596526740/">Perl Hacks</a> by chromatic with
Damian Conway and Curtis &lsquo;Ovid&rsquo; Poe. Copyright 2006 O&rsquo;Reilly Media, Inc., 0-596-52674-1</li>
</ul>]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 04 - Adding Command Line Arguments</title>
  <link>https://randomgeekery.org/post/2009/09/parrot-babysteps-04-adding-command-line-arguments/</link>
  <pubDate>Thu, 17 Sep 2009 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/09/parrot-babysteps-04-adding-command-line-arguments/</guid>
  <description>Introduction We have learned a reasonable amount so far. We know how to write fairly trivial applications using Parrot Intermediate Representation. We could probably write a simple formula calculator that gets input from the user, ensures that the content is valid, and presents the results of applying user input to the formula.
It would be nice to write more ambitious programs, though. It would be painful - maybe even impossible - to create a modern program using only the tools and opcodes we have learned so far.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>We have learned a reasonable amount so far. We know how to write fairly trivial applications using <a href="/card/parrot/">Parrot</a> Intermediate Representation. We could probably write a simple formula calculator that gets input from the user, ensures that the content is valid, and presents the results of applying user input to the formula.</p>
<p>It would be nice to write more ambitious programs, though. It would be painful - maybe even impossible - to create a modern program using only the tools and opcodes we have learned so far.</p>
<p>We can start examining PMCs by writing a version of our hypotenuse calculator from <a href="/post/2009/07/parrot-babysteps-02-variables-and-types/">a few steps ago</a> that has command line arguments.</p>
<h2 id="command-line-arguments">Command Line Arguments</h2>
<p>How do we tell Parrot that our program accepts command line arguments, though? We need some way to show that our <code>:main</code> sub is ready to take parameters. Turns out that&rsquo;s actually pretty easy.</p>
<h3 id="param-directive"><code>.param</code> directive</h3>
<p>The <code>.param</code> directive is used at the start of a subroutine to indicate that the subroutine will accept a parameter and place it in the named variable.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-04-01.pir

.sub &#39;main&#39; :main
    .param pmc argv
.end</code></pre>
</figure><p><code>argv</code> is a <a href="http://docs.parrot.org/parrot/latest/html/src/pmc/resizablestringarray.pmc.html">ResizableStringArray</a>: an ordered collection of strings.</p>
<p>We can use the <code>elements</code> opcode to find out how many arguments were passed to the file.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-04-02.pir

.sub &#39;main&#39; :main
    .param pmc argv
    .local int argument_count
    .local string description

    argument_count = elements argv
    description = &#34;I was called with &#34;
    $S0 = argument_count
    description .= $S0
    description .= &#34; arguments&#34;

    say description
.end</code></pre>
</figure><p>Try it out.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-04-02.pir hey there
I was called with 3 arguments</code></pre>
</figure><p>Three? Let&rsquo;s look at the arguments individually and see if we can figure this out.</p>
<h3 id="shift"><code>shift</code></h3>
<p>The <code>shift</code> opcode lets us pull the first item from an array. This shrinks the <code>argv</code> array by one as it shifts the rest of its contents over to fill the empty space, but it&rsquo;s not a concern for us right now.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-04-03.pir

.sub &#39;main&#39; :main
    .param pmc argv
    .local int argument_count
    .local string this_argument
    .local string description

  GET_ARG:
    argument_count = argv
    if argument_count &lt;= 0 goto END
    this_argument = shift argv
    description = &#34;This argument: &#34; . this_argument
    say description
    goto GET_ARG

  END:

.end</code></pre>
</figure><p>We can use this code to look at our program arguments one at a time.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >bash-3.2$ parrot example-04-03.pir hey there
This argument: example-04-03.pir
This argument: hey
This argument: there</code></pre>
</figure><p>Oh, right. The program name is the first argument. That is not unusual, especially in some lower level languages. I should have remembered.</p>
<h3 id="calculating-a-hypotenuse">Calculating a Hypotenuse</h3>
<p>Let&rsquo;s take what we&rsquo;ve learned about handling the command line and apply it to our hypotenuse calculator.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-04-04.pir

.sub &#39;main&#39; :main
    .param pmc argv
    .local int argument_count
    .local string program_name
    .local num a
    .local num b
    .local num c
    .local num a_squared
    .local num b_squared
    .local num c_squared
    .local string error_message

    program_name = shift argv
    argument_count = elements argv
    if argument_count != 2 goto BAD_ARG_COUNT
    a = shift argv
    b = shift argv
    a_squared = a * a
    b_squared = b * b
    say a_squared
    say b_squared
    c_squared = a_squared &#43; b_squared
    c = sqrt c_squared
    say c
    goto END

  BAD_ARG_COUNT:
    error_message = &#34;Exactly two arguments required&#34;
    say error_message
    goto END

  END:
.end</code></pre>
</figure><p>First we shift the first item off of <code>argv</code> because we know for sure that it&rsquo;s going to be the program name. Then we check to make sure that the user has provided us with two arguments that we can use for <code>a</code> and <code>b</code>. Not having two arguments is an error, so the program branches to displaying an error and quitting. When the argument count is right, the program shifts the arguments into <code>a</code> and <code>b</code> then uses them to calculate and display the hypotenuse.</p>
<p>Oh yeah - sooner or later you&rsquo;re going to see this error message from Parrot:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >error:imcc:syntax error, unexpected &#39;=&#39;, expecting &#39;(&#39; (&#39;=&#39;)
        in file &#39;example-04-04.pir&#39; line 24</code></pre>
</figure><p>What did line 24 look like?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >c_squared = a_squared &#43; b_squared</code></pre>
</figure><p>It took me a while to realize that I had never declared <code>.local num c_squared</code>. Unfortunately, Parrot&rsquo;s error messages aren&rsquo;t quite as descriptive as Perl&rsquo;s. Perl has had a lot more time to figure out how to gently explain a user&rsquo;s error to him, though.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >bash-3.2$ parrot example-04-04.pir 12 23
144
529
25.9422435421457
bash-3.2$</code></pre>
</figure><p>That worked.</p>
<p>Parrot has many special opcodes <a href="http://docs.parrot.org/parrot/latest/html/src/ops/pmc.ops.html">for dealing with PMCs</a> and soon we&rsquo;ll be looking at more of them. I am especially interested in the opcodes that allow us to use arrays and other collection types.</p>
<h2 id="summary">Summary</h2>
<p>Yes, this has been a <em>very</em> quick step. Maybe we didn&rsquo;t learn a whole lot,  but there&rsquo;s a little bit of new stuff in there. We did learn how to add command line handling by using <code>.param</code> to tell Parrot that our <code>:main</code> method accepts parameters. We learned that for <code>:main</code>, the parameter is a particular PMC - something called a ResizableStringArray. The <code>shift</code> opcode removes the first item in a ResizableStringArray and lets us use it in a variable. We also saw that we can use the <code>members</code> opcode to get the number of members in an array.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 03 - Simple Control Structures</title>
  <link>https://randomgeekery.org/post/2009/09/parrot-babysteps-03-simple-control-structures/</link>
  <pubDate>Fri, 11 Sep 2009 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/09/parrot-babysteps-03-simple-control-structures/</guid>
  <description>I won’t spend a whole lot of time on what control structures are and more time on how to implement them in Parrot.
This material follows pretty much the same steps as the Parrot book chapter on control structures. You could follow that chapter and end up with the same knowledge that you would get from reading today’s step. Maybe even a little more.
Sequence As usual for many programming languages, the the sequence control structure is implemented in Parrot as a pattern of one instruction following another.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>I won&rsquo;t spend a whole lot of time on what control structures <em>are</em> and more time on how to implement them in <a href="/card/parrot/">Parrot</a>.</p>
<p>This material follows pretty much the same steps as the Parrot book chapter on <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch05_control_structures.pod.html">control structures</a>. You could follow that chapter and end up with the same knowledge that you would get from reading today&rsquo;s step. Maybe even a little more.</p>
<h2 id="sequence">Sequence</h2>
<p>As usual for many programming languages, the the sequence control structure is
implemented in Parrot as a pattern of one instruction following another.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-01.pir
.sub main :main
    .const string PROMPT = &#34;What is your name? &#34;
    .local string name
    .local string response
    .local pmc    stdin

    stdin = getstdin
    name = stdin.&#39;readline_interactive&#39;(PROMPT)
    response = &#34;Hello, &#34; . name
    say response
.end</code></pre>
</figure><h2 id="selection">Selection</h2>
<p>Parrot uses simple mechanisms for building selection and repetition structures. Why is this?
This is because Parrot and PIR are built for designing new programming languages. The
designers opted to have the core control structures be simplistic so you wouldn&rsquo;t be stuck
with what Parrot thinks a repetition loop - as one example - should look like. This does
mean that moderately experienced developers such as myself must release some of our prejudices
about what is &ldquo;good&rdquo; or &ldquo;bad&rdquo; in code. Very experienced developers and complete newcomers
should have an easier time with Parrot&rsquo;s controls, due to broadened horizons or lack of
preconceptions.</p>
<p>Selection structures are created in Parrot with a combination of labels, <code>goto</code>, and <code>if</code> test
instructions. Yes, the <a href="http://www.c2.com/cgi/wiki?GotoConsideredHarmful">infamous <code>goto</code></a>. Let&rsquo;s
relinquish our <a href="http://en.wikipedia.org/wiki/Cargo_cult_programming">cargo cult</a>
habits and start learning how <code>goto</code> is used in Parrot.</p>
<p>We&rsquo;ll look at labels first, which are how we tell <code>goto</code> where to go.</p>
<h2 id="labels">Labels</h2>
<p>Labels consist of a series of letters, numbers, and underscores followed by a colon <code>:</code> character.
Although it&rsquo;s not strictly required, I use uppercase letters for label identifiers.
You will generally find labels by themselves, outdented from the other instructions around it.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&lt;IDENTIFIER&gt;:
    # Code following instruction</code></pre>
</figure><p>Again: this is not required. I follow this convention because I believe it makes my
code easier to read. You could just as easily have the following instruction on the same line,
but it has the risk of making your code visually cluttered.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >SET_NAME: $S0 = &#39;Brian&#39;
say $S0</code></pre>
</figure><p>Labels serve as markers in your code. They don&rsquo;t accomplish much by themselves, but can
show some of your program structure if named and placed intelligently.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-02.pir
.sub main :main
    .const string PROMPT = &#34;What is your name? &#34;
    .local string name
    .local string response
    .local pmc    stdin

    stdin = getstdin

GET_NAME:
    name = stdin.&#39;readline_interactive&#39;(PROMPT)

    response = &#34;Hello, &#34; . name
    say response
.end</code></pre>
</figure><h3 id="goto"><code>goto</code></h3>
<p>A <code>goto</code> instruction sends Parrot execution to a specific labelled location
in your code.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >goto &lt;LABEL_IDENTIFIER&gt;</code></pre>
</figure><p>When it follows a <code>goto</code>, Parrot picks up by executing the first
instruction following the label. In this example, it creates an
infinite loop which can only be interrupted by pressing
Control-C.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-03.pir
.sub main :main
    .const string PROMPT = &#34;What is your name? &#34;
    .local string name
    .local string response
    .local pmc    stdin

    stdin = getstdin

GET_NAME:
    name = stdin.&#39;readline_interactive&#39;(PROMPT)

    goto GET_NAME

    response = &#34;Hello, &#34; . name
    say response
.end</code></pre>
</figure><p>Infinite loops have their occasional uses, but most of the time they&rsquo;re just
annoying.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-03-03.pir
What is your name? Brian
What is your name? Brian
What is your name? I said &#34;Brian!&#34;
What is your name? &lt;Control-C&gt;</code></pre>
</figure><h3 id="if"><code>if</code></h3>
<p>The <code>if</code> operation lets us perform specific instructions when a particular
condition is true by branching control. At our level of expertise, that
branching is performed with <code>goto</code>. So for us, the general <code>if</code> syntax looks
like this:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >if &lt;conditional&gt; goto &lt;LABEL&gt;</code></pre>
</figure><p>Let&rsquo;s see <code>if</code> in action by adding a little control logic to our name
prompt.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-04.pir
.sub &#39;main&#39; :main
    .const string PROMPT = &#34;What is your name? &#34;
    .local string name
    .local string response
    .local pmc    stdin

    stdin = getstdin

    name = stdin.&#39;readline_interactive&#39;(PROMPT)
    if name == &#34;Brian&#34; goto GREETING_FOR_BRIAN
    response = &#34;Hello, &#34; . name
    goto SAY_IT

  GREETING_FOR_BRIAN:
    response = &#34;Hey, Brian!&#34;

  SAY_IT:
    say response

.end</code></pre>
</figure><p>I admit it. This example is all about making me feel good. One greeting is prepared for users named Brian, while
another greeting is prepared for everybody else. The program accomplishes this by examining the value of <code>name</code>.
If <code>name</code> is &ldquo;Brian&rdquo;, the program is instructed to <code>goto</code> the label <code>GREETING_FOR_BRIAN</code>. Otherwise it continues
on, preparing a generic response and going to the <code>SAY_IT</code> label. <code>GREETING_FOR_BRIAN</code> prepares a custom response
and follows up to the next instruction, which happens to be the <code>SAY_IT</code> code. Remember that labels are just markers.
They don&rsquo;t cut the labeled code off from the rest of your code.</p>
<h4 id="conditionals">Conditionals</h4>
<p>The conditional in an <code>if</code> operation is checked to see if it looks false. The
conditional can be a simple variable, in which case the value of the variable
is examined. False looks a little different for each of the types.</p>
<table>
<thead>
<tr>
<th>For This Type</th>
<th>False looks like this</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer</td>
<td><code>0</code></td>
</tr>
<tr>
<td>Number</td>
<td><code>0.0</code></td>
</tr>
<tr>
<td>String</td>
<td><code>&quot;&quot;</code>, <code>&quot;0&quot;</code></td>
</tr>
</tbody>
</table>
<p>Anything that doesn&rsquo;t look false is considered true.</p>
<p>You can also use comparison operators to compare two values in your conditional.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-05.pir
.sub main :main
    .local int    a
    .local int    b
    .local pmc    stdin

    stdin = getstdin

    a = stdin.&#39;readline_interactive&#39;(&#39;a: &#39;)
    b = stdin.&#39;readline_interactive&#39;(&#39;b: &#39;)

    if a &gt; b goto A_IS_GREATER
    if b &gt; a goto B_IS_GREATER
    goto BOTH_EQUAL

A_IS_GREATER:
    say &#34;a is greater&#34;
    goto END
B_IS_GREATER:
    say &#34;b is greater&#34;
    goto END
BOTH_EQUAL:
    say &#34;a and b are the same&#34;
    goto END

END:
    say &#34;Wasn&#39;t that fun?&#34;
.end</code></pre>
</figure><p>This little script grabs two values from the user and reports which one is greater -
or reports the special case when they are the same.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-03-05.pir
a: 5
b: 10
b is greater
Wasn&#39;t that fun?</code></pre>
</figure><p>Here are the comparison operators that are available for your conditionals.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Tests</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a == b</code></td>
<td>Are <code>a</code> and <code>b</code> the same value?</td>
</tr>
<tr>
<td><code>a !== b</code></td>
<td>Are <code>a</code> and <code>b</code> different values?</td>
</tr>
<tr>
<td><code>a &gt; b</code></td>
<td>Is <code>a</code> greater than <code>b</code>?</td>
</tr>
<tr>
<td><code>a &lt; b</code></td>
<td>Is <code>a</code> less than <code>b</code>?</td>
</tr>
<tr>
<td><code>a &gt;= b</code></td>
<td>Is <code>a</code> greater than or equal to <code>b</code>?</td>
</tr>
<tr>
<td><code>a &lt;= b</code></td>
<td>Is <code>a</code> less than or equal to <code>b</code>?</td>
</tr>
</tbody>
</table>
<p>What about having multiple tests? For example, maybe you will only accept
a number if it&rsquo;s within a certain range. Parrot does not let us chain
comparisons, but we can still use multiple tests with the <code>and</code> and <code>or</code>
opcodes.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-06.pir
.sub main :main
    .const int MINIMUM = 10
    .const int MAXIMUM = 100
    .local int input
    .local int input_is_valid
    .local pmc stdin

    stdin = getstdin

GET_NUMBER:
    print &#34;Enter a number (&#34;
    print MINIMUM
    print &#34; - &#34;
    print MAXIMUM
    print &#34;)&#34;
    input = stdin.&#39;readline_interactive&#39;(&#39;: &#39;)
    $I0 = input &gt;= MINIMUM
    $I1 = input &lt;= MAXIMUM
    input_is_valid = and $I0, $I1
    if input_is_valid goto VALID_INPUT
    say &#34;That is not in the acceptable range!&#34;
    goto END_PROGRAM

  VALID_INPUT:
    say &#34;That is in the acceptable range.&#34;

  END_PROGRAM:
    say &#34;Thank you!&#34;
.end</code></pre>
</figure><p><code>and</code> compares its arguments, and returns true if the arguments all look true.
Parrot lets you store test results in a variable, as you can see. Then you can
examine the truthiness of the variable in your <code>if</code> condition.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-03-06.pir
Enter a number (10 - 100): 990
That is not in the acceptable range!
Thank you!
$ parrot example-03-06.pir
Enter a number (10 - 100): 82
That is in the acceptable range.
Thank you!</code></pre>
</figure><p>This approach looked odd enough to me that I thought I&rsquo;d show the equivalent
Perl code.</p>
<p>This Parrot code:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >  $I0 = input &gt;= MINIMUM
  $I1 = input &lt;= MAXIMUM
  input_is_valid = and $I0, $I1
  if input_is_valid goto VALID_INPUT
  say &#34;That is not in the acceptable range!&#34;
  goto END_PROGRAM

VALID_INPUT:
  say &#34;That is in the acceptable range.&#34;

END_PROGRAM:
  say &#34;Thank you!&#34;</code></pre>
</figure><p>is roughly equivalent to the following Perl code:</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nv">$input</span> <span class="o">&gt;=</span> <span class="nv">$MINIMUM</span> <span class="o">&amp;&amp;</span> <span class="nv">$input</span> <span class="o">&lt;=</span> <span class="nv">$MAXIMUM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;That is in the acceptable range.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="s">&#34;That is not in the acceptable range.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">say</span> <span class="s">&#34;Thank you!&#34;</span><span class="p">;</span></span></span></code></pre>
</figure><p>We could also use <code>or</code>, which compares its arguments and returns true if <em>either</em>
argument looks true.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-07.pir
.sub &#39;main&#39; :main
    .const int MINIMUM = 10
    .const int MAXIMUM = 100
    .local int input
    .local int input_is_invalid
    .local pmc stdin

    stdin = getstdin

GET_NUMBER:
    print &#34;Enter a number (&#34;
    print MINIMUM
    print &#34; - &#34;
    print MAXIMUM
    print &#34;)&#34;
    input = stdin.&#39;readline_interactive&#39;(&#39;: &#39;)
    $I0 = input &lt;= MINIMUM
    $I1 = input &gt;= MAXIMUM
    input_is_invalid = or $I0, $I1
    if input_is_invalid goto WARN_USER_ABOUT_INPUT
    goto END_PROGRAM

WARN_USER_ABOUT_INPUT:
    say &#34;That is not in the acceptable range!&#34;

END_PROGRAM:
    say &#34;Thank you!&#34;
.end</code></pre>
</figure><h3 id="unless"><code>unless</code></h3>
<p>Sometimes the normal <code>if</code> test does not clearly describe your needs. You
may only want to branch if a test fails. While you <em>can</em> do this with <code>if</code>,
Parrot also provides the <code>unless</code> test for exactly this situation. <code>unless</code>
looks similar to <code>if</code>:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >unless &lt;conditional&gt; goto &lt;LABEL&gt;</code></pre>
</figure><p>I can use it in the user prompt program to streamline the description of
the application&rsquo;s response to anyone but me.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-08.pir
.sub main :main
    .const string PROMPT = &#34;What is your name? &#34;
    .local string name
    .local string response
    .local pmc    stdin

    stdin = getstdin

    name = stdin.&#39;readline_interactive&#39;(PROMPT)
    unless name == &#34;Brian&#34; goto GENERIC_GREETING
    response = &#34;Hey, Brian!&#34;
    goto SAY_IT

  GENERIC_GREETING:
    response = &#34;Hello, &#34; . name

  SAY_IT:
    say response
.end</code></pre>
</figure><p>The program will run the same after this little change. Try it and see.</p>
<p>Usage of <code>unless</code> is a personal choice. I like it because it lets me describe
my program a little more concisely. Others don&rsquo;t like to use <code>unless</code> because
it adds to the mental load of reading application code: &ldquo;let&rsquo;s see, <code>unless</code>
means &lsquo;<code>if</code> this is not true.&rdquo; Both points of view are valid, and ultimately
it&rsquo;s up to you whether <code>unless</code> belongs in your code.</p>
<h3 id="repetition">Repetition</h3>
<p>We saw the infinite loop earlier when we first looked at <code>goto</code>. Let&rsquo;s
explore more controlled loops.</p>
<p>Believe it or not, the combination of <code>if</code> and <code>goto</code> provide us with the
core features we need for a wide range of control structures. Things can
get interesting now that we&rsquo;ve added these tools to our kit.</p>
<p>How about a countdown?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-09.pir
.sub &#39;main&#39; :main
    .const int start = 10
    .const int stop  = 0
    .local int current

    current = start
  COUNTDOWN:
    if current &lt; stop goto LIFTOFF
    say current
    current -= 1
    goto COUNTDOWN

  LIFTOFF:
    say &#34;Liftoff!&#34;
.end</code></pre>
</figure><p>This presents a simple count-controlled loop. We set a loop counter <code>current</code> to a reasonable start value before we
start looping. We check the value of the loop counter each time we start the loop, quitting if <code>current</code> is less
than our stopping value. After our check, we display the value, subtract one, and run the loop again.</p>
<p>A condition-controlled loop is easy, too.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-03-10.pir
.sub main :main
    .const string PROMPT = &#34;What is your name? &#34;
    .local string name
    .local string response
    .local pmc    stdin

    stdin = getstdin

GET_NAME:
    name = stdin.&#39;readline_interactive&#39;(PROMPT)
    if name goto GREET_USER
    goto GET_NAME

GREET_USER:
    response = &#34;Hello, &#34; . name
    say response
.end</code></pre>
</figure><p>Our script will now continue to check to see if the user actually entered
anything for a name. If the user has entered a name, control goes to
the <code>GREET_USER</code> label. Otherwise, control is sent backwards to the
<code>GET_USER</code> label.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-03-10.pir
What is your name? 
What is your name? Brian
Hello, Brian</code></pre>
</figure><p>Collection loops such as list iterators will have to wait until we examine PMCs.</p>
<h2 id="summary">Summary</h2>
<p>Adding <code>if</code> and <code>goto</code> to our toolkit has given us the means to build fundamental
control structures in our Parrot programs. We know how to use simple conditionals
as well as how to create more complex conditionals using <code>and</code> and <code>or</code>. We have
<code>unless</code> for those situations when <code>if</code> doesn&rsquo;t describe our intent clearly
enough. We can use the simple combination of <code>if</code> and <code>goto</code> to create counter
and condition controlled loops. A really determined person could create useful
programs with just this information. However, even simple useful
programs would benefit from using the library of PMCs that are available.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Perl 5.10.1 is available</title>
  <link>https://randomgeekery.org/post/2009/08/perl-5101-is-available/</link>
  <pubDate>Sun, 23 Aug 2009 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/08/perl-5101-is-available/</guid>
  <description>Find it at https://perl.org. I can stop whining - for a little bit, at least. About Perl, anyways.</description>
   <category>post</category> 
   <category>post</category> 
   <category>perl</category>  <category>blogspot</category> 
  <content:encoded><![CDATA[<p>Find it at <a href="https://perl.org">https://perl.org</a>. I can stop whining - for a little bit, at least. About <a href="/card/perl/">Perl</a>, anyways.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 01 - Getting Started</title>
  <link>https://randomgeekery.org/post/2009/07/parrot-babysteps-01-getting-started/</link>
  <pubDate>Sun, 12 Jul 2009 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/07/parrot-babysteps-01-getting-started/</guid>
  <description>Introduction I want to explore basic installation and usage of Parrot. The usage will include output, simple variables, and input. PIR, the Parrot Intermediate Representation language, will be my language of choice. This is the same pattern as my other Babysteps tutorials, but the fact that PIR is a lower level language means that these are going to be some pretty big steps. I encourage you to walk along with me if you’re curious about PIR.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I want to explore basic installation and usage of <a href="/card/parrot/">Parrot</a>. The usage will include output, simple variables, and input. PIR, the <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch03_basic_syntax.pod.html">Parrot Intermediate Representation</a> language, will be my language of choice. This is the same pattern as my other Babysteps tutorials, but the fact  that PIR is a lower level language means that these are going to be some pretty big steps. I encourage you to walk along with me if you&rsquo;re curious about PIR.</p>
<p>As always, I welcome suggestions from both novice and experienced Parrot hackers on how to improve this material for newcomers to Parrot.</p>
<h3 id="my-setup">My Setup</h3>
<h4 id="linux">Linux</h4>
<p>I&rsquo;m running <a href="http://www.ubuntu.com">Ubuntu</a> 10.10 with <a href="http://packages.ubuntu.com/lucid/build-essential">build-essential</a> and Perl 5 installed.
Perl 5 is installed by default on Ubuntu, and <code>build-essential</code> is easy enough.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sudo apt-get install build-essential</code></pre>
</figure><p>There may be other dependencies already installed on this machine that I do not know
about. I tend to install <em>many</em> packages on my system, such as <a href="http://packages.ubuntu.com/lucid/wget">wget</a>. Perl 5 and
<code>build-essential</code> should do it as far as I know, though.</p>
<p>You will probably want a good text editor as well. <a href="/tags/vim/">Vim</a>
is my choice, but you&rsquo;re welcome to use anything that makes you happy.</p>
<h4 id="os-x">OS X</h4>
<p>The iMac which rules our home is currently running OS X 10.6 with the Developer Tools
and <a href="http://www.macports.org">MacPorts</a>. As usual, my text editor of choice for this platform is <a href="/tags/vim/">Vim</a>. I
have my essential toolkit including <code>wget</code> installed via MacPorts.</p>
<h4 id="windows">Windows</h4>
<p>I&rsquo;m using 32 bit Microsoft Windows 7 Ultimate on the other partition of my laptop. Hey,
it&rsquo;s better than Vista. I&rsquo;m also using <a href="/tags/vim/">Vim</a> to edit my
files on this platform because I am a creature of habit.</p>
<h2 id="installation">Installation</h2>
<p>You need to get Parrot before you can use it. The <a href="http://www.parrot.org/download">download page</a> shows where you can get versions of Parrot appropriate to your system, including <a href="http://sourceforge.net/projects/parrotwin32/">Windows packages</a>.</p>
<h3 id="linux-and-os-x">Linux and OS X</h3>
<p>I will be grabbing the latest <a href="http://parrot.org/source.html">stable source release</a>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ cd ~/src
$ wget http://www.parrot.org/release/supported</code></pre>
</figure><p>Previous versions of these Babysteps were using the development releases of Parrot.
Why did I switch? I have trouble keeping my articles up to date with the pace
of Parrot development while also developing new material and working, so my focus moved
to the slower &ldquo;supported&rdquo; cycle. I may switch back to using development releases
if stable is horribly broken for something the Babysteps need. You&rsquo;re welcome
to use development. Most of the material will <em>probably</em> work as-is.</p>
<p>I&rsquo;ve gone through a few installations of Parrot by now, and have finally noticed that
bad things happen if you ignore your old installation. Cleaning up the important
files for the old installation is a good idea. So, if you are upgrading:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sudo rm -rf /usr/local/lib/*parrot*</code></pre>
</figure><p>Of course, you better make sure that anything matching that name pattern is actually
related to your old Parrot install before nuking them like this.</p>
<p>Next I&rsquo;ll unpack, build, and test my download.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ tar xfvz parrot-3.0.0.tar.gz
$ cd parrot-3.0.0
$ perl Configure.pl
$ make
$ make test</code></pre>
</figure><p><code>make test</code> takes a little longer each time I install a new version of Parrot. They add tests in every
iteration. Just think of those extra few seconds as proof that someone cares about the quality of
software they&rsquo;re writing for the world.</p>
<p>The Parrot authors can always use additional feedback about how well their baby works on
different platforms. One piece of information that can be useful for them is a smoke report
with test results telling them how well Parrot works on your machine. You can very easily do
this on Linux and OS X:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sudo cpan TAP::Harness::Archive
$ make smoke
...
All tests successful.
Files=381, Tests=13848, 155 wallclock secs ( 2.36 usr  1.43 sys &#43; 102.37 cusr 28.89 csys = 135.05 CPU)
Result: PASS

TAP Archive created at /Users/brian/src/parrot/parrot-3.0.0/parrot_test_run.tar.gz
Test report successfully sent to Smolder at
http://smolder.parrot.org/app/projects/report_details/14424
You can see other recent reports at
http://smolder.parrot.org/app/projects/smoke_reports/1 .</code></pre>
</figure><p>My smoke report and the <a href="http://smolder.parrot.org/app/projects/smoke_reports/1">list of recent reports</a> are fun to look at in a nerdy
sort of way.</p>
<p>There. Now I&rsquo;ll install Parrot.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sudo make install</code></pre>
</figure><p>Oh, editor support is also available. Since I&rsquo;m using Vim, I&rsquo;ll need to make <code>vim-install</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ cd editor
$ make vim-install</code></pre>
</figure><p>This gives me syntax highlighting and template generation for new PIR files.</p>
<h3 id="windows-1">Windows</h3>
<p>It appears to be even more straightforward to install Parrot on Microsoft Windows.
The <a href="http://www.parrot.org/download">Parrot download page</a> includes a link to
an installer file.</p>
<blockquote>
<p><a href="http://sourceforge.net/projects/parrotwin32/files/parrotwin32%20setup/">parrot-win32 setup files</a></p>
</blockquote>
<p>The stable setup file available currently is <code>setup-parrot-3.0.0.exe</code>. If you browse around,
you will find a lot of interesting setup files. I won&rsquo;t be exploring them right now,
but I encourage you to check them out.</p>
<p>I will download the latest stable installer and run it, following all the defaults for now.
That was easy. Don&rsquo;t miss the CHM Parrot documentation in <code>C:\Parrot-2.3.0\share\doc\parrot</code>!
It is good to have documentation handy when exploring strange new software.</p>
<p>I&rsquo;m not sure if this warning is still true, since my recent reinstallation of Windows
means I don&rsquo;t have a previous Parrot install to overwrite. Still, it&rsquo;s worth checking out.</p>
<p>When you install a new version of Parrot, the default behavior is to place it in the
same location as your previous installation. This means 3.0 would sit in <code>C:\Parrot-2.9.0</code>
on my machine. That can cause trouble, since some important Parrot settings may be based
on assumptions about where it was installed. The safest thing before upgrading Parrot
on Windows is to uninstall old versions through the Control Panel, and to make sure
that previous Parrot bin folders are not sitting on your Path. Check for that in
Computer → System Properties → Advanced System Settings →
Environment Variables. It gets easier to remember those steps after you&rsquo;ve clicked them
a few times. <strong>Do not install a new Parrot until you have removed the old one!</strong></p>
<p>So - installing Parrot is easy, but I still want my Vim support. The installer was made with
the reasonable assumption that Parrot users on Windows weren&rsquo;t going to need support for their
favorite Unix editors. Reasonable assumptions tend to break down around me, though.</p>
<p>If you&rsquo;re not using Vim on Windows, you can just move on to the next section. As for the rest of us,
let&rsquo;s get to it.</p>
<ol>
<li>Take your browser to the <a href="https://github.com/parrot/parrot/tree/RELEASE_3_0_0/editor">editor</a> directory for the latest stable Parrot release.</li>
<li>Download the files that are important for Vim support:
<ul>
<li><code>filetype_parrot.vim</code></li>
<li><code>indent_pir.vim</code></li>
<li><code>pasm.vim</code></li>
<li><code>pmc.vim</code></li>
<li><code>pir_vim.in</code></li>
<li><code>skeleton.pir</code></li>
</ul>
</li>
<li>Create a <code>vimfiles</code> directory in your home folder if you don&rsquo;t already have one.</li>
<li>Using <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/editor/README.pod">README.pod</a> as your guide, move the support files into your <code>vimfiles</code> directory:
<ul>
<li><code>filetype_parrot.vim</code> → <code>vimfiles\ftdetect\filetype_parrot.vim</code></li>
<li><code>indent_pir.vim</code> → <code>vimfiles\indent\pir.vim</code></li>
<li><code>pasm.vim</code> → <code>vimfiles\syntax\pasm.vim</code></li>
<li><code>pmc.vim</code> → <code>vimfiles\syntax\pmc.vim</code></li>
<li><code>pir_vim.in</code> → <code>vimfiles\syntax\pir.vim</code></li>
<li><code>skeleton.pir</code> → <code>vimfiles\skeleton.pir</code></li>
</ul>
</li>
<li>Open <code>vimfiles\ftdetect\filetype_parrot.vim</code> and execute the following:
<ul>
<li><code>:4s/\.vim/vimfiles</code></li>
<li>Or yeah, you can move to where it says <code>.vim</code> and manually replace that
with <code>vimfiles</code> if that&rsquo;s how you like to do things.</li>
</ul>
</li>
</ol>
<p>The steps may be a little more involved than just &ldquo;click and run&rdquo;, but it&rsquo;s worth
it for me. I <em>like</em> having Vim support.</p>
<h2 id="output">Output</h2>
<p>It is time to start writing code. Move to your projects
directory and create a new directory for the Parrot Babysteps project.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ cd ~/projects
$ mkdir parrot-babysteps
$ cd parrot-babysteps
$ gvim example-01-01.pir</code></pre>
</figure><p>When I&rsquo;m connected to the iMac via <code>ssh</code> I settle for</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ vim example-01-01.pir</code></pre>
</figure><p>The steps are the more or less the same on Windows. First, open a command
prompt by whatever means you&rsquo;re comfortable with. I prefer typing <code>cmd</code>
into the &ldquo;Search programs and files&rdquo; field of the Start menu. Then, move to your projects
directory and create a new directory for the Parrot Babysteps project.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >C:\Users\brian&gt; cd \projects
C:\projects&gt; mkdir parrot-babysteps
C:\projects&gt; cd parrot-babysteps
C:\projects\parrot-babysteps&gt; gvim example-01-01.pir</code></pre>
</figure><p>From here on, the differences between Windows and other platforms become
small enough that I feel comfortable ignoring them until something really significant
catches my attention.</p>
<p>We immediately see some benefit from installing editor support.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># Copyright (C) 2011 Parrot Foundation.

.sub &#39;main&#39; :main
    # For Parrot developers.
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:</code></pre>
</figure><p>That looks like a heck of a lot for an otherwise empty file, but most of those
lines are actually comments.</p>
<h3 id="comments">Comments</h3>
<p>PIR comments start with a <code>#</code> character. Everything from that <code>#</code> to the end of the line is
ignored by the parser.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># This is a comment</code></pre>
</figure><p>Comments are handy. They can explain why you chose a particular solution,
concerns you have about the code, or pretty much anything else. The
comments in our template serve to identify where the template file came from
and a few directives for Vim to remember when editing this file.</p>
<h3 id="directives">Directives</h3>
<p>There are only two important lines left when we ignore the comments.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub main :main
.end</code></pre>
</figure><p>Lines that start with a period (<code>.</code>) are <em>directives</em>, special instructions for PIR. There
are a number of directives for Parrot, and it is possible to create your own. The <code>.sub</code>
line is telling PIR that this line begins a compilation unit called &ldquo;main&rdquo; which serves as the <code>:main</code>
compilation unit in the program. Compilation units are tasty named tidbits of code that get a
particular job done. They seem roughly the same as subroutines in other languages, so that&rsquo;s
what I&rsquo;m going to call them from here on. Less typing that way. Once you have created a subroutine,
you can call it elsewhere in your code.</p>
<p>Subroutines can also have a tag after their name to add a little extra information. The
subroutine tagged as <code>:main</code> is the main entry point for a PIR application - it&rsquo;s where
the program actually starts running. When you hand a <code>.pir</code> script to parrot, it directly
executes the code contained in <code>:main</code>. If it can&rsquo;t find a subroutine tagged
with <code>:main</code>, then Parrot will directly execute the first subroutine in your code. It is a
good idea to specify which is <code>:main</code> so you don&rsquo;t have to rely on the default behavior.</p>
<p>The <code>.end</code> directive tells PIR that it has reached the end of this particular subroutine.
Any <code>.sub</code> must be followed by <code>.end</code> eventually. Everything in between is the
body of the subroutine - the stuff that gets executed when the subroutine is called.</p>
<p>We now basically know what a subroutine is, what it looks like, and how Parrot goes
about figuring out which one to run first. We still don&rsquo;t have anything to be executed,
though. How about making this program <em>do</em> something?</p>
<h3 id="building-the-program">Building The Program</h3>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-01-01.pir
.sub main :main
    say &#34;Hello, world!&#34;
.end</code></pre>
</figure><p>Finally - code! Fairly self-explanatory code at that. Well, almost. <code>say</code> is
an <a href="http://docs.parrot.org/parrot/latest/html/ops.html"><em>opcode</em></a> - a
native Parrot command - for presenting values to the user. <code>say</code> won&rsquo;t normally speak the
phrase &ldquo;Hello, world!&rdquo; through your speakers. It will, however print the phrase on a line in your
console.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-01-01.pir
Hello, World!
$</code></pre>
</figure><h2 id="variables">Variables</h2>
<p>What if I want to change the greeting, so that it displays my name as part of the greeting?
While simply rewriting the phrase does technically work &hellip;</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-01-02.pir
.sub main :main
    say &#34;Hello, Brian!&#34;
.end</code></pre>
</figure><p>&hellip; I want something a little more flexible. I want to be able to define a name, and then
print a greeting with the name. This will require adding a variable.
We use variables whenever we want the program to remember something.</p>
<p>There are four types of things that Parrot can keep track of:</p>
<dl>
<dt>integers</dt>
<dd>Simple counting numbers, like 13 or -485</dd>
<dt>numbers</dt>
<dd>Decimal numbers like 1.3 or -1.3e+5</dd>
<dt>strings</dt>
<dd>text and phrases like &ldquo;Hello, Brian&rdquo;</dd>
<dt>Polymorphic Containers, or PMCs</dt>
<dd>A special type that basically refers to anything that&rsquo;s not an integer, number, or string</dd>
</dl>
<p>Parrot has special rules for dealing with each of these types, so it is important to tell Parrot
how you want your variable treated. One way to do that is with <em>register variables</em>. Registers
can be thought of as variable buckets: one bucket for each type. Okay, maybe not a bucket. More
like four rows of nicely organized variables, with each variable type in its own row.</p>
<p>Register variables are prefixed with the dollar sign <code>$</code> and an uppercase letter indicating their
type. The rest of the variable name is a whole number from zero on up. Here, let me show you:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-01-03.pir
.sub main :main
    $S0 = &#34;Brian&#34;
    $S1 = &#34;Hello, &#34; . $S0
    $S1 = $S1 . &#34;!&#34;
    say $S1
.end</code></pre>
</figure><p>Assignment to register variables is pretty straightforward, as you can see. You tell Parrot which
position in which row is being assigned to on one side of the <code>=</code> symbol, and the value
to assign on the other.</p>
<p>Oh, did you see what I did when creating <code>$S1</code>? I did mention that Parrot has special rules for
handling each type of variable. One thing you can do with string variables is paste two of them
together, making a whole new string. You use the <code>.</code> operator for that. But only for pasting two
strings together. If you want more, you&rsquo;ll need to do it on two lines like I did.</p>
<p>Back to register variables. No, it doesn&rsquo;t really matter which numbers you use. I could have
used <code>$S9999</code> to hold the name and Parrot wouldn&rsquo;t care. We just need to remember what purpose
each variable serves.</p>
<p>Actually, that&rsquo;s the main problem with register variables. Their names don&rsquo;t tell you much about
what purpose the variable serves. Sure, it&rsquo;s easy enough to see that <code>$S1</code> is a string, but will I
still remember that it&rsquo;s being used to hold the name once I&rsquo;ve added a few hundred lines of code?
Probably not. I&rsquo;m getting flashbacks to programming BASIC in grade school, when I kept a cheat
sheet of variable names handy.</p>
<p>Parrot is thankfully there for us with the <code>.local</code> directive. <code>local</code> allows us to create a
readable name for our variable, asking Parrot to deal with the register side of things.</p>
<p>Creation of a local variable requires the <code>.local</code> directive, followed by type information and
lastly a variable name.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.local &lt;type&gt; &lt;name&gt;</code></pre>
</figure><p>The type names match up to the Parrot types, of course:</p>
<ul>
<li><code>int</code> for integers</li>
<li><code>num</code> for numbers</li>
<li><code>string</code> for strings</li>
<li><code>pmc</code> for PMCs</li>
</ul>
<p>Variables created with the <code>.local</code> directive can be treated the same as a
register variable.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-01-04.pir
.sub main :main
    .local string name
    .local string greeting

    name = &#34;Brian&#34;
    greeting = &#34;Hello, &#34; . name
    greeting = greeting . &#34;!&#34;
    say greeting
.end</code></pre>
</figure><p>You know, that line where we append an exclamation to our greeting is longer than it needs to be.
The PIR provides special operators for when you are doing something to a variable and then assigning
the result back to the same variable. That means we could describe &ldquo;append an exclamation point to
<code>greeting</code>&rdquo; this way, too:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-01-05.pir
# ...
greeting = &#34;Hello, &#34; . name
greeting .= &#34;!&#34;
# ...</code></pre>
</figure><h2 id="input">Input</h2>
<p>We&rsquo;ve covered a lot of conceptual ground already. What has it earned us?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-01-05.pir
Hello, Brian!</code></pre>
</figure><p>This is not impressive. We&rsquo;ve actually increased the amount of code significantly compared
to just saying &ldquo;Hello, Brian!&rdquo;. Splitting the name off into its own variable does lay the groundwork
for a slightly more impressive task, though. Let&rsquo;s make the program ask the user for his name
when run.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-01-06.pir
.sub main :main
    .local string name
    .local string greeting
    .local pmc stdin

    stdin = getstdin
    name = stdin.&#39;readline_interactive&#39;(&#34;Please enter your name: &#34;)
    greeting = &#34;Hello, &#34; . name
    greeting .= &#34;!&#34;
    say greeting
.end</code></pre>
</figure><p>We&rsquo;ve only added a few lines, but these few lines have added a lot of functionality. The first thing
you probably noticed was the <em>pmc</em> variable named <code>stdin</code>. PMCs are used in Parrot for complex types,
like classes in other languages. They often have special subroutines called <em>methods</em> tied to them.
Those methods can greatly simplify the creation of complex programs.</p>
<p>We use the opcode <code>getstdin</code> to figure out standard input and assign
it to our <code>stdin</code> PMC. Standard input - widely referred to as <em>stdin</em> - is a
<a href="http://docs.parrot.org/parrot/latest/html/src/pmc/filehandle.pmc.html">FileHandle</a> that
describes where we expect user input to come from. That can be any number of places, but
usually refers to the keyboard. The FileHandle method we care about most today is <code>readline_interactive</code>.
<code>readline_interactive</code> prompts the user for input, and hands that input back to the program.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-01-06.pir
Please enter your name: Brian
Hello, Brian</code></pre>
</figure><h2 id="conclusion">Conclusion</h2>
<p>We&rsquo;ve done quite a bit today. We installed Parrot, created a simple script that prints a greeting
to the console, then expanded our script to get the user&rsquo;s name and incorporate the name into the
greeting. It took less effort than I thought it would despite the fact that PIR is low-level
compared to languages like Python and Perl 5.</p>
<p>The ability to handle user input makes it easier to create meaningful programs even with a bare
minimum of knowledge, and can be very handy as we explore Parrot, the PIR syntax, and the
many <a href="http://docs.parrot.org/parrot/latest/html/pmc.html">PMCs</a>. From this starting point,
we can go deeper into the <a href="http://docs.parrot.org/parrot/latest/html/">Parrot</a> and <a href="http://docs.parrot.org/parrot/latest/html/docs/pdds/pdd19_pir.pod.html">PIR</a> documentation, and search the Web
for Parrot tutorials.</p>
<p>Remember also that Parrot is released monthly. I do try to keep these pages up to date, but sometimes
work and life demand more of my time, or I get distracted by bright shiny things. So don&rsquo;t assume
my version numbers are correct. Double-check them for yourself.</p>
<p>Most of all, have fun!</p>
]]></content:encoded>
</item>
</channel>
</rss>
