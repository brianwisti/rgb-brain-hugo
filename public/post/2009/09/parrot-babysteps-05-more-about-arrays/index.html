<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
    










    







<script defer language="javascript" type="text/javascript" src="/js/bundle.min.60856f0f2ed73fb3cd2820ee548c4698ffbc4d743736e852c0e27ce4f52dfd9c.js"></script>






    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    <link rel="icon" href=/favicon.png>

    
    





  





  
  
  

<meta property="og:url" content="https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/">
<meta property="og:title" content="Parrot Babysteps 05 - More About Arrays">
<meta name="twitter:title" content="Parrot Babysteps 05 - More About Arrays">


  <meta name="twitter:site" content="@brianwisti">



  
    <meta name="twitter:description" content="Introduction We started looking at arrays in the last step. We&rsquo;re going to take a closer look today, exploring different ways of looking at Parrot arrays to build an averaging calculator. We&rsquo;ll start with no array at all, to build the basic flow of our program and to demonstrate that an array is not always needed. Then we&rsquo;ll move on to more interesting stuff, with array indexing, stack opcodes, and iterators.">
    <meta property="og:description" content="Introduction We started looking at arrays in the last step. We&rsquo;re going to take a closer look today, exploring different ways of looking at Parrot arrays to build an averaging calculator. We&rsquo;ll start with no array at all, to build the basic flow of our program and to demonstrate that an array is not always needed. Then we&rsquo;ll move on to more interesting stuff, with array indexing, stack opcodes, and iterators.">
  



<title itemprop="name">Parrot Babysteps 05 - More About Arrays - Random Geekery</title>
<meta property="og:title" content=Parrot&#32;Babysteps&#32;05&#32;-&#32;More&#32;About&#32;Arrays&#32;-&#32;Random&#32;Geekery />
<meta name="twitter:title" content=Parrot&#32;Babysteps&#32;05&#32;-&#32;More&#32;About&#32;Arrays&#32;-&#32;Random&#32;Geekery />
<meta itemprop="name" content=Parrot&#32;Babysteps&#32;05&#32;-&#32;More&#32;About&#32;Arrays&#32;-&#32;Random&#32;Geekery />
<meta name="application-name" content=Parrot&#32;Babysteps&#32;05&#32;-&#32;More&#32;About&#32;Arrays&#32;-&#32;Random&#32;Geekery />
<meta property="og:site_name" content="Random Geekery" />


<meta name="description" content="" />
<meta itemprop="description" content="" />
<meta property="og:description" content="" />
<meta name="twitter:description" content="" />


<base href="https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/" />
<link rel="canonical" href="https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/" itemprop="url" />
<meta name="url" content="https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/" />
<meta name="twitter:url" content="https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/" />
<meta property="og:url" content="https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/" />


<meta property="og:updated_time" content=29009-29-12T90:00:09-0700 />


<link rel="sitemap" type="application/xml" title="Sitemap" href='https://randomgeekery.org/sitemap.xml' />

  <link
      rel="alternate"
      type="application/rss+xml"
    
        href="/index.xml"
    
      title="Random Geekery"/>



<meta name="robots" content="index,follow" />
<meta name="googlebot" content="index,follow" />


<meta name="twitter:site" content="" />
<meta name="twitter:creator" content="" />
<meta property="fb:admins" content="" />


<meta name="apple-mobile-web-app-title" content="Random Geekery" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />






<meta name="generator" content="Hugo 0.121.2">


    
    

<link
    rel="stylesheet"
    href="/css/style.15361b4c24f30033251cd8947e34c41e754c9461dc117cab390ac04e365faec3.css"
    integrity="sha256-FTYbTCTzADMlHNiUfjTEHnVMlGHcEXyrOQrATjZfrsM=" 
    crossorigin="anonymous">


</head>

    <body class="">
        <div class="wrapper">
            <aside class="sidebar">
    <div class="container sidebar-sticky">
        <div class="light-dark" align="right">
    <button class="btn-light-dark" title="Toggle light/dark mode">
        <svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M6 .278a.768.768 0 0 1 .08.858a7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277c.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316a.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71C0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
        </svg>
        <svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M8 12a4 4 0 1 0 0-8a4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
        </svg>
    </button>
</div>

        <div class="sidebar-about">
    <h1 class="brand">
        
        
            <a href="https://randomgeekery.org">
                <h1>Random Geekery</h1>
            </a>
        
    </h1>
    <p class="lead">
    Collecting my attempts to improve at tech, art, and life
    </p>
</div>

        <nav>
    <ul class="sidebar-nav">
      
        <li class="bullet">
          <a href="/follow/">Follow</a>
        </li>
      
        <li class="bullet">
          <a href="/now/">Now</a>
        </li>
      
    </ul>
</nav>

        
  <div class="related">
    <div class="related-posts">
      <h3>Related</h3>
      <ul>
        
          <li><a href="/post/2009/12/parrot-babysteps-08-testing-with-testmore/">Parrot Babysteps 08 - Testing With Test::More</a></li>
        
          <li><a href="/post/2009/10/parrot-babysteps-07-writing-subroutines/">Parrot Babysteps 07 - Writing Subroutines</a></li>
        
          <li><a href="/post/2009/10/parrot-babysteps-06-files-and-hashes/">Parrot Babysteps 06 - Files and Hashes</a></li>
        
          <li><a href="/post/2009/09/parrot-babysteps-04-adding-command-line-arguments/">Parrot Babysteps 04 - Adding Command Line Arguments</a></li>
        
          <li><a href="/post/2009/09/parrot-babysteps-03-simple-control-structures/">Parrot Babysteps 03 - Simple Control Structures</a></li>
        
      </ul>
    </div>
  </div>



        
















        <p class="footnote">
powered by <a target="_blank" href="https://gohugo.io">Hugo</a> | themed with <a target="_blank" href="https://github.com/lukeorth/poison">poison</a>
    <br>
    &copy; 2024 Brian Wisti. All rights reserved.
</p>
<p class="footnote">
  This work is licensed under a
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
    Creative Commons Attribution 4.0 International License
  </a>.
</p>

  </div>
</aside>

            <main class="content container">
                <div class="post">
  <nav class="masthead">
    <ul>
    
  
    
  
    
  

    <li><a href="https://randomgeekery.org/">Random Geekery</a></li>
  

    <li><a href="https://randomgeekery.org/post/">Posts</a></li>
  

    <li><a class="active" href="https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/">Parrot Babysteps 05 - More About Arrays</a></li>
</nav>



  <div class="info">
    <h1 class="post-title">
        <a href="https://randomgeekery.org/post/2009/09/parrot-babysteps-05-more-about-arrays/">Parrot Babysteps 05 - More About Arrays</a>
    </h1>
    
        <time datetime="2009-09-29T00:00:00-0700" class="post-date">
            September 29, 2009
        </time>
    
    
    <ul class="tags">
        
        <li class="tag-parrot">
            <a href="https://randomgeekery.org/tags/parrot">parrot</a>
        </li>
        
        <li class="tag-learn">
            <a href="https://randomgeekery.org/tags/learn">learn</a>
        </li>
        
        <li class="tag-coolnamehere">
            <a href="https://randomgeekery.org/tags/coolnamehere">coolnamehere</a>
        </li>
        
    </ul>
    
    
    
    
        <p class="seriesname">
            Series: <a href="https://randomgeekery.orgseries/">[Parrot Babysteps]</a>
        </p>
    
    
    
</div>

  <h2 id="introduction">Introduction</h2>
<p>We started looking at arrays in the <a href="/post/2009/09/parrot-babysteps-04-adding-command-line-arguments/">last step</a>. We&rsquo;re going to take a closer look today, exploring different ways of looking at <a href="/card/parrot/">Parrot</a> arrays to build an averaging calculator. We&rsquo;ll start with no array at all, to build the basic flow of our program and to demonstrate that an array is not always needed. Then we&rsquo;ll move on to more interesting stuff, with array indexing, stack opcodes, and iterators.</p>
<h2 id="building-the-basic-flow">Building the Basic Flow</h2>
<p>Our averaging program is going to get its input from the user, and will take an
arbitrary quantity of Numbers. Basically, it will keep accepting Numbers until the
user indicates that she&rsquo;s done. It will then display the average of all Numbers
and exit.</p>
<p>Sounds simple enough. How will the user tell the program that she&rsquo;s done? I like
the idea of using the string &ldquo;done&rdquo;. It&rsquo;s easy to remember and to the point.
Wait. Let me think about that for a moment. The phrase &ldquo;done&rdquo; may be easy
to remember, but &ldquo;quit&rdquo; is more common for leaving an interactive shell. I guess
we should use &ldquo;quit&rdquo;.</p>
<p>Okay, let&rsquo;s make the basic shell.</p>
<pre tabindex="0"><code># example-05-01.pir
.sub &#39;main&#39; :main
	.const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
	.const string EXIT_STRING = &#39;quit&#39;
	.local string user_input
	.local num    latest_number
	.local pmc    stdin

	stdin = getstdin

  GET_INPUT:
	user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
	if user_input == EXIT_STRING goto SHOW_AVERAGE
	latest_number = user_input
	say latest_number
	goto GET_INPUT

  SHOW_AVERAGE:
	say &#34;Average goes here&#34;
	goto EXIT

  EXIT:

.end
</code></pre><p>There&rsquo;s a little debugging output that won&rsquo;t be necessary once the program is
filled out a little more, but we&rsquo;ve got the basics.</p>
<pre tabindex="0"><code>$ parrot example-05-01.pir
Enter a number (or &#34;quit&#34; to quit): 23
23
Enter a number (or &#34;quit&#34; to quit): 12
12
Enter a number (or &#34;quit&#34; to quit): q
0
Enter a number (or &#34;quit&#34; to quit): quit
Average goes here
$
</code></pre><p>Notice that the string is converted to a number using normal Perl rules: if it
doesn&rsquo;t have any numbers, it&rsquo;s treated as zero. We could put in some error
checking to chastise the user for bad input, but I don&rsquo;t feel like it right now.</p>
<h2 id="averaging-with-no-arrays">Averaging With No Arrays</h2>
<p>I would like to point something out before we start digging into array features.
We don&rsquo;t <em>need</em> to use arrays when calculating something like an average. Here&rsquo;s
a perfectly useful example that never uses a single array:</p>
<pre tabindex="0"><code># example-05-02.pir
.sub &#39;main&#39; :main
	.const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
	.const string EXIT_STRING = &#39;quit&#39;
	.local string user_input
	.local num    latest_number
	.local num    total
	.local int    numbers_entered
	.local num    average
	.local pmc    stdin

	stdin = getstdin
	total = 0
	numbers_entered = 0

  GET_INPUT:
	user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
	if user_input == EXIT_STRING goto SHOW_AVERAGE
	latest_number = user_input
	numbers_entered += 1
	total += latest_number
	goto GET_INPUT

  SHOW_AVERAGE:
	average = total / numbers_entered
	say average
	goto EXIT

  EXIT:

.end
</code></pre><p>Here&rsquo;s what it looks like in action.</p>
<pre tabindex="0"><code>$ parrot example-05-02.pir
Enter a number (or &#34;quit&#34; to quit): 5
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): 15
Enter a number (or &#34;quit&#34; to quit): 20
Enter a number (or &#34;quit&#34; to quit): quit
12.5
</code></pre><p>Why did I show this? Well, basically because &ldquo;write an averaging program
without using an Array in the language of your choice&rdquo; is an interview
question I&rsquo;ve been asked a couple of times. It&rsquo;s been a while, but I
thought I&rsquo;d be ready in case somebody asked me again. They&rsquo;ll probably
expect me to use Java or Ruby or something. This will show them. This
will show them all! This will show them - uhh -</p>
<p>I&rsquo;m not sure what it&rsquo;ll show them.</p>
<p>Anyways - I wrote this version because I felt like it. Let&rsquo;s start writing
code that uses arrays, okay?</p>
<h2 id="stacks---pushing-and-popping">Stacks - Pushing and Popping</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Stack_%28data_structure%29">stack</a> is one of
the fundamental data structures. The mental image is straightforward: you have
a stack of things. You can <em>push</em> a new thing onto the stack, or you can <em>pop</em>
the top thing from the stack into your hand. Stacks provide a simple way to
handle every item in a collection. One thing you need to keep in mind is
consistent with that stack image: once you&rsquo;ve popped an item from the stack,
it&rsquo;s not in the collection anymore. So popping all the way through a stack
results in what? Yes, that&rsquo;s right. It results in an empty stack.</p>
<p>Still, the stack structure is good enough for a lot of collection handling,
and will definitely work for our averaging application.</p>
<p>I&rsquo;ll show you the code first, then we can talk about it.</p>
<pre tabindex="0"><code># example-05-03
.sub &#39;main&#39; :main
	.const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
	.const string EXIT_STRING = &#39;quit&#39;
	.local string user_input
	.local num    latest_number
	.local num    total
	.local int    number_count
	.local pmc    numbers
	.local num    average
	.local pmc    stdin

	stdin = getstdin
	numbers = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
	user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
	if user_input == EXIT_STRING goto SETUP_CALCULATE_SUM
	latest_number = user_input
	push numbers, latest_number
	goto GET_INPUT

  SETUP_CALCULATE_SUM:
	total = 0
	number_count = 0

  CALCULATE_SUM:
	latest_number = pop numbers
	total += latest_number
	number_count += 1
	if numbers goto CALCULATE_SUM

	average = total / number_count
	say average

.end
</code></pre><p>We use the <a href="http://docs.parrot.org/parrot/devel/html/src/pmc/resizablefloatarray.pmc.html">ResizableFloatArray</a> PMC to hold our user&rsquo;s numeric input. That is a built-in PMC, so we don&rsquo;t need to do any special includes to access it. Just create a new one with the <code>new</code> opcode.</p>
<pre tabindex="0"><code>.local pmc    numbers
# ...
numbers = new &#39;ResizableFloatArray&#39;
</code></pre><p>After creating <code>numbers</code>, we can push new values onto the array with the <code>push</code>
opcode. We use this to collect user input.</p>
<pre tabindex="0"><code>push numbers, latest_number
</code></pre><p>Later on, when we&rsquo;re calculating the average, we use <code>pop</code> to grab the most
recently pushed value from the stack. We keep doing that until we&rsquo;re out of
numbers, as judged by a simple <code>if</code> test.</p>
<pre tabindex="0"><code>  CALCULATE_SUM:
	latest_number = pop numbers
	total += latest_number
	number_count += 1
	if numbers goto CALCULATE_SUM
</code></pre><p>If <code>numbers</code> is empty and that test looks false to Parrot, the program falls
through to the next statement. That next statement is where we actually
calculate the average.</p>
<pre tabindex="0"><code>$ parrot example-05-03.pir
Enter a number (or &#34;quit&#34; to quit): 1e+5
Enter a number (or &#34;quit&#34; to quit): 1e+3
Enter a number (or &#34;quit&#34; to quit): 1e+1
Enter a number (or &#34;quit&#34; to quit): quit
33670
</code></pre><p>Yes, I was being more clever than I needed to with this example session, but I wanted to remind you that Parrot accepts <a href="http://en.wikipedia.org/wiki/Scientific_notation#E_notation">E notation</a> for numbers. Here&rsquo;s the same session with the numbers looking more like you might have expected.</p>
<pre tabindex="0"><code>$ parrot example-05-03.pir
Enter a number (or &#34;quit&#34; to quit): 100000
Enter a number (or &#34;quit&#34; to quit): 1000
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): quit
33670
</code></pre><h3 id="shift-and-unshift---the-bottom-of-the-stack"><code>shift</code> and <code>unshift</code> - The Bottom of the Stack</h3>
<p>While <code>push</code> and <code>pop</code> work on the end of an array, Parrot also provides <code>unshift</code>
and <code>shift</code> which handle corresponding functionality on the front of an array.
Let&rsquo;s go back to the stack image for a moment. We already have the basic idea
of pushing onto and popping off of the top of a stack. We can also <em>shift</em> an
item from the bottom of that stack. What used to be the first item is now in our
hands, and the rested of the stack has <em>shifted</em> down so that the old second
item is the new first item. We can <em>unshift</em> an item into the bottom of the
stack. Now that unshifted item is the new first in the collection, and the old
first item is now the second.</p>
<p>I really need to get some illustrations in here. The idea is very easy to show,
but my language skills aren&rsquo;t adequate for the task.</p>
<pre tabindex="0"><code># example-05-04
.sub &#39;main&#39; :main
    .const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
    .const string EXIT_STRING = &#39;quit&#39;
    .local string user_input
    .local num    latest_number
    .local num    total
    .local int    number_count
    .local pmc    numbers
    .local num    average
    .local pmc    stdin

    stdin = getstdin
    numbers = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
    user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if user_input == EXIT_STRING goto SETUP_CALCULATE_SUM
    latest_number = user_input
    unshift numbers, latest_number
    goto GET_INPUT

  SETUP_CALCULATE_SUM:
    total = 0
    number_count = 0

  CALCULATE_SUM:
    latest_number = shift numbers
    total += latest_number
    number_count += 1
    if numbers goto CALCULATE_SUM

    average = total / number_count
    say average

.end
</code></pre><p>Which is better? I&rsquo;ll be honest with you. I don&rsquo;t really know. I stick to pushing
and popping because it&rsquo;s easier to visualize.</p>
<p>However, when you combine <code>push</code> and <code>shift</code> you get a whole new structure called
a queue.</p>
<h2 id="queues">Queues</h2>
<p>A <a href="http://en.wikipedia.org/wiki/Queue_%28data_structure%29">queue</a> is yet another way of looking at your array when you are concerned about order. Stacks are LIFO: when you pop an item from the stack, you&rsquo;re getting the last item that was pushed. Queues are FIFO: when you shift an item from the queue, you get the first item that was pushed. Okay - the technical term for placing an item in the queue is <em>enqueue</em> and for grabbing an item is <em>dequeue</em>. Pushing and shifting refer to the opcodes we&rsquo;re using. Use whatever term you&rsquo;re happier with.</p>
<p>The actual code for using a queue instead of a stack still doesn&rsquo;t look all that
different, because they&rsquo;re still producing the same final result.
Let&rsquo;s write an example that clearly demonstrates the difference
between a queue and a stack:</p>
<pre tabindex="0"><code># example-05-05
.sub &#39;main&#39; :main
    .const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
    .const string EXIT_STRING = &#39;quit&#39;
    .local pmc    stdin
    .local string user_input
    .local num    latest_number
    .local pmc    stack
    .local int    stack_count
    .local num    stack_popped
    .local num    stack_sum
    .local num    stack_average
    .local pmc    queue
    .local int    queue_count
    .local num    queue_dequeued
    .local num    queue_sum
    .local num    queue_average

    stdin = getstdin
    stack = new &#39;ResizableFloatArray&#39;
    queue = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
    user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if user_input == EXIT_STRING goto SETUP_SUM_CALCULATIONS
    latest_number = user_input
    push stack, latest_number  # Push onto the stack
    push queue, latest_number  # Enqueue onto the queue
    goto GET_INPUT

  SETUP_SUM_CALCULATIONS:
    stack_count = 0
    stack_sum   = 0
    queue_count = 0
    queue_sum   = 0

  CALCULATE_STACK_SUM:
    stack_popped = pop stack
    print &#34;Popped: &#34;
    say stack_popped
    stack_sum += stack_popped
    stack_count += 1
    if stack goto CALCULATE_STACK_SUM

  CALCULATE_QUEUE_SUM:
    queue_dequeued = shift queue
    print &#34;Dequeued: &#34;
    say queue_dequeued
    queue_sum += queue_dequeued
    queue_count += 1
    if queue goto CALCULATE_QUEUE_SUM

    stack_average = stack_sum / stack_count
    queue_average = queue_sum / queue_count
    print &#34;Stack average: &#34;
    say stack_average
    print &#34;Queue average: &#34;
    say queue_average

.end
</code></pre><p>Now we can see exactly what numbers are being grabbed as our program calculates
the sums.</p>
<pre tabindex="0"><code>$ parrot example-05-05.pir
Enter a number (or &#34;quit&#34; to quit): 5
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): 15
Enter a number (or &#34;quit&#34; to quit): 20
Enter a number (or &#34;quit&#34; to quit): quit
Popped: 20
Popped: 15
Popped: 10
Popped: 5
Dequeued: 5
Dequeued: 10
Dequeued: 15
Dequeued: 20
Stack average: 12.5
Queue average: 12.5
</code></pre><p>That output could fill up the screen if I had a lot of values. I might want to
fine-tune the debug output. Then again, I might want to just move on to the next
subject.</p>
<h2 id="accessing-by-index">Accessing by Index</h2>
<p>Stacks and queues are a practical solution to a wide range of collection-handling
problems. They do have one shortcoming, though. Both of them are destructive.
When you <code>pop</code> or <code>shift</code> a value from an array, you are actually removing that value.
There is nothing left after you haved popped or shifted the last value. Sometimes
that is okay, but sometimes you want to use the array for some other calculation.
Those are the situations where you want a way to access the contents of the array
without changing them. One way to do that is by accessing contents via an index.</p>
<p>The Parrot <a href="http://docs.parrot.org/parrot/devel/html/docs/pmc/array.pod.html">Array documentation</a> shows a few things about setting up fixed-size arrays and setting individual values within arrays, but what I care about is the fact that array elements are accessed pretty much the same as in other languages I&rsquo;m familiar with. We use square brackets <code>[]</code> to access a specific element, and the count is zero-based. Yes, zero-based indexing can be a little confusing sometimes. Think of it as &ldquo;how many items from the front is the element I want?&rdquo; and you should be fine.</p>
<p>We&rsquo;ll build up our array in the same way that we have been, because I want the user
to have some flexibility in deciding how many numbers to average. After that we&rsquo;ll
step through the array by incrementing an index.</p>
<pre tabindex="0"><code># example-05-06
.sub &#39;main&#39; :main
    .const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
    .const string EXIT_STRING = &#39;quit&#39;
    .local string user_input
    .local num    latest_number
    .local num    total
    .local int    number_count
    .local int    number_index
    .local pmc    numbers
    .local num    average
    .local pmc    stdin

    stdin = getstdin
    numbers = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
    user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if user_input == EXIT_STRING goto SETUP_CALCULATE_SUM
    latest_number = user_input
    push numbers, latest_number
    goto GET_INPUT

  SETUP_CALCULATE_SUM:
    total = 0
    number_count = numbers
    number_index = 0

  CALCULATE_SUM:
    if number_index &gt;= number_count goto CALCULATE_AVERAGE
    latest_number = numbers[number_index]
    total += latest_number
    number_index += 1
    goto CALCULATE_SUM

  CALCULATE_AVERAGE:
    average = total / number_count
    
  DISPLAY_VALUES:
    print &#34;Values entered: &#34;
    say number_count
    print &#34;Sum of values:  &#34;
    say total
    print &#34;Average:        &#34;
    say average
.end
</code></pre><p>A little more information is displayed in this version.</p>
<pre tabindex="0"><code>$ parrot example-05-06.pir
Enter a number (or &#34;quit&#34; to quit): 5
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): 15
Enter a number (or &#34;quit&#34; to quit): 20
Enter a number (or &#34;quit&#34; to quit): quit
Values entered: 4
Sum of values:  50
Average:        12.5
</code></pre><p>Notice that we check to see if we&rsquo;ve stepped outside of bounds right away. We
could test at the end of that section, but the truth is that I don&rsquo;t trust my
own code. The sooner I can see if I need to move on, the happier I&rsquo;ll be. I
could even test if we&rsquo;ve somehow gone below zero if I was feeling especially
paranoid. I won&rsquo;t do that today, though. You&rsquo;re welcome.</p>
<h2 id="using-an-iterator">Using an Iterator</h2>
<p>We&rsquo;re nearly done. There is only one more way of traversing arrays that I want to look at. Parrot <a href="http://docs.parrot.org/parrot/devel/html/src/pmc/iterator.pmc.html">Iterators</a> allow you to step through the contents of an array without doing anything to the array itself, while ignoring the details of array indexing.</p>
<pre tabindex="0"><code># example-05-07
.sub &#39;main&#39; :main
    .const string PROMPT      = &#39;Enter a number (or &#34;quit&#34; to quit): &#39;
    .const string EXIT_STRING = &#39;quit&#39;
    .local string user_input
    .local num    latest_number
    .local num    total
    .local int    number_count
    .local pmc    numbers
    .local pmc    numbers_iterator
    .local num    average
    .local pmc    stdin

    stdin = getstdin
    numbers = new &#39;ResizableFloatArray&#39;

  GET_INPUT:
    user_input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if user_input == EXIT_STRING goto SETUP_CALCULATE_SUM
    latest_number = user_input
    push numbers, latest_number
    goto GET_INPUT

  SETUP_CALCULATE_SUM:
    total = 0
    numbers_iterator = iter numbers

  CALCULATE_SUM:
    unless numbers_iterator goto CALCULATE_AVERAGE
    latest_number = shift numbers_iterator
    total += latest_number
    goto CALCULATE_SUM

  CALCULATE_AVERAGE:
    number_count = numbers
    average = total / number_count

  DISPLAY_VALUES:
    print &#34;Values entered: &#34;
    say number_count
    print &#34;Sum of values:  &#34;
    say total
    print &#34;Average:        &#34;
    say average

.end
</code></pre><p>All right. This example is easier for me to read than the others for some reason.
That could be due to the simple fact that I&rsquo;ve been looking at Parrot arrays for
a couple of hours now. Maybe it&rsquo;s because my blocks are more clearly labelled.
Maybe it&rsquo;s because using an iterator allowed me to build up a sum and still get
the length the length of <code>numbers</code> later, rather than building up two values
at the same time. I&rsquo;m not really sure. I do know that I feel like the iterator
has given me a nice little convenience layer for handling my array. The output
is still the same.</p>
<pre tabindex="0"><code>$ parrot example-05-07.pir
Enter a number (or &#34;quit&#34; to quit): 5
Enter a number (or &#34;quit&#34; to quit): 10
Enter a number (or &#34;quit&#34; to quit): 15
Enter a number (or &#34;quit&#34; to quit): 20
Enter a number (or &#34;quit&#34; to quit): quit
Values entered: 4
Sum of values:  50
Average:        12.5
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>We had already taken a glance at arrays when we worked with the command line. Today we dove a little deeper, looking into different ways we can access the contents of an array. Now you understand how to treat a &lsquo;ResizableFloatArray&rsquo; like a stack, a queue, a plain old array, or an iterable collection. These principles should work for other array types as well. Parrot has many array PMCs, and you can find them on the list of core PMCs <a href="http://docs.parrot.org/parrot/devel/html/pmc.html">here</a>.</p>

  






  <hr>
  

  
  
<hr>
<div class="footer">
    
      <p>Series: <a href="/series/parrot-babysteps">Parrot Babysteps</a></p>
    
    
      <a class="previous-post" href="https://randomgeekery.org/post/2009/09/perl-hacks-in-my-workspace/?ref=footer">
        <span style="font-weight:bold;">« Previous</span>
        <br>Perl Hacks In My Workspace
      </a>
    
    
      <div class="next-post">
        <a href="https://randomgeekery.org/post/2009/10/parrot-babysteps-06-files-and-hashes/?ref=footer">
          <span style="font-weight:bold;">Next »</span>
          <br>Parrot Babysteps 06 - Files and Hashes
        </a>
      </div>
    
</div>

  
</div>
            </main>
            
  
    <div class="article-toc ">
    <div class="toc-wrapper">
      <h4 id="contents"></h4>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#building-the-basic-flow">Building the Basic Flow</a></li>
    <li><a href="#averaging-with-no-arrays">Averaging With No Arrays</a></li>
    <li><a href="#stacks---pushing-and-popping">Stacks - Pushing and Popping</a>
      <ul>
        <li><a href="#shift-and-unshift---the-bottom-of-the-stack"><code>shift</code> and <code>unshift</code> - The Bottom of the Stack</a></li>
      </ul>
    </li>
    <li><a href="#queues">Queues</a></li>
    <li><a href="#accessing-by-index">Accessing by Index</a></li>
    <li><a href="#using-an-iterator">Using an Iterator</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
</div>

  

        </div><script defer data-domain="randomgeekery.org" src="https://plausible.io/js/script.js"></script>
    </body>
</html>
