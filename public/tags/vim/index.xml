<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>vimonRandom Geekery</title>
    <link>https://randomgeekery.org/tags/vim/</link>
    <description>
      Recent contentinvim on Random Geekery
    </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
      
      <lastBuildDate>Sat, 23 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://randomgeekery.org/tags/vim/index.xml" rel="self" type="application/rss+xml" /><item>
  <title>Post: Try Riv if you like Vim and reStructuredText</title>
  <link>https://randomgeekery.org/post/2021/10/try-riv-if-you-like-vim-and-restructuredtext/</link>
  <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
  
  <guid>https://randomgeekery.org/post/2021/10/try-riv-if-you-like-vim-and-restructuredtext/</guid>
  <description>Riv screenshot
Riv is a wiki, but feels like more of a notebook. Think Deft for Emacs with journaling and HTML publishing. What makes Riv interesting — aside from the Vim thing — is that it uses reStructuredText for its native format.
It works well enough, especially once you build up muscle memory for Riv’s leader sequence C-e. Don’t overload it right away though! It includes some insert mode mappings, which can get real confusing if your preferred leader is a space.</description>
   <category>post</category> 
   <category>note</category> 
   <category>vim</category>  <category>rst</category>  <category>second-brain</category> 
  <content:encoded><![CDATA[<p><img src="/post/2021/10/../../../attachments/img/2021/cover-2021-10-23.png" alt="attachments/img/2021/cover-2021-10-23.png"/>
Riv screenshot</p>
<p><a href="https://github.com/gu-fan/riv.vim">Riv</a> is a wiki, but feels like more of a notebook. Think <a href="https://jblevins.org/projects/deft/">Deft for Emacs</a> with journaling and HTML publishing. What makes Riv interesting — aside from the <a href="https://www.vim.org/">Vim</a> thing — is that it uses <a href="https://docutils.sourceforge.io/">reStructuredText</a> for its native format.</p>
<p>It works well enough, especially once you build up muscle memory for Riv&rsquo;s leader sequence <kbd>C-e</kbd>. Don&rsquo;t overload it right away though! It includes some insert mode mappings, which can get real confusing if your preferred leader is a space.</p>
<p>Meanwhile I got a lot of <a href="/card/neovim/">card/Neovim</a> ideas. Course, I need to get some more practice in with <a href="https://pynvim.readthedocs.io/en/latest/">pynvim</a> first. And I suppose some more practice with Riv.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: OrgMode-ish VimWiki</title>
  <link>https://randomgeekery.org/post/2020/07/orgmode-ish-vimwiki/</link>
  <pubDate>Fri, 03 Jul 2020 23:51:27 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2020/07/orgmode-ish-vimwiki/</guid>
  <description>I just wanted to see if I can something like the card/Org experience in card/Vim without vim-orgmode. I can. Sort of. Using Vimwiki with TaskWiki for Taskwarrior integration. Not appearing in this image: vim-table-mode. Appearing but not relevant to the Org-ish experiment is vim-which-key. Completely missing: any sort of Babel code evaluation/tangling.
That agenda-ish task list is real cool but needs to show more info, like tags.</description>
   <category>post</category> 
   <category>note</category> 
   <category>vim</category>  <category>taskwarrior</category>  <category>orgmode</category> 
  <content:encoded><![CDATA[<p><img src="/post/2020/07/../../../attachments/img/2020/cover-2020-07-03.png" alt="attachments/img/2020/cover-2020-07-03.png"/></p>
<p>I just wanted to see if I can something like the <a href="/card/org/">card/Org</a> experience in <a href="/card/vim/">card/Vim</a> without <a href="https://github.com/jceb/vim-orgmode">vim-orgmode</a>. I can. Sort of. Using <a href="https://vimwiki.github.io/">Vimwiki</a> with <a href="https://github.com/tbabej/taskwiki">TaskWiki</a> for Taskwarrior integration. Not appearing in this image: <a href="https://github.com/dhruvasagar/vim-table-mode">vim-table-mode</a>. Appearing but not relevant to the Org-ish experiment is <a href="https://github.com/liuchengxu/vim-which-key">vim-which-key</a>. Completely missing: any sort of <a href="https://orgmode.org/worg/org-contrib/babel/intro.html">Babel</a> code evaluation/tangling.</p>
<p>That agenda-ish task list is <em>real</em> cool but needs to show more info, like tags.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Showing Post Word Count in (neo)vim</title>
  <link>https://randomgeekery.org/post/2019/05/showing-post-word-count-in-neovim/</link>
  <pubDate>Sun, 05 May 2019 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2019/05/showing-post-word-count-in-neovim/</guid>
  <description>&lt;p&gt;A couple shell pipes. A little Vimscript. Now &lt;a href=&#34;https://randomgeekery.org/card/neovim/&#34;&gt;card/Neovim&lt;/a&gt; tells me (roughly) how many words my post has!&lt;/p&gt;</description>
   <category>post</category> 
   <category>post</category> 
   <category>vim</category>  <category>pandoc</category>  <category>programming</category> 
  <content:encoded><![CDATA[<p>A couple shell pipes. A little Vimscript. Now <a href="/card/neovim/">card/Neovim</a> tells me (roughly) how many words my post has!</p>
<p><img src="/post/2019/05/../../../attachments/img/2019/cover-2019-05-05.png" alt="attachments/img/2019/cover-2019-05-05.png"/></p>
<h2 id="my-problem">My problem</h2>
<p><a href="/post/2014/10/counting-words-in-blog-posts/">once again</a> I&rsquo;m trying to get myself to write more regularly. I post so much everywhere else. Surely I can spare a few hundred words a week on my blog, right?</p>
<p>Since I implied a number in that question, I have a metric I can use. Word count! Just write until I have 250 words, then post it. Or five hundred. Or a thousand. Whatever. I don&rsquo;t even need a concrete goal.  Seeing the number encourages me to type a little bit more.</p>
<p>But how to get the word count of a post? The approach I used a few years ago required enough extra thought that I eventually forgot all about it until editing this post!</p>
<p><a href="/card/hugo/">card/Hugo</a> includes word count and reading time in <a href="https://gohugo.io/variables/page/">page variables</a>, so I could put the variable in the post template, then keep the server running and browser open while I type. In fact, that&rsquo;s exactly what I&rsquo;ve been doing!</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&lt;p&gt;About {{ .Page.ReadingTime }} minutes to read ({{ .Page.WordCount }} words)&lt;/p&gt;</code></pre>
</figure><p>Honestly, this is cumbersome. I prefer something that doesn&rsquo;t require I have Hugo running. Sure, I enjoy previewing the site with live reload, but when I&rsquo;m writing my flow is interrupted by half my screen refreshing every few seconds.</p>
<p>Yes, I tend to save my work that often. You lose enough editing sessions and it
becomes a reflex.</p>
<p>Something <em>in</em> my editor would be better.</p>
<h2 id="a-solution">A solution</h2>
<p><a href="https://en.wikipedia.org/wiki/Wc_%28Unix%29"><code>wc</code></a> can count words, but hand it the file and it counts <em>everything</em>. I care about the prose and code examples. I don&rsquo;t want front matter, link URLs, or formatting artifacts included in the count.</p>
<p>What if I stripped the Markdown components out, leaving plain text? That&rsquo;s exactly what I want to count! Okay, so how do I go about that? I already know that I&rsquo;ll mess something up if I write my own solution. Maybe one of the tools I already use?</p>
<p>Let&rsquo;s see. My posts are formatted with <a href="https://mmark.nl/">mmark</a>, a Markdown parser with its own <a href="https://mmark.nl/">extensions</a> to the <a href="/card/markdown/">card/Markdown</a> foundation. Near as I can tell, mmark does not support generating plain text from its input.  But <a href="https://pandoc.org/">Pandoc</a> can. Pandoc can do anything. Except parse mmark.</p>
<p>Well maybe it could if I wrestled with the extensions a little. But I don&rsquo;t want to do that today. mmark can turn Markdown into HTML. Pandoc can turn HTML into plain text!</p>
<p>So. Have mmark turn the file into HTML, then have pandoc turn the HTML into text, and count the words of text produced.</p>
<p>We use pipes. Pipes everywhere.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mmark -html -fragment index.md | pandoc -f html -t plain | wc -w | tr -d &#39; &#39;
403</code></pre>
</figure><blockquote>
<p><strong>NOTE</strong></p>
<p>Found out that Hugo shortcodes look a lot like mmark includes, and that choked my pipes up a bit. Added an initial pass through Perl to remove anything that might be a shortcode. Confuses counting in a couple of my posts <em>about</em> Hugo, but I will survive.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">perl -pe <span class="s1">&#39;BEGIN{ undef $/ } s/\{\{&lt;.+?&gt;}}//gsm&#39;</span> <span class="s2">&#34; index.md \
</span></span></span><span class="line"><span class="cl"><span class="s2">  | mmark -html -fragment index.md \
</span></span></span><span class="line"><span class="cl"><span class="s2">  | pandoc -f html -t plain \
</span></span></span><span class="line"><span class="cl"><span class="s2">  | wc -w | tr -d &#39; &#39;</span></span></span></code></pre>
</figure></blockquote>
<p>I told mmark to generate a fragment of HTML rather than a complete HTML document, to reduce noise from things like a <code>&lt;title&gt;</code> tag.</p>
<p>Plus a little massaging by <code>tr</code> since <code>wc -w</code> had leading spaces in its output.</p>
<p>Naturally, Hugo reports a different number at this point: 397. You know what, though? I&rsquo;m not going to fuss about a small difference. If I was getting paid per word (or at all) for these posts, I might care more. Eventually I may dig into code and find out <em>why</em> they report different numbers. As it is, I am happy with the answers that pandoc + wc give me.</p>
<h3 id="how-to-get-vim-to-report-it">How to get Vim to report it</h3>
<p>So I know how to get the numbers I want. Now I must learn enough <a href="http://learnvimscriptthehardway.stevelosh.com/">Vimscript</a> to move that information from the shell to the status line.</p>
<blockquote>
<p><strong>WARNING</strong></p>
<p>I&rsquo;ve been using Neovim as my main terminal <code>$EDITOR</code>. Although it maintains compatibility with Vim, some of the functions here may require a newer release of Vim than you have on your machine.</p>
<p>The goal was to figure this out on my own machine, so unfortunately the only advice I can offer if your Vim complains is: upgrade Vim or switch to Neovim.</p>
</blockquote>
<p>Later I may expand this into a library function that understands about different content types. Right now it returns a formatted word count if the filetype of the current buffer is Markdown, and an empty string otherwise. That way there&rsquo;s <em>something</em> to put in the status line.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-vim" data-lang="vim"><span class="line"><span class="cl"><span class="k">function</span><span class="p">!</span> <span class="nx">MarkdownWordCount</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">let</span> <span class="nx">my_filetype</span> <span class="p">=</span> &amp;<span class="k">filetype</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">my_filetype</span> <span class="p">!=</span> <span class="s1">&#39;markdown&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">return</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="k">endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">let</span> <span class="nx">wordcount</span> <span class="p">=</span> <span class="nx">system</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        \ <span class="s2">&#34;perl -pe &#39;BEGIN{ undef $/ } s/\\{\\{&lt;.+?&gt;}}//gsm&#39; &#34;</span> . <span class="nx">bufname</span><span class="p">(</span><span class="s2">&#34;%&#34;</span><span class="p">)</span> .
</span></span><span class="line"><span class="cl">        \ <span class="s2">&#34; \| mmark -html -fragment&#34;</span> .
</span></span><span class="line"><span class="cl">        \ <span class="s2">&#34; \| pandoc -f html -t plain&#34;</span> .
</span></span><span class="line"><span class="cl">        \ <span class="s2">&#34; \| wc -w \| tr -d &#39; &#39;&#34;</span>
</span></span><span class="line"><span class="cl">        \ <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">return</span> <span class="s2">&#34;[wc:&#34;</span> . <span class="nx">trim</span><span class="p">(</span><span class="nx">wordcount</span><span class="p">)</span> . <span class="s2">&#34;]&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">endfunction</span></span></span></code></pre>
</figure><p>Look! Functions! For the full list of neovim&rsquo;s built-in functions, see <a href="https://neovim.io/doc/user/eval.html"><code>:help eval</code></a>. Let&rsquo;s just look at the ones I used.</p>
<ul>
<li><code>system</code> gets me the output of a shell command (with a little backslash escaping so my pipes work).</li>
<li><code>bufname</code> returns the filename for the requested buffer (<code>%</code> is Vim shorthand for &ldquo;the current buffer&rdquo;)</li>
<li><code>trim</code> gets rid of that pesky newline. Oh hey I bet it gets rid of the leading spaces, too. Might not need to <code>tr</code> the word count.</li>
</ul>
<p>Also, I want to keep it from counting words all the time. The piped commands are fast enough on my computer, but it just feels like wasted effort. Keep the word count and time of last check in buffer variables. Update the word count only if the file&rsquo;s been touched since the last check.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-vim" data-lang="vim"><span class="line"><span class="cl"><span class="c">&#34; Word Count for Markdown posts</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span><span class="p">!</span> <span class="nx">MarkdownWordCount</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">let</span> <span class="nx">my_filetype</span> <span class="p">=</span> &amp;<span class="k">filetype</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">my_filetype</span> <span class="p">!=</span> <span class="s1">&#39;markdown&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">return</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="k">endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">!</span><span class="nx">exists</span><span class="p">(</span><span class="s2">&#34;b:wc_last_checked_at&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">let</span> <span class="nx">b</span>:<span class="nx">wc_last_checked_at</span> <span class="p">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">  <span class="k">endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">let</span> <span class="nx">filename</span> <span class="p">=</span> <span class="nx">bufname</span><span class="p">(</span><span class="s2">&#34;%&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">let</span> <span class="nx">filetime</span> <span class="p">=</span> <span class="nx">getftime</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">!</span><span class="nx">exists</span><span class="p">(</span><span class="s2">&#34;b:wc_last_count&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">let</span> <span class="nx">b</span>:<span class="nx">wc_last_count</span> <span class="p">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">  <span class="k">endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">filetime</span> <span class="p">&gt;</span> <span class="nx">b</span>:<span class="nx">wc_last_checked_at</span>
</span></span><span class="line"><span class="cl">    <span class="k">let</span> <span class="nx">wordcount</span> <span class="p">=</span> <span class="nx">system</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          \ <span class="s2">&#34;perl -pe &#39;BEGIN{ undef $/ } s/\\{\\{&lt;.+?&gt;}}//gsm&#39; &#34;</span> . <span class="nx">filename</span> .
</span></span><span class="line"><span class="cl">          \ <span class="s2">&#34; \| mmark -html -fragment&#34;</span> .
</span></span><span class="line"><span class="cl">          \ <span class="s2">&#34; \| pandoc -f html -t plain&#34;</span> .
</span></span><span class="line"><span class="cl">          \ <span class="s2">&#34; \| wc -w&#34;</span>
</span></span><span class="line"><span class="cl">          \ <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">let</span> <span class="nx">b</span>:<span class="nx">wc_last_count</span> <span class="p">=</span> <span class="nx">trim</span><span class="p">(</span><span class="nx">wordcount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">let</span> <span class="nx">b</span>:<span class="nx">wc_last_checked_at</span> <span class="p">=</span> <span class="nx">localtime</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">endif</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">return</span> <span class="s2">&#34;[wc:&#34;</span> . <span class="nx">b</span>:<span class="nx">wc_last_count</span> . <span class="s2">&#34;]&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">endfunction</span></span></span></code></pre>
</figure><p>Hey, a couple new functions!</p>
<ul>
<li><code>getftime</code> tells me when the file was last modified</li>
<li><code>localtime</code> tells me what time it is now.</li>
</ul>
<p>Both of these time functions work in &ldquo;seconds since 1970-01-01.&rdquo; That&rsquo;s not unusual, but it does mean you&rsquo;d need to feed the values to <code>strftime</code> if you wanted human-readable times.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-vim" data-lang="vim"><span class="line"><span class="cl"><span class="c">&#34; Later, in my status line:</span>
</span></span><span class="line"><span class="cl"><span class="k">set</span> <span class="nx">statusline</span><span class="p">=</span>%<span class="nx">m</span>%<span class="nx">h</span>%<span class="nx">w</span><span class="p">&lt;</span>%<span class="nx">f</span><span class="p">&gt;</span>\ %<span class="p">=</span>%<span class="p">(</span>%{<span class="nx">fugitive</span>#<span class="nx">statusline</span><span class="p">()</span>}\ [%<span class="nx">Y</span>]%{<span class="nx">MarkdownWordCount</span><span class="p">()</span>}[%<span class="nx">l</span><span class="p">,</span>%<span class="nx">v</span>][%<span class="nx">p</span>%%]%<span class="p">)</span></span></span></code></pre>
</figure><p>Yeah, my status line is a little busy.</p>
<p>Anyways. It works! Is it perfect? Of course not. But it gives me the information I want, and that pleases me. On to the next task!</p>]]></content:encoded>
</item>
<item>
  <title>Post: Sticking with Vim</title>
  <link>https://randomgeekery.org/post/2006/02/sticking-with-vim/</link>
  <pubDate>Sun, 12 Feb 2006 00:00:00 -0800</pubDate>
  
  <guid>https://randomgeekery.org/post/2006/02/sticking-with-vim/</guid>
  <description>I’ve been experimenting with several excellent editors for Windows, including UltraEdit and Crimson Editor. The experiments will continue, but for now I am going to stick to a Windows install of Vim. Becoming familiar with Windows doesn’t mean I have to drop everything I already know in the dust!</description>
   <category>post</category> 
   <category>post</category> 
   <category>43-things</category>  <category>vim</category>  <category>editors</category>  <category>blogspot</category> 
  <content:encoded><![CDATA[<p>I&rsquo;ve been experimenting with several excellent editors for Windows, including <a href="http://www.ultraedit.com">UltraEdit</a> and <a href="http://www.crimsoneditor.com">Crimson Editor</a>. The experiments will continue, but for now I am going to stick to a Windows install of <a href="/card/vim/">Vim</a>. Becoming familiar with Windows doesn&rsquo;t mean I have to drop everything I already know in the dust!</p>
]]></content:encoded>
</item>
</channel>
</rss>
