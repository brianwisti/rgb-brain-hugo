<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>learnonRandom Geekery</title>
    <link>https://randomgeekery.org/tags/learn/</link>
    <description>
      Recent contentinlearn on Random Geekery
    </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
      
      <lastBuildDate>Mon, 11 Jul 2016 00:00:00 -0700</lastBuildDate><atom:link href="https://randomgeekery.org/tags/learn/index.xml" rel="self" type="application/rss+xml" /><item>
  <title>Post: Hello Dancer2</title>
  <link>https://randomgeekery.org/post/2016/07/hello-dancer2/</link>
  <pubDate>Mon, 11 Jul 2016 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2016/07/hello-dancer2/</guid>
  <description>The PerlDancer team’s Dancer2 project is a card/Perl framework for writing Web applications with less boilerplate code than other Web frameworks. I am slowly exploring what it offers. Feel free to follow along.
This is sort of a tutorial. I assume you know Perl and maybe a bit about Web server programming, but not that you have mastered either. My pace may annoy you if you have mastered Perl, Web programming, or Dancer2.</description>
   <category>post</category> 
   <category>post</category> 
   <category>perl</category>  <category>dancer</category>  <category>learn</category>  <category>programming</category> 
  <content:encoded><![CDATA[<h2>Some simple first steps with the Perl 5 Dancer2 web framework</h2><p>The <a href="https://github.com/PerlDancer/">PerlDancer</a> team’s <a href="https://metacpan.org/pod/Dancer2">Dancer2</a> project is a <a href="/card/perl/">card/Perl</a> framework for writing Web applications with less <a href="https://en.wikipedia.org/wiki/Boilerplate_code">boilerplate code</a> than other Web frameworks. I am slowly exploring what it offers. Feel free to follow along.</p>
<p>This is sort of a tutorial. I assume you know Perl and maybe a bit about Web server programming, but not that you have mastered either. My pace may annoy you if you <em>have</em> mastered Perl, Web programming, or Dancer2.</p>
<h2 id="installation">Installation</h2>
<p>I use Perl 5.24.0 and <a href="https://metacpan.org/pod/App::cpanminus">cpanm</a> via <a href="http://perlbrew.pl/">Perlbrew</a>. Installation of Dancer2 and its dependencies requires a single command.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ cpanm Dancer2</code></pre>
</figure><h2 id="hey">Hey</h2>
<p>You do not need much code to create a Dancer2 application.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Dancer2</span><span class="p">;</span>     <span class="c1"># Load Dancer2 and its keywords</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">get</span> <span class="s">&#39;/hey&#39;</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="c1"># Define some routes</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s">&#39;Hey!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">start</span><span class="p">;</span>           <span class="c1"># Run the application</span></span></span></code></pre>
</figure><p>Even better: you can hand this code to Perl and it starts a server!</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ perl hey.pl
&gt;&gt; Dancer2 v0.200002 server 15388 listening on http://0.0.0.0:3000</code></pre>
</figure><p>Loading <code>http://localhost:3000/hey</code> in a browser shows our simple message.</p>
<p><figure>
    <img src="/attachments/img/2016/dancer2-hey.png" title="Hey from Dancer2!" alt="Hey from Dancer2"/><figcaption>Hey from Dancer2!</figcaption></figure></p>
<p>Dancer2 gives you a <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> — Domain-Specific Language — to describe your application. These DSL <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#DSL-KEYWORDS">keywords</a> cut down the boilerplate code common in some Web development frameworks.</p>
<h3 id="get"><code>get</code></h3>
<p>The <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#get">get</a> keyword defines a <a href="https://metacpan.org/pod/Dancer2::Core::Route">route</a> for Dancer2. Routes tell Dancer2 how to respond when someone requests a path — the /hey bit — from your application. <code>get</code> is also a method from <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a>. Use it when you only want to &ldquo;get&rdquo; something from the application. Dancer2 has keywords for more HTTP methods, but <code>get</code> is fine for now.</p>
<p>What happens if someone requests a path that you did not define?</p>
<p>Your Dancer2 application returns an error page informing them that the path does not exist.</p>
<p>With the HTTP method and path defined, the last important part of our route is the code. Your application runs that code and sends its return value to the visitor. Our first route code example is an anonymous subroutine that returns the text &ldquo;Hello!&rdquo;, but they can be as complicated as you need.</p>
<h3 id="start"><code>start</code></h3>
<p><a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#start">start</a> tells Dancer2 that you finished defining your application and it can begin serving to the world.</p>
<p>DSL = Keywords + Sugar</p>
<p>Keywords make the Dancer2 DSL work, but the code style takes advantage of Perl’s flexible syntax. Our route looks like this with less <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a>.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">get</span><span class="p">(</span><span class="s">&#39;/hey&#39;</span><span class="p">,</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#39;Hey!&#39;</span><span class="p">;</span> <span class="p">});</span></span></span></code></pre>
</figure><h2 id="hey-you">Hey You</h2>
<p>How about greeting the visitor by name? Since form processing involves more steps than I want to think about today, we use route parameters instead.</p>
<p>Dancer2 allows placeholders in route paths. The simplest placeholders are tokens prefixed with a colon, such as <code>:name</code> or <code>:id</code>. When you make a request that matches, such as <code>/hey/brian</code>, Dancer2 saves the matching path part. Here, look at some code.</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Dancer2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># A simple greeting: /hey</span>
</span></span><span class="line"><span class="cl"><span class="n">get</span> <span class="s">&#39;/hey&#39;</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s">&#39;Hey!&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># A personalized greeting: /hey/Brian</span>
</span></span><span class="line"><span class="cl"><span class="n">get</span> <span class="s">&#39;/hey/:name&#39;</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="nn">route_parameters</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s">&#34;Hey $name!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">start</span><span class="p">;</span></span></span></code></pre>
</figure><p>Route handlers can get <a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#Route-Handlers">much more complicated</a>, but not today. Our application treats a general greeting and a greeting with a distinct name at two different actions, so we use two different routes.</p>
<p>In order to use the new code, we need to stop the Perl process. <code>Control-C</code> should do it. Then launch it again, and the new code will be loaded.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ perl hey.pl
&gt;&gt; Dancer2 v0.200002 server 31385 listening on http://0.0.0.0:3000</code></pre>
</figure><p>Now we should be able to see <a href="http://localhost:3000/hey/Brian">http://localhost:3000/hey/Brian</a> — or whatever name you prefer.</p>
<p><figure>
    <img src="/attachments/img/2016/dancer2-hey-brian.png" alt="&ldquo;Hey Brian!&rdquo; in Dancer2"/></figure></p>
<h3 id="route_parameters"><code>route_parameters</code></h3>
<p><a href="https://metacpan.org/pod/distribution/Dancer2/lib/Dancer2/Manual.pod#route_parameters">route_parameters</a> returns a <a href="https://metacpan.org/pod/Hash::MultiValue">hash-like object</a> which stores tokens and their values from a route match. Use the <code>get</code> method when you need those values in your route code.</p>
<h2 id="wrap-it-up">Wrap It Up</h2>
<p>We installed Dancer2, made just about the simplest Web application I could think of, and explored a little bit about declaring routes.</p>
<p>What’s next? I plan to look at using template files to produce real Web pages.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Python 2 Babysteps 01 Installing Python 2</title>
  <link>https://randomgeekery.org/post/2011/06/python-2-babysteps-01-installing-python-2/</link>
  <pubDate>Thu, 16 Jun 2011 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2011/06/python-2-babysteps-01-installing-python-2/</guid>
  <description>Installation You need to get Python before you can use Python. There are many versions available, such as ActivePython, Jython, and IronPython. They each offer distinct advantages. ActivePython offers commercial support. Jython runs on the Java platform, providing access to the underlying JVM and many support libraries. IronPython runs on the .NET and Mono platforms, providing access to their underlying virtual machine and support libraries.
I decided to focus on the official release of Python rather than get overwhelmed by choice.</description>
   <category>post</category> 
   <category>post</category> 
   <category>python</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<h2>Think of it as Step Zero for the other Python tutorials.</h2><h2 id="installation">Installation</h2>
<p>You need to <em>get</em> <a href="/card/python/">Python</a> before you can <em>use</em> Python. There are many versions available, such as <a href="http://www.activestate.com/activepython">ActivePython</a>, <a href="http://jython.org/">Jython</a>, and <a href="http://www.codeplex.com/wikipage?ProjectName=IronPython">IronPython</a>. They each offer distinct advantages. ActivePython offers commercial support. Jython runs on the <a href="http://www.java.com/en/">Java</a> platform, providing access to the underlying JVM and many support libraries. IronPython runs on the <a href="http://www.microsoft.com/NET/">.NET</a> and <a href="http://www.mono-project.com/Python">Mono</a> platforms, providing access to <em>their</em> underlying virtual machine and support libraries.</p>
<p>I decided to focus on the official release of Python rather than get overwhelmed by choice. You can probably follow along if you decide to install an alternate Python. I will provide notes where I can, but cannot make any guarantees about their accuracy. Check the documentation for your Python choice.</p>
<h3 id="why-not-python-3">Why Not Python 3?</h3>
<p>Python 3 has been available for a while now, and is actually up to <a href="http://python.org/download/releases/3.2/">Python 3.2</a>. Why don’t I cover it in this Babystep? I would rather talk about the newest Python release. but that’s impractical. Many widely used libraries have not been updated so that they are compatible with the Python 3 series. Although the differences between Python 2 and Python 3 are small, they add up for large projects like <a href="http://djangoproject.com">Django</a>. I want you to be able to use your Python skills right away.</p>
<p>Fortunately, the Python developers continue to support the 2.x line, and continue to release versions with fixes and new features for Python 2. If you started learning Python 2 today, it would continue to be useful for quite some time.</p>
<h3 id="os-x">OS X</h3>
<p>You must install the Xcode and Developer Tools to get the full usage out of Python on OS X, although I will not be spending any time in the XCode environment. The Developer Tools should have come with your installation kit. If not, they are available online.</p>
<p>OS X 10.6 includes Python 2.6.1, which is probably good enough for our purposes. I like having the latest version of a language, though.</p>
<h4 id="just-download-it">Just Download It</h4>
<p>If you are using a version of OX X older than 10.6, or you don’t care about 64 bit functionality, just grab the <a href="http://python.org/ftp/python/2.7.2/python-2.7.2-macosx10.3.dmg">Mac OS X 32-bit i386/PPC</a> installer and skip to &ldquo;Installing Python From the Disk Image&rdquo;.</p>
<p>Python uses <a href="http://www.tcl.tk/">TCL/Tk</a> for its default graphical development environment IDLE. These Python Babysteps assume that we will be using IDLE. Since there are <a href="http://www.python.org/download/mac/tcltk/">cautionary notes</a> about using IDLE with Apple’s default TCL, we will heed those notes and grab our own copy of <a href="http://www.activestate.com/activetcl">ActiveTcl</a>. We can just grab the <a href="http://www.activestate.com/activetcl/downloads">current ActiveTcl download</a>.</p>
<p>Opening the ActiveTCL disk image in the Finder will present us with an installer called <code>ActiveTCL-8.5.pkg</code>. Double-click that package file to start the installer and accept its defaults.</p>
<p>Right. Now you have ActiveTCL installed. Eject the ActiveTCL disk image whenever you like.</p>
<aside class="admonition note">
<p class="admonition-title">Note</p>
<p>All of this is unnecessary to play with Python in general. These steps just make it possible for us to take advantage of the full 64 bit functionality of OS X, using the latest Python release and IDLE. Feel free to skip the ActiveTCL download if you do not want to use IDLE.</p>
</aside>
<p>Now that we have the right TCL/Tk installed (or have decided that we don’t care), go to the download page for <a href="http://python.org/download/releases/2.7.2/">Python 2.7.2</a> and grab the <a href="http://python.org/ftp/python/2.7.2/python-2.7.2-macosx10.6.dmg">Mac OS X 64-bit/32-bit Installer</a>.</p>
<h4 id="installing-python-from-the-disk-image">Installing Python From the Disk Image</h4>
<p>Open the image and double click <code>Python.mpkg</code> to run the installation. The default settings should be good enough.</p>
<p>Well that wasn’t hard. Okay, there were a few details if you insisted on the latest and greatest.</p>
<h4 id="macports">MacPorts</h4>
<p>On my home machine, I use <a href="http://macports.org">MacPorts</a> to access a large repository of open source software that can be installed on OS X. Although <a href="http://www.macports.org/install.php">installing MacPorts</a> is not difficult, it is well beyond the scope of this tutorial. I will instead show you the commands I ran from a Terminal to install Python 2.7 on that machine.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sudo port install python-2.7
$ sudo port select python python-2.7
$ python -V
Python 2.7.1</code></pre>
</figure><p>That will do. The differences between 2.7.1 and 2.7.2 are so small that I doubt I will notice any of them.</p>
<h4 id="homebrew">Homebrew</h4>
<p>And some of you use <a href="http://mxcl.github.com/homebrew/">Homebrew</a> to install open source software. No problem. Here are the instructions for installing and verifying a fresh Python once you <a href="https://github.com/mxcl/homebrew/wiki/Installation">install Homebrew</a>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ brew install python
$ python -V
Python 2.7.2</code></pre>
</figure><h3 id="linux">Linux</h3>
<p>Python is well supported in Linux.</p>
<h4 id="redhat-based-distributions-fedora">Redhat-based distributions (Fedora)</h4>
<p><a href="http://fedoraproject.org">Fedora</a> 15 ships with Python 2.7.1, and that is good enough for me. We need to install the <code>python-tools</code> package if we want IDLE, though.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ su -
# yum install python-tools</code></pre>
</figure><h4 id="debian-based-distributions-ubuntu-mint">Debian-based Distributions (Ubuntu, Mint)</h4>
<p><a href="http://ubuntu.com">Ubuntu</a> 11.04 has Python 2.7.1 installed by default, and that’s good enough for us.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ python -V
Python 2.7.1&#43;</code></pre>
</figure><p>I am not sure what the <code>+</code> means. I assume the Ubuntu developers made some customizations to Python.</p>
<p>IDLE is not installed by default, though. That can be fixed.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ sudo apt-get install idle</code></pre>
</figure><h4 id="others">Others</h4>
<p>Check the documentation for your distribution. The odds are that you already have Python installed, or can easily install it using your distribution’s tools.</p>
<h3 id="windows">Windows</h3>
<p>I do not have a Windows installation handy right now, so most of this section is just going from memory. Thank goodness installation on Windows is easy.</p>
<p>You can always find links to download the latest version of Python at the Python site itself:</p>
<blockquote>
<p><a href="http://www.python.org/download">http://www.python.org/download</a></p>
</blockquote>
<p>Somewhere around the top of the page is a link to the latest version. Look for the first version that doesn’t have &ldquo;alpha&rdquo;, &ldquo;beta&rdquo;, or &ldquo;release candidate&rdquo; in its name. Follow that link, which is currently:</p>
<ul>
<li><a href="http://python.org/ftp/python/2.7.1/python-2.7.1.msi">http://python.org/ftp/python/2.7.1/python-2.7.1.msi</a> for 32-bit   Windows, and</li>
<li><a href="http://www.python.org/ftp/python/2.7.1/python-2.7.1.amd64.msi">http://www.python.org/ftp/python/2.7.1/python-2.7.1.amd64.msi</a> for 64-bit Windows installations</li>
</ul>
<p>The kind folks who run the python.org site make sure there are links to the latest Windows Python 32 bit download from their <a href="http://python.org">front page</a>. Look on the left side of the page for <em>&ldquo;Quick Links &raquo; Windows Installer&rdquo;</em>.</p>
<p>Windows will ask you if you want to save the file or run it directly from the site. That’s up to you. If you have the disk space, and know how to find and run a file on your hard drive, I recommend you save the installer program to disk. That way you can redo an installation you messed up. On the other hand, if you don’t have much space on the computer, or you aren’t sure how to find a file once you’ve save it, you are probably better off opening the file straight from the site. I have screwed up so many installations that I pretty much automatically select &ldquo;Save&rdquo; when downloading an installer.</p>
<p>Once you have downloaded the installer, you need to run it. If you told Windows that you wanted to open it from the current location, you can skip this step. Otherwise, you will need to find your file. You will probably find it in &ldquo;Downloads&rdquo;, within the &ldquo;My Documents&rdquo; section of the computer. Dig or search in your hard drive until you find the installer executable, named <code>Python-2.7.1.msi</code>. Double-click the icon to run the program, and you are on your way to installing Python!</p>
<p>I’m going to skim through the next bit here, because most of the installation is   imply &ldquo;Do you want me to install Python in folder X?&rdquo; and &ldquo;Do you want me to call it Python?&rdquo; Most of the options you can safely run through by clicking &ldquo;Next&rdquo;, but stay alert for anything that you might want different from the defaults.</p>
<p>Eventually, you are presented with a little progress bar while the installer puts all of the Python files where they belong. This is the stage where you sip some coffee (or tea, or soda) and dream about all the great things you will be able to do as a programmer.</p>
<p>Guess what? You are now a proud owner of Python 2! All that’s left is learning how to program.</p>
<h3 id="building-from-source">Building From Source</h3>
<p>And if you are feeling bold, you can grab the <a href="http://python.org/ftp/python/2.7.2/Python-2.7.2.tar.bz2">source distribution</a> and build your own copy. It is not difficult, but will require installing different tools on different machines. Go right ahead and do this if you want to. The instructions within the source distribution are clear enough. I am not going to build my own copy. I have installed Python four times today, and frankly that is enough.</p>
<p>It is time to get acquainted with this new language.</p>
<h2 id="using-python">Using Python</h2>
<p>There are already a lot of online tutorials for learning Python. Maybe that’s because Python is as fun to teach as it is to learn. Anyways, I am not going to try and tell you that <em>my</em> rough little Web site has the best introduction you’ll ever find.</p>
<p>You can pick and choose from links at the Python <a href="http://wiki.python.org/moin/BeginnersGuide">BeginnersGuide wiki page</a>.</p>
<p>That page has links to articles which discuss Python, tutorials, and comparisons to other languages. Python was largely written for educational environments: learning how to do things &ldquo;the Python way&rdquo; makes it easier to write clean, readable programs for any language. Plus, its flexibility makes it useful way past the classroom — unlike the stuff like Applesoft BASIC that <em>I</em> learned in class. There is nothing like spending years trying to forget what BASIC taught me about
programming.</p>
<p>Even though those links will teach you about how to program in Python, I ask you to stick with me a little bit longer. I still have to tell you how to get started with the tools that you just installed.</p>
<p>I will be focussing on IDLE — and the simple stuff — at that. You can just as easily use PythonWin or the Python shell, which you get into from the console by typing python.</p>
<p>IDLE is Python’s Integrated DeveLopment E&gt;nvironment. It’s just a coincidence that the acronym <em>happens</em> to spell out the last name of one of the members of a British comedy troupe — whose name just <em>happens</em> to contain the word &ldquo;Python&rdquo;. That’s right, just a coincidence. <em>Wink wink, nudge nudge</em></p>
<p>IDLE gives you access to everything you need to write Python code in a graphical pointy-clicky environment like Windows. There’s a version of the Python shell, as well as features allowing you to write, save, and run your own Python programs with ease.</p>
<p>You can find some information about IDLE at its <a href="http://docs.python.org/library/idle.html">documentation page</a>.</p>
<p>In the next couple of sections, I will help you with the basics of using IDLE. We’ll use the shell for some simple code, then make and run our own little Python script. That’s right, you’ll be creating your own programs within the next few minutes.</p>
<h2 id="how-to-use-idle">How to use IDLE</h2>
<p>Starting IDLE under Windows is a matter of finding it in your Start menu.</p>
<ol>
<li>Find the Python folder in your Start menu.</li>
<li>Find the menu item for IDLE within the Python folder.</li>
<li>Select it.</li>
</ol>
<p>On Windows Vista and Windows 7, you can launch IDLE by entering &ldquo;idle&rdquo; in the Start Menu search field and selecting the program when it appears in search results.</p>
<p>Given the wide, wild range of desktop environments available for Linux, there is no way I could simply tell you which menu option runs IDLE. Instead, you get these instructions:</p>
<ol>
<li>Open a terminal (XTerm, Konsole, Gnome Terminal … whatever)</li>
<li>In the terminal, type <code>idle[ENTER]</code></li>
</ol>
<p>If you happen to have IDLE in your environment’s equivalent of a Start menu, then you can just use that. It’s in the &ldquo;Programming&rdquo; group on Ubuntu.</p>
<p>IDLE will start with something that looks like some sort of command line interface (kind of like a colorful DOS box or XTerm). That is the shell, and it allows you to perform the next step:</p>
<h3 id="using-the-idle-shell-writing-code">Using the IDLE Shell (<em>Writing Code!</em>)</h3>
<p>Let’s see, how do we run Python code in the IDLE shell?</p>
<ol>
<li>Type it in and watch it go!</li>
</ol>
<p>Hmm… maybe a <em>little</em> more detail would be helpful here.</p>
<p>The IDLE shell allows you to enter code (from simple statements to function and class definitions), and execute it immediately. Since you have the shell open already, type in this example:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&gt;&gt;&gt; print &#34;Hello, world!&#34;</code></pre>
</figure><p><figure>
    <img src="/attachments/img/2011/idle.png" alt="IDLE screenshot"/></figure></p>
<p>The <code>&gt;&gt;&gt;</code> is the shell prompt, showing that you can type something here. You may notice that the characters you type show up in different colors as you enter them into the shell. This is called &ldquo;syntax highlighting.&rdquo; It’s basically just the environment helping you out so that you know more or less how the code will be broken down by Python (important <em>keywords</em> are one color, <em>strings</em> of text are another, etcetera).</p>
<p>Press the ENTER key, and the shell will perform that command right away:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&gt;&gt;&gt; print &#34;Hello, world!&#34;
Hello, world!</code></pre>
</figure><p>The shell allows you to define more complex things, too. Say you want to get the user’s name, and print a customized &ldquo;Hello you!&rdquo; for the user.</p>
<p>First, you have to get their name:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&gt;&gt;&gt; name = raw_input(&#34;Please enter your name: &#34;)</code></pre>
</figure><p><code>raw_input()</code> is a function that displays a prompt to the user, gets some keyboard input from them, and sends what they typed back to you. I want to use that typed-in name in a moment, so I save the result in the variable <code>name</code>. A <em>variable</em> is basically just something you want the computer to remember so that you can use it later. What’s a <em>function</em>? Basically, it’s something you feed data into, and get data out of — kind of a mini-program in your program. That’s all we need to know for right now.</p>
<p>When you press <code>[ENTER]</code> this time, you will be shown a prompt. In IDLE, this prompt shows up simply as some text printed out in the shell.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&gt;&gt;&gt; name = raw_input(&#34;Enter your name: &#34;)
Enter your name:</code></pre>
</figure><p>I provide my name (&ldquo;Brian&rdquo;), and Python quietly saves that answer in the variable <code>name</code>, then waits for me to do something new. One of the things that confused me when I first tried <code>raw_input()</code> in the Python shell: how do I know that Python actually grabbed the name I gave? Well, it turns out that it’s easy enough to ask:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&gt;&gt;&gt; print name
Brian</code></pre>
</figure><p>When you want to get at a value that Python has stored for you, all you have to do is call it by name. In this case, I just wanted to print out the value of <code>name</code> — which was filled in when I typed my name at the prompt — and that’s exactly what I told Python to do. Pretty simple, yes?</p>
<p>Okay, so it has my name. What was I trying to do again? Oh yeah, the custom &ldquo;Hello&rdquo; thing. Let’s make it print &ldquo;Hello, Brian&rdquo; - or &ldquo;Craig&rdquo;, or &ldquo;Susan&rdquo;, or whatever name you gave to <code>raw_input()</code> …​ ummm …​ I lost myself again. Let me get back on track here.</p>
<p>Wait. How are we supposed to do this? You know, take a value, and write it along with some other text?</p>
<p>Here’s the easiest way:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&gt;&gt;&gt; print &#34;Hello&#34;, name
Hello Brian</code></pre>
</figure><p>Every time you normally tell Python to print something, it will print that something out, and then start a new line. If you paste a comma onto the end of the thing you want to print, it’s just like a comma in conversation. It means that you’re pausing for air, and the sentence isn’t done yet. Instead of starting a new line, Python just inserts a space. The next thing that gets printed will show up on the same line.</p>
<p>In this case, Python prints the phrase &ldquo;Hello&rdquo;, followed by a space, and ending with the name that was given to it by <code>raw_input</code>.</p>
<p>You can print several things at once, too. Just put a comma in between each item to be printed.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&gt;&gt;&gt; print &#34;Hello&#34;, name, &#34;- good to see you!&#34;
Hello Brian - good to see you!</code></pre>
</figure><p>Wow. That made me feel pretty good. It’s amazing how just a few nice words can lift your mood — even if you have to write them yourself.</p>
<p>What if we wanted to be able to get that warm fuzzy feeling any time? It’s only two lines of code. We could probably enter that in the shell when we wanted some warm words. But there’s a school of programming that tells us Laziness is a virtue. Why write the same two lines again and again, when we could write them once, call it a program, and run that program anytime we felt blue?</p>
<p>Let’s find out how to do just that.</p>
<h2 id="how-to-make-your-own-python-program">How to Make Your Own Python Program</h2>
<p>Even though the IDLE shell is pretty neat, and <em>very</em> useful for figuring out whether a code idea will work, it’s not any good for actual programs.</p>
<p>Don’t get all huffy. I said the IDLE <em>shell</em> wasn’t good for programs, not that <em>IDLE</em> is no good for programs.</p>
<p>To edit a Python script in IDLE, simply go to the &ldquo;File&rdquo; menu and select &ldquo;New Window&rdquo;. This will open a new window for editing Python stuff. This is not a shell, but a NotePad-like text editing environment.</p>
<p>In your new window, enter this code:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># hello.py
#  Get the user&#39;s name and print a friendly hello
name = raw_input(&#34;Please enter your name: &#34;)
print &#34;Hello&#34;, name, &#34;- good to see you!&#34;</code></pre>
</figure><p>Most of it is the same as what we entered in the shell, but what’s with those first couple of lines?</p>
<p>Well, they’re Python comments. Comments start from the character <code>#</code>, and extend to the end of the line that you wrote them on. Python ignores comments, which means that you can use them to explain what is going on in your code. Comments are good. When you come back to look at a complex script after several months, you might forget what some block of code does. Having the comments there to remind you will make it that much easier to sort everything out.</p>
<p>I like to start every one of my scripts off with a quick header to describe the purpose of the program. Here is the rough template:</p>
<p>Python docstrings would actually be better for script headers, but:</p>
<ol>
<li>I haven’t described those yet</li>
<li>I needed an excuse to show you what comments look like.</li>
</ol>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># filename</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  A quick description of what this program does</span></span></span></code></pre>
</figure><p>Of course, your header can be as complicated as you like:</p>
<figure class="highlight">
  <pre tabindex="0" class="chroma"
    ><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># # # # # # # #</span>
</span></span><span class="line"><span class="cl"><span class="c1"># hello.py</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  Get the user&#39;s name and print a friendly hello</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># AUTHOR</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  Brian Wisti (brianwisti@pobox.com)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># DATE</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  26 December 2008</span>
</span></span><span class="line"><span class="cl"><span class="c1"># VERSION</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  1.1</span>
</span></span><span class="line"><span class="cl"><span class="c1"># PURPOSE</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  Demonstration script for my python tutorial at</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  http://www.coolnamehere.com/geekery/python/pythontut.html</span>
</span></span><span class="line"><span class="cl"><span class="c1"># USAGE</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  python hello.py</span>
</span></span><span class="line"><span class="cl"><span class="c1"># LICENSE</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  You may copy and redistribute this program as you see fit, with no</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  restrictions.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># WARRANTY</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  This program comes with NO warranty, real or implied.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># HISTORY</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  1.0 19 January 2001</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    Initial release for Python Babysteps Tutorial</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  1.1 26 December 2008</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    Updated for Python version 2.6</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  1.2 16 June 2011</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    Updated for Python version 2.7.2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># # # # # # # #</span></span></span></code></pre>
</figure><p>Just try to match the header complexity to the program. Using this header for a program that consists of two lines of code might be a <em>little</em> bit of overkill. I usually start with something like the two-line header and expand it as I see fit.</p>
<p>After you enter your script, you need to save it. That’s easy. Just go to the &ldquo;File&rdquo; menu and select &ldquo;Save As…​&rdquo; You will be shown a dialog that should look pretty familiar if you’ve ever worked with an editing program. Choose a directory to place your program, enter a name ending with <code>.py</code> to let your computer know that this is a Python file, and click &ldquo;Save&rdquo;. You have now saved your file.</p>
<p>I bet you’re just itching to run that program! Since you’ve already got <code>hello.py</code> open, all you have to do is go to the &ldquo;Run&rdquo; menu, and select &ldquo;Run module&rdquo;. Python puts you in the IDLE shell, where you see something like this:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >Python 2.7.1 (r271:86832, Nov 27 2010, 18:30:46) [MSC v.1500 32 bit (Intel)] on win32
Type &#34;copyright&#34;, &#34;credits&#34; or &#34;license()&#34; for more information.
&gt;&gt;&gt; ================================ RESTART ================================
&gt;&gt;&gt;
Please enter your name:</code></pre>
</figure><p>Enter your name, press ENTER, and there’s your warm fuzzy greeting!</p>
<p>You may be happy with <code>hello.py</code> right now, but you will probably want to change it later: make it print out a different greeting, for example. To do that, you need to know how to open a Python file for editing.</p>
<p>Actually, it’s pretty easy. Go to the &ldquo;File&rdquo; menu, select &ldquo;Open…​&rdquo; and select your file. IDLE automatically opens your file in an editing window, where you can edit, save, and run your program to your heart’s content.</p>
<p>There are two more ways to run a Python program in Windows.</p>
<p>The Python installation automatically associates the <code>py</code> extension with Python program. That tells Windows that anything ending with <code>.py</code> should be handed over to Python. That means you can just double-click on hello.py, and Python will automatically run it. Unfortunately, that’s not very helpful for most of the stuff we’ll be writing. Try it yourself. You get a DOS box prompting you for your name, but the box disappears almost as soon as you press ENTER! That is kind of annoying.</p>
<p>But there’s another trick which we can use until we’re writing more complex applications which can keep themselves open or don’t need a DOS box. Simply open your own DOS box (&lsquo;Start MenuAccessories|Command Prompt&rsquo;), move to the directory that contains your script, and call Python yourself:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >C:&gt;cd scripts
C:\scripts&gt;python hello.py
Please enter your name: Brian
Hello Brian - good to see you!
C:\scripts&gt;</code></pre>
</figure><p>In order for this to work, you’ll have to have your Python installation directory specified as part of your environment variable <code>PATH</code>. How you do that depends on what version of Windows (or which command line shell for Linux) you are running. Once again, I’m lazy, so I’m leaving it alone.</p>
<p>To be honest, I recommend you stick with IDLE interface for now. There is less to remember.</p>
<p>Finally, you might want to know how to <em>leave</em> IDLE. The menu command &lsquo;File|Exit&rsquo; is all you need to remember. If you haven’t saved all of the files you have been editing, IDLE will check if you want to save them before you quit. Answer as you see fit, save any files you want, and you’re out of IDLE in the real world.</p>
<p>And you know what? You know how to use the IDLE shell, as well as how to
edit, save, and run your very own Python scripts. You’re a programmer
now! Okay, there’s still plenty more to learn, but you are ready to
start exploring.</p>
<h2 id="what-next">What Next?</h2>
<p>This was just the quickest introduction to Python. Hopefully you are warmed up and ready for more. Now you should start one of the recommended tutorials at the <a href="http://wiki.python.org/moin/BeginnersGuide">Python BeginnersGuide</a>.</p>
<p>I have a few favorites of my own.</p>
<ul>
<li>The Official Python Tutorial
<a href="http://docs.python.org/tutorial/">http://docs.python.org/tutorial/</a></li>
<li>Dive Into Python
<ul>
<li><a href="http://www.diveintopython.net/">http://www.diveintopython.net/</a></li>
<li><a href="http://www.diveintopython3.net/">http://www.diveintopython3.net/</a></li>
</ul>
</li>
<li>How To Think Like a Computer Scientist In Python
<a href="http://openbookproject.net/thinkcs/python/english2e/">http://openbookproject.net/thinkcs/python/english2e/</a></li>
</ul>
<h3 id="quick-reference-using-idle">Quick Reference: Using IDLE</h3>
<table>
<thead>
<tr>
<th>To Do This…</th>
<th>Use This Menu Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start IDLE</td>
<td>&ldquo;Start/Programs/Python 2.7/IDLE (Python GUI)&rdquo;</td>
</tr>
<tr>
<td>Edit a New Python File</td>
<td>&ldquo;File/New Window&rdquo;</td>
</tr>
<tr>
<td>Save a New Python File</td>
<td>&ldquo;File/Save As…&rdquo;</td>
</tr>
<tr>
<td>Open a Python File</td>
<td>&ldquo;File/Open&rdquo;</td>
</tr>
<tr>
<td>Save a Python File</td>
<td>&ldquo;File/Save&rdquo;</td>
</tr>
<tr>
<td>Run your script in IDLE</td>
<td>&ldquo;Run/Run Module&rdquo;</td>
</tr>
<tr>
<td>Quit IDLE</td>
<td>&ldquo;File/Exit&rdquo;</td>
</tr>
</tbody>
</table>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 0e - Parrot Namespaces</title>
  <link>https://randomgeekery.org/post/2010/10/parrot-babysteps-0e-parrot-namespaces/</link>
  <pubDate>Mon, 11 Oct 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/10/parrot-babysteps-0e-parrot-namespaces/</guid>
  <description>Where was I? In the previous Babystep, I started working out some rough ideas for a version of the old school Star Trader game written in Parrot PIR. I made a quick description and sketched up a list of the features that would need to be created. One of those features was an interactive shell to be used in developing and hacking on that Space Trade game. I wrote a simple shell that could be extended, making it easier to expand the capabilities of the shell in the future - or even use the shell in some completely unforeseen future application.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>Where was I? In the <a href="/post/2010/08/parrot-babysteps-0d-the-space-trade-project/">previous Babystep</a>, I started working out some rough ideas for a version of the old school <a href="https://en.wikipedia.org/wiki/Star_Trader">Star Trader</a> game written in Parrot PIR. I made a quick description and sketched up a list of the  features that would need to be created. One of those features was an interactive shell to be used in developing and hacking on that Space Trade game. I wrote a simple shell that could be extended, making it easier to expand the capabilities of the shell in the future - or even use the shell in some completely unforeseen future application.</p>
<p>I like that shell, but it is not perfect. Programming languages like Parrot
support <a href="http://en.wikipedia.org/wiki/Namespace_%28computer_science%29">namespaces</a>, which you can think of as dictionaries that the language uses to look up variables and subroutines. My problem with the shell today revolves around the fact that every subroutine used in defining or extending the shell exists in the global namespace. They are available everywhere - in every line of code for the SpaceTrade game and anything that uses it. This may not be a huge problem by itself, because right now there are only a few subroutines. The number of subroutines will grow as the project evolves, however. This will have a couple of different effects.</p>
<ul>
<li>Subroutine names will be harder to remember, because the global namespace is one big bucket. I like to put related subroutines into little boxes so that I can focus on shell behavior when I&rsquo;m looking at shell code, and game behavior when I&rsquo;m looking at game code.</li>
<li>Subroutine names could get rather contorted. What happens if I make Space Trade available, and against all odds it becomes a runaway success? Five, maybe even ten people download it and play it. It is likely that at least one of those people will want to write their own shell for the game. They will have to come up with some odd names for their shell code, such as <code>register_awesome_commands</code>, because I have selfishly used all the good names for my own shell.</li>
</ul>
<h2 id="namespaces">Namespaces</h2>
<p>Namespaces provide a way to insulate the parts of a computer program from each other. The subroutines and variables defined in one namespace will not interfere with the subroutines and variables in another. This means that I can have my <code>register_default_commands</code> subroutine for my own shell, and you can have a  <code>register_default_commands</code> subroutine in your own shell, and they never need to know about each other. It does mean you must take extra steps if you want to use the subroutine from my package in your own code, or I must somehow provide a means to push the subroutines that I consider appropriate into your namespace. That is what <a href="https://github.com/parrot/parrot/blob/master/runtime/parrot/include/test_more.pir">Test::More</a> does. Defining something like that is an exercise in careful judgment and reasonable coding. In other words, we will not be doing that with SpaceTrade any time soon.</p>
<p>I will try to focus on the most important elements of <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch04_variables.pod.html#Namespaces">Parrot Namespaces</a> rather than get carried away with all of the little details.</p>
<h3 id="organizing-the-namespaces">Organizing the Namespaces</h3>
<p>Even though the SpaceTrade game has very little code right now, I want to put a little thought into organizing my namespaces before I create them. The first layer is easy: all of the code supporting the SpaceTrade game will go in the &ldquo;SpaceTrade&rdquo; namespace.</p>
<ul>
<li>SpaceTrade: Code for the SpaceTrade Game</li>
</ul>
<p>Parrot supports nested namespaces, so &ldquo;SpaceTrade&rdquo; can contain any number of namespaces. I&rsquo;m sure there will be many contained namespaces for game setup and play, but I will only specify the one I am working on today: &ldquo;SpaceTrade::Shell.&rdquo;</p>
<ul>
<li>SpaceTrade: Code for the SpaceTrade Game</li>
<li>SpaceTrade::Shell: A simple interactive shell for SpaceTrade</li>
</ul>
<p>The names do not mean anything to Parrot. It does not force a particular way of organizing your namespaces. Nested namespaces are a convenience so that <em>we</em> know two chunks of code are somewhat related.</p>
<h4 id="the-namespace-directive">The <code>.namespace</code> Directive</h4>
<p>The <code>.namespace</code> directive is used to tell Parrot that the following code belongs in a particular namespace. Its argument is a hash index specifying the name.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.namespace [&#39;SpaceTrade&#39;]</code></pre>
</figure><p>Use a complex key to indicate a nested namespace.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.namespace [&#39;SpaceTrade&#39;;&#39;Shell&#39;]</code></pre>
</figure><p>All of the code after the <code>.namespace</code> directive gets filed in the namespace associated with the key you handed to it. This lasts until you declare a new namespace.</p>
<p>It&rsquo;s time to try it out in <code>spacetrade.pir</code>. All of the code written so far is for the shell, so I can probably get away with putting my <code>.namespace</code> directive at the top of the file.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-01/lib/spacetrade.pir
.namespace [&#39;SpaceTrade&#39;;&#39;Shell&#39;]

.sub &#39;main&#39; :main
    run_shell()
.end

.sub run_shell
    # ...</code></pre>
</figure><p>Why do I say &ldquo;SpaceTrade::Shell&rdquo; rather than <code>['SpaceTrade';'Shell']</code> when talking about my namespace in this article? That is mainly because I am lazy. My fingers do not enjoy typing out all the characters to say <code>['SpaceTrace';'Shell']</code>, so I want to use a shorthand. &ldquo;SpaceTrade::Shell&rdquo; mimics a convention used by some Parrot programmers when talking about namespaces. It is a convention derived from the way that namespaces - or &ldquo;packages&rdquo; - are declared in <a href="/card/perl/">Perl</a>, which is another language of choice for many Parrot developers. I will switch to another convention if I see one that is both widely used and easy to type.</p>
<p>Back to SpaceTrade. I run <code>setup.pir test</code> out of curiosity.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-shell-metacommands.t .. ok
All tests successful.
Files=1, Tests=6,  0.015 wallclock secs
Result: PASS</code></pre>
</figure><p>The tests pass, which is kind of cool. But <em>why</em> do they pass, if I have
defined a namespace in <code>spacetrade.pir</code>? The tests should complain about missing subroutines if they are in a different namespace, right?</p>
<p>Yes, that is right. However, the <code>.include</code> directive effectively dumps the
code from your included file right where you put the directive. The tests exist in the <code>['SpaceTrade';'Shell']</code> namespace because we never indicated that we were moving onto a new one.</p>
<p>That might even be okay for these tests. After all, they are just telling me
that the shell subroutines work, not that namespace handling works. The
SpaceTrade namespaces are going to get more cluttered as time goes on, though. I am going to be more explicit in the namespace handling for my tests in order to prepare for that clutter.</p>
<h3 id="the-default-namespace">The Default Namespace</h3>
<p>To specify that you are going back to the default namespace, hand an empty key to the <code>.namespace</code> directive.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.namespace [ ]</code></pre>
</figure><p>I understand the idea here. The default namespace is no namespace at all, so it gets an empty key. Let&rsquo;s put that line in <code>01-shell-metacommands.pir</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-02/t/01-shell-metacommands.pir

.include &#39;lib/spacetrade.pir&#39;

.namespace [ ]

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    # ...</code></pre>
</figure><p>What happens if I run the tests now?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-shell-metacommands.t .. Dubious, test returned 1
Failed 6/6 subtests

Test Summary Report
-------------------
t/01-shell-metacommands.t (Tests: 0 Failed: 0)
  Non-zero exit status: 1
  Parse errors: Unknown TAP token: &#34;Could not find sub register_default_commands&#34;
                Unknown TAP token: &#34;current instr.: &#39;main&#39; pc 275 (t/01-shell-metacommands.t:14)&#34;
Bad plan.  You planned 6 tests but ran 0.
Files=1, Tests=0,  0.014 wallclock secs
Result: FAIL
test fails
current instr.: &#39;setup&#39; pc 829 (runtime/parrot/library/distutils.pir:379)</code></pre>
</figure><p>This is the error I was expecting to see initially, so I am happy. I suppose I could have put that <code>.namespace [ ]</code> directive at the end of <code>spacetrade.pir</code> - Parrot does not have any rules about where to end one namespace and start another - but I feel like that would have broken the way <code>.include</code> behaves. I will probably learn a better way to handle these little namespace issues eventually.</p>
<p>Now I have library code tucked into a namespace and test code that doesn&rsquo;t know about the shell subroutines. A quick look at <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines/">07-writing-subroutines/</a> shows how to get those shell subroutines into our current namespace. The <code>get_global</code> opcode allows us to grab a variable from another namespace. We used it in to grab the <code>chomp</code> subroutine from the String::Utils namespace. Let&rsquo;s use <code>get_global</code> to make the tested subroutines available.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-03/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.namespace [ ]

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(6)

    .local pmc    register_default_commands
    .local pmc    evaluate_command
    .local pmc    register_command
    .local pmc    commands
    .local string expected
    .local string output

    register_default_commands = get_global [&#39;SpaceTrade&#39;;&#39;Shell&#39;], &#39;register_default_commands&#39;
    evaluate_command = get_global [&#39;SpaceTrade&#39;;&#39;Shell&#39;], &#39;evaluate_command&#39;
    register_command = get_global [&#39;SpaceTrade&#39;;&#39;Shell&#39;], &#39;register_command&#39;

    commands = register_default_commands()

    # ...</code></pre>
</figure><p>As we can see, that&rsquo;s <em>almost</em> good enough.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >1..6
ok 1 - :help should be a registered default command
ok 2 - :quit should be a registered default command that returns an empty string
ok 3 - :help should reflect registered commands
not ok 4 - User command &#34;:dude&#34; should result in string &#34;Dude!&#34;
# Have: Invalid command: :dude points to nonexistent sub say_dude
# Want: Dude!
ok 5 - Shell should warn about unknown commands
ok 6 - Shell should warn about invalid commands</code></pre>
</figure><p>Up until now we have been using subroutine names when registering commands, but that is not going to work anymore. SpaceTrade no longer knows exactly where it should look for the subroutines with those names. Instead of names, let&rsquo;s try using the subroutines themselves.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-04/lib/spacetrade.pir
.sub register_command
    .param pmc    commands
    .param string name
    .param pmc    code
    .param string explanation

    .local pmc    command
    .local pmc    callback

    command = new &#39;Hash&#39;
    command[&#39;code&#39;] = code
    command[&#39;explanation&#39;] = explanation

    commands[name] = command
    goto RETURN_COMMANDS

  RETURN_COMMANDS:
    .return(commands)
.end</code></pre>
</figure><p><code>register_command</code> doesn&rsquo;t look a lot different. The names have changed to show what is going on, but we are still just building a Hash of commands and relying on <code>evaluate_command</code> to sort out any problems.</p>
<p>Naturally, that means <code>evaluate_command</code> is where the changes become obvious.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-04/lib/spacetrade.pir
.sub evaluate_command
    .param pmc    commands
    .param string name

    .local int    has_command
    .local pmc    command_info
    .local pmc    code
    .local int    is_invokable
    .local pmc    command_sub
    .local string output

    has_command = exists commands[name]
    unless has_command goto UNKNOWN_COMMAND

    command_sub = commands[name;&#39;code&#39;]
    if_null command_sub, INVALID_COMMAND

    is_invokable = does command_sub, &#39;invokable&#39;
    unless is_invokable goto INVALID_COMMAND

    output = command_sub(commands)
    goto RETURN_OUTPUT

  UNKNOWN_COMMAND:
    output = &#34;Unknown command: &#34; . name
    goto RETURN_OUTPUT

  INVALID_COMMAND:
    output = &#34;Invalid command: &#34; . name
    output .= &#34; does not point to a valid subroutine&#34;

  RETURN_OUTPUT:
    .return(output)
.end</code></pre>
</figure><p>We do a few simple checks when somebody tries to evaluate a command.</p>
<ul>
<li>Do we have an entry for the command?</li>
<li>Is there something actually <em>at</em> the entry?</li>
<li>Is the thing stored for the command look like something we can treat as a subroutine?</li>
</ul>
<p>That&rsquo;s what the <code>does</code> check handles, incidentally. Right now we only know about subroutines, but later on we may get into strange creations that aren&rsquo;t subroutines but can be invoked as if they were. From what the folks on IRC <code>#parrot</code> tell me, you would ask <code>command_sub</code> if it is invokable. All I know is that it worked and that I like the folks on <code>#parrot</code> very much.</p>
<p>We should make one more change before heading over to the tests. <code>register_default_commands</code> needs to adjust to the new way of  registering commands.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-04/lib/spacetrade.pir
.sub register_default_commands
    .local pmc commands
    .local pmc help_command
    .local pmc quit_command

    commands = new &#39;Hash&#39;
    help_command = get_global &#39;default_help&#39;
    quit_command = get_global &#39;default_quit&#39;
    commands = register_command(commands, &#39;:help&#39;, help_command, &#39;This view&#39;)
    commands = register_command(commands, &#39;:quit&#39;, quit_command, &#39;Exit the shell&#39;)

    .return(commands)
.end</code></pre>
</figure><p>If you don&rsquo;t explicitly hand a namespace to <code>get_global</code>, it will use whatever namespace it&rsquo;s called from. In this case, that is the SpaceTrade::Shell namespace.</p>
<p>We have to change the tests themselves now. There is actually only one test that needs to be changed. Look in <code>01-shell-metacommands.t</code> for the line that registers the <code>:dude</code> command.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-03/t/01-shell-metacommands.t
# ...
commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)</code></pre>
</figure><p>Instead of handing a string, create a PMC to hold the <code>say_dude</code> subroutine and had <em>that</em> to <code>register_command</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0e-04/t/01-shell-metacommands.t
.local pmc my_sub
my_sub = get_global &#39;say_dude&#39;
commands = register_command(commands, &#39;:dude&#39;, my_sub, &#39;Say &#34;Dude!&#34;&#39;)</code></pre>
</figure><p>Once again, we&rsquo;re using <code>get_global</code> to grab from the current namespace, which is the default namespace now.</p>
<p>All right, the tests should run okay.</p>
<p>It is possible to set and get truly global variables with <code>get_root_global</code> and <code>set_root_global</code>, but I do not recommend it. What happens if you decide that the global <code>my_config</code> should be an Array instead of a Hash? Every piece of code that uses a global variable must be updated.</p>
<p>The same problem exists with package globals, even though it may be on a smaller scale. There&rsquo;s a solution - or at least a way to make the problem even smaller. Whenever I see data and several subroutines that need to work on that data, I start to see objects.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 0d - The SpaceTrade Project</title>
  <link>https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/</link>
  <pubDate>Mon, 02 Aug 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/08/parrot-babysteps-0d-the-space-trade-project/</guid>
  <description>I might be done with the Stellar application for the moment, but I don’t think I’m done with the space theme in Parrot yet.
Back in the ancient days, there was a nifty game called Star Trader. You and your friends were interstellar merchants trying to earn a few credits (or whatever) in a cold and uncaring universe. Star Trader has had many popular descendants, which have evolved over the generations into games like Trade Wars Rising, Oolite and Eve Online.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>I might be done with the <a href="/post/2010/07/parrot-babysteps-0x-the-stellar-app/">Stellar</a> application for the moment, but I don&rsquo;t think I&rsquo;m done with the space theme in <a href="/card/parrot/">Parrot</a> yet.</p>
<p>Back in the ancient days, there was a nifty game called <a href="https://en.wikipedia.org/wiki/Star_Trader">Star Trader</a>. You and your friends were interstellar merchants trying to earn a few credits (or whatever) in a cold and uncaring universe. Star Trader has had <em>many</em> popular descendants, which have evolved over the generations into games like <a href="http://tradewarsrising.com">Trade Wars Rising</a>,  <a href="http://www.oolite.org/">Oolite</a> and <a href="http://eveonline.com">Eve Online</a>. Those games are interactive and fun and great ways to kill many hours, but I&rsquo;ve got an itch for something old school. I want to revisit the joy of a text interface that demands your imagination work overtime while you figure out what is going on.</p>
<p>It is possible that I have been playing <a href="http://www.bay12games.com/dwarves/">Dwarf Fortress</a> a little bit too much for my own good.</p>
<p>This one is going to take some work. It is a fairly elaborate game. The map is random, markets change, and merchants can be haggled with. I can use the <a href="https://web.archive.org/web/20131222221016/http://www.dunnington.u-net.com/public/basicgames/TRADES">original code</a> as a resource, but not very well. The listing I could find was written in a HP-BASIC dialect that I am unfamiliar with. So I have to do more than just copy the game. I&rsquo;ll have to make a game inspired by Star Trader instead. That seems to be what all the cool kids are doing - assuming you use a rather flexible definition of &ldquo;cool.&rdquo;</p>
<p>I talked about using a text interface, but I know that eventually I will want to choose my own interface for the game. Players can choose their own approach, and bored coders will be able to create new ones. I will start by keeping the game logic as abstract as I can, and worry about the details of play later.</p>
<h2 id="spacetrade-summary">SpaceTrade Summary</h2>
<p>Space Trade is a turn-based game in which one or more players assumes the role of an interstellar merchant in the future. The game has a fixed number of turns, determined during game setup. Players are competing to have a pilot with the highest worth at the end of the game. The single player goal is to beat her own previous high scores.</p>
<p>Game play occurs on a map of star systems. Each star system has a trade classification, which makes the price of goods vary from one system to the next. There is a port in every system for traders to buy and sell goods, or to upgrade their ship&rsquo;s capabilities. Traders may attempt to haggle for a more favorable price, but this might not work. As the game progresses, markets may change based on trade activity. A glut of a particular good could temporarily reduce its value, or a run on that good could temporarily increase its value.</p>
<p>Traders may encounter hazards such as planetoids or pirates while travelling between systems. The results of these encounters could be cargo loss or damage to the trader&rsquo;s ship. If a ship accumulates enough damage without repair, it could be destroyed. Destruction of a ship ends the game for that trader.</p>
<h3 id="development-tasks">Development Tasks</h3>
<p>My summary is a little vague compared to your average game, but there are a lot of juicy programming tasks in there.</p>
<ul>
<li>Creating a star</li>
<li>Building a star map</li>
<li>Creating a new trader</li>
<li>Buying cargo</li>
<li>Selecting and travelling to a new system</li>
<li>Selling cargo</li>
<li>Dealing with changing markets</li>
<li>Haggling with merchants</li>
<li>Coping with environmental hazards (pirates, planetoids, etcetera)</li>
<li>Enabling multiple players</li>
<li>Upgrading a ship</li>
<li>Scoring the endgame</li>
<li>Tracking high scores</li>
<li>Saving a game in play</li>
<li>Loading a saved game</li>
</ul>
<p>At each stage, we will work on the simple text interface and add randomization to make gameplay interesting.</p>
<p>I have never written a game in Parrot before. I have not written many games in <em>any</em> language. I understand if one of your questions is &ldquo;why not use language X?&rdquo; - where <em>X</em> is Python, Perl, Ruby, Rakudo, D, or something else. I might use language X another time, but then it would be part of the X Babysteps rather than the Parrot Babysteps.</p>
<p>Another question might be &ldquo;Are we <em>ever</em> going to use Parrot to write a language?&rdquo; Actually, yes. I&rsquo;m going to put together a simple script language that handles game behavior. Not a powerful megasmart language for high end projects, but something for building the star map and playing the game itself. It will be used for saving and sharing games, and inevitably for hacking game details. Hey, what fun is a game if you can&rsquo;t hack it?</p>
<p>That&rsquo;s three more on-going development tasks, then:</p>
<ul>
<li>Developing an interactive user shell</li>
<li>Randomizing game play elements</li>
<li>Creating a game scripting language</li>
</ul>
<p>This is more complex than Stellar, and it will take more than a few steps to finish it. I am certain there will be a lot of new Parrot territory to explore.</p>
<p>This should be fun. Let&rsquo;s get started!</p>
<h2 id="setting-up-the-project">Setting up the project</h2>
<p>Thanks to Stellar, I already know how I like to prepare my workspace for a new project.  The setup from <a href="/post/2010/04/parrot-babysteps-09-simple-projects/">parrot-babysteps-09-simple-projects</a> will provide the starting point for SpaceTrade.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mkdir spacetrade
$ mkdir spacetrade/t
$ mkdir spacetrade/lib
$ cd spacetrade</code></pre>
</figure><p>The <code>setup.pir</code> script will start out the same as the one used for Stellar.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-01/setup.pir
.sub &#39;main&#39; :main
    .param pmc args
    $S0 = shift args # Ignore my own filename
    load_bytecode &#39;distutils.pbc&#39;

    # find out what command the user has issued.
    .local string directive
    directive = shift args

    # Used by test mode
    .local string prove_exec
    prove_exec = get_parrot()

    setup(directive, &#39;prove_exec&#39; =&gt; prove_exec)
.end</code></pre>
</figure><p>There is one basic feature I want to get out of the way before I start handling game logic. User interaction is important. Oh sure, there may eventually be interfaces in <a href="https://github.com/parrot/parrot/blob/master/runtime/parrot/library/Curses.pir">Curses</a> or <a href="https://github.com/parrot/parrot/tree/master/runtime/parrot/library/SDL">SDL</a>, but all that&rsquo;s needed for now is a simple command line <a href="http://en.wikipedia.org/wiki/Shell_%28computing%29">shell</a>. This shell will be used to examine the nuts and bolts of SpaceTrade and to play a simple text-based version of the game.</p>
<h3 id="the-spacetrade-interactive-shell">The SpaceTrade Interactive Shell</h3>
<p>I believe that every interactive shell needs a few minimal components to be useful.</p>
<ul>
<li>A command to quit</li>
<li>A command to get help</li>
<li>A reasonable way to handle invalid input</li>
</ul>
<p>A sample session with such a minimal shell might look like this:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot lib/spacetrade.pir
Welcome to SpaceTrade!
Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.
&gt; waffles!
Unknown command: waffles!
Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.
&gt; :help
COMMANDS
:help    This view
:quit    Exit the shell
&gt; :quit
Goodbye!
$</code></pre>
</figure><p>Why do I imagine this shell having commands prefixed by a <code>:</code> character? Well, &ldquo;normal&rdquo; commands would look normal, but behavior like getting help or quitting the game are only important for dealing with the shell. I want those special shell commands to look different from the normal game commands.</p>
<p>Of course, I may change my mind later. I am fickle.</p>
<p>What is the smallest amount of code I can use to get this end result and still feel comfortable?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-01/lib/spacetrade.pir
.sub &#39;main&#39; :main
    run_shell()
.end

.sub run_shell
    .local string input
    .local pmc    stdin
    .const string PROMPT     = &#39;&gt; &#39;
    .const string QUICK_HELP = &#34;Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.&#34;

    stdin = getstdin

    say &#34;Welcome to SpaceTrade!&#34;
    say QUICK_HELP

  READLINE:
    input = stdin.&#39;readline_interactive&#39;(PROMPT)
    if input == &#39;:quit&#39; goto EXIT
    if input == &#39;:help&#39; goto SHOW_USAGE
    goto SHOW_ERROR

  SHOW_USAGE:
    say &#34;COMMANDS&#34;
    say &#34;:help    This view&#34;
    say &#34;:quit    Exit the shell&#34;
    goto READLINE

  SHOW_ERROR:
    .local string error_message
    error_message = &#34;Unknown command: &#34;
    error_message .= input
    say error_message
    say QUICK_HELP
    goto READLINE

  EXIT:
    say &#34;Goodbye!&#34;
.end</code></pre>
</figure><p>This works, but it doesn&rsquo;t look right.</p>
<p>For a start, the commands are kind of a mess. When I add commands, I will have to add both an <code>if</code> check in the <code>READLINE</code> section and a line of output in the <code>SHOW_USAGE</code> section. Then there are the blocks I would have to add to provide that actual functionality. No, I do not like this at all. The shell commands should be better organized so that adding and managing features is as easy as possible.</p>
<p>One approach would be to add a registry which stores the commands recognized by the shell.</p>
<h3 id="creating-a-command-registry">Creating a Command Registry</h3>
<p>The idea is that I could have a simple structure that stores information about available commands, and the application could add commands as needed. Let&rsquo;s start with a simple Hash and two subroutines for adding and evaluating shell commands.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-02/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(1)

    .local pmc    commands
    .local string expected
    .local string output

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)
    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)
.end

.sub say_dude
    .return(&#34;Dude!&#34;)
.end</code></pre>
</figure><p>The first sub that&rsquo;s needed is <code>register_command</code>, which will add a <code>:dude</code> entry in the <code>commands</code> Hash with appropriate information.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-02/lib/spacetrade.pir

.sub register_command
    .param pmc    commands
    .param string name
    .param string sub_name
    .param string explanation

    .local pmc    command
    .local pmc    callback

    command = new &#39;Hash&#39;
    command[&#39;sub_name&#39;] = sub_name
    command[&#39;explanation&#39;] = explanation
    commands[name] = command

  RETURN_COMMANDS:
    .return(commands)
.end</code></pre>
</figure><p>There is no special magic going on here. <code>command[':dude']</code> points to a Hash containing a subroutine name and an explanation of the command. <code>commands</code> is returned to the caller once the new command has been added.</p>
<p>You can probably figure out what I expect to happen from the test code. I have a <code>say_dude</code> sub, and somehow I expect the shell to figure out how to call that sub when I ask for it by sending the <code>:dude</code> command. We&rsquo;ve actually already done this, back when we were grabbing the <code>chomp</code> sub in <a href="/post/2009/10/parrot-babysteps-06-files-and-hashes/">/post/2009/06-files-and-hashes/</a>. The <code>get_global</code> <a href="http://docs.parrot.org/parrot/latest/html/src/ops/var.ops.html">variable opcode</a> will look for a variable with a specified name and return it to us if it exists.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-02/lib/spacetrade.pir
.sub evaluate_command
    .param pmc    commands
    .param string name

    .local string sub_name
    .local pmc    command_sub
    .local string output

    sub_name = commands[name;&#39;sub_name&#39;]
    command_sub = get_global sub_name
    output = command_sub()

    .return(output)
.end</code></pre>
</figure><p>There is one new bit of strangeness here, though:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >sub_name = commands[name;&#39;sub_name&#39;]</code></pre>
</figure><p>This is called a &ldquo;complex key,&rdquo; and lets us directly access the values in the Hash held at <code>commands[name]</code>. Each index in a complex key is separated by a semicolon (<code>;</code>) character.  Without a complex key, we might have to do something like this:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$P1 = commands[name]
sub_name = $P1[&#39;sub_name&#39;]</code></pre>
</figure><p>I did not realize I could use a complex key until I scanned the <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch04_variables.pod.html">variables chapter</a> of the Parrot PIR Book. It is important to keep reviewing documentation, even if you think you already know a solution. Remember:  regardless of what you know, there is probably a better way.</p>
<p>It is time to add basic error handling to the shell. <code>evaluate_command</code> needs to handle two major error cases.</p>
<ol>
<li>User tries a command that doesn&rsquo;t exist</li>
<li>User tries a command that points to a nonexistent subroutine.</li>
</ol>
<p>Okay, let&rsquo;s add the tests.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-03/t/01-shell-metacommands.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(3)

    .local pmc    commands
    .local string expected
    .local string output

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)
    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)

    expected = &#34;Unknown command: :sweet&#34;
    output = evaluate_command(commands, &#39;:sweet&#39;)
    is(output, expected, &#39;Shell should warn about unknown commands&#39;)

    commands = register_command(commands, &#39;:whats-mine-say&#39;, &#39;whats_mine_say&#39;, &#34;What&#39;s mine say?&#34;)
    expected = &#34;Invalid command: :whats-mine-say points to nonexistent sub whats_mine_say&#34;
    output = evaluate_command(commands, &#39;:whats-mine-say&#39;)
    is(output, expected, &#39;Shell should warn about invalid commands&#39;)
.end

# ...</code></pre>
</figure><p><code>evaluate_command</code> is a little more complicated now, but it is still manageable.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-03/lib/spacetrade.pir

# ...

.sub evaluate_command
    .param pmc    commands
    .param string name

    .local string sub_name
    .local pmc    command_sub
    .local string output

    sub_name = commands[name;&#39;sub_name&#39;]
    unless sub_name goto UNKNOWN_COMMAND
    command_sub = get_global sub_name
    if_null command_sub, INVALID_COMMAND
    output = command_sub()
    goto RETURN_OUTPUT

  UNKNOWN_COMMAND:
    output = &#34;Unknown command: &#34; . name
    goto RETURN_OUTPUT

  INVALID_COMMAND:
    output = &#34;Invalid command: &#34; . name
    output .= &#34; points to nonexistent sub &#34;
    output .= sub_name

  RETURN_OUTPUT:
    .return(output)
.end

# ...</code></pre>
</figure><p>One thing that might catch your attention is the <code>if_null</code> opcode.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >if_null command_sub, INVALID_COMMAND</code></pre>
</figure><p>This will check if <code>command_sub</code> is null, and branch to <code>INVALID_COMMAND</code> if the subroutine we just tried to grab is indeed null. To be perfectly honest with you, I&rsquo;m not sure if a branch is the same as a <code>goto</code>. It behaves the same in this code, so for now I will pretend that it is the same.</p>
<h3 id="setting-up-those-default-shell-commands">Setting Up Those Default Shell Commands</h3>
<p>This ends up working pretty much the same as the earlier code did, and it&rsquo;s a bit more flexible. Is this how we make programming languages in Parrot? Well, no. This is not how we make programming languages in Parrot. This is a very simple shell which will have a few simple commands, but try to pass everything else off to the game itself. Proper language development is still a few Babysteps away.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-04/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(5)

    .local pmc    commands
    .local string expected
    .local string output

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)
    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)

    expected = &#34;Unknown command: :sweet&#34;
    output = evaluate_command(commands, &#39;:sweet&#39;)
    is(output, expected, &#39;Shell should warn about unknown commands&#39;)

    commands = register_command(commands, &#39;:whats-mine-say&#39;, &#39;whats_mine_say&#39;, &#34;What&#39;s mine say?&#34;)
    expected = &#34;Invalid command: :whats-mine-say points to nonexistent sub whats_mine_say&#34;
    output = evaluate_command(commands, &#39;:whats-mine-say&#39;)
    is(output, expected, &#39;Shell should warn about invalid commands&#39;)

    commands = register_default_commands()

    expected =&lt;&lt;&#39;EXPECTED&#39;
COMMANDS
:help    This view
:quit    Exit the shell
EXPECTED
    output = evaluate_command(commands, &#39;:help&#39;)
    is(output, expected, &#39;:help should be a registered default command&#39;)

    expected = &#39;&#39;
    output = evaluate_command(commands, &#39;:quit&#39;)
    is(output, expected, &#39;:quit should be a registered default command that returns an empty string&#39;)
.end

.sub say_dude
    .return(&#34;Dude!&#34;)
.end</code></pre>
</figure><p>The test code that has already been written shows a clear path for registering default commands. All that&rsquo;s needed is the subroutines that will be invoked when the command is called.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >example-0d-04/lib/spacetrade.pir
.sub register_default_commands
    .local pmc commands

    commands = new &#39;Hash&#39;
    commands = register_command(commands, &#39;:help&#39;, &#39;default_help&#39;, &#39;This view&#39;)
    commands = register_command(commands, &#39;:quit&#39;, &#39;default_quit&#39;, &#39;Exit the shell&#39;)

    .return(commands)
.end

.sub default_help
    .local string output

    output =&lt;&lt;&#39;OUTPUT&#39;
COMMANDS
:help    This view
:quit    Exit the shell
OUTPUT

    .return(output)
.end

.sub default_quit
    .local string output
    output = &#39;&#39;
    .return(output)
.end</code></pre>
</figure><p>There&rsquo;s a problem.</p>
<p>The problem is that I had to cheat on <code>default_help</code>. See, the way that I set up <code>evaluate_commands</code> is to directly invoke the registered subroutine without any arguments. I would prefer that <code>default_help</code> examined the currently registered commands and provided a real summary. It should even include my magnificent <code>:dude</code> command in the summary.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/t/01-shell-metacommands.t
.include &#39;lib/spacetrade.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(6)

    .local pmc    commands
    .local string expected
    .local string output

    commands = register_default_commands()

    expected =&lt;&lt;&#39;EXPECTED&#39;
COMMANDS
:help    This view
:quit    Exit the shell
EXPECTED
    output = evaluate_command(commands, &#39;:help&#39;)
    is(output, expected, &#39;:help should be a registered default command&#39;)

    expected = &#39;&#39;
    output = evaluate_command(commands, &#39;:quit&#39;)
    is(output, expected, &#39;:quit should be a registered default command that returns an empty string&#39;)

    commands = register_command(commands, &#39;:dude&#39;, &#39;say_dude&#39;, &#39;Say &#34;Dude!&#34;&#39;)

    expected =&lt;&lt;&#39;EXPECTED&#39;
COMMANDS
:dude    Say &#34;Dude!&#34;
:help    This view
:quit    Exit the shell
EXPECTED
    output = evaluate_command(commands, &#39;:help&#39;)
    is(output, expected, &#39;:help should reflect registered commands&#39;)

    expected = &#34;Dude!&#34;
    output = evaluate_command(commands, &#39;:dude&#39;)
    is(output, expected, &#39;User command &#34;:dude&#34; should result in string &#34;Dude!&#34;&#39;)

    expected = &#34;Unknown command: :sweet&#34;
    output = evaluate_command(commands, &#39;:sweet&#39;)
    is(output, expected, &#39;Shell should warn about unknown commands&#39;)

    commands = register_command(commands, &#39;:whats-mine-say&#39;, &#39;whats_mine_say&#39;, &#34;What&#39;s mine say?&#34;)
    expected = &#34;Invalid command: :whats-mine-say points to nonexistent sub whats_mine_say&#34;
    output = evaluate_command(commands, &#39;:whats-mine-say&#39;)
    is(output, expected, &#39;Shell should warn about invalid commands&#39;)

.end

.sub say_dude
    .return(&#34;Dude!&#34;)
.end</code></pre>
</figure><p>How am I supposed to do this? Let&rsquo;s start by rewriting <code>default_help</code> the way it should work: by preparing a sorted list of registered commands and their summaries.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/lib/spacetrade.pir
.sub default_help
    .param pmc    commands
    .local string output
    .local pmc    command_iter
    .local pmc    command_keys
    .local string key

    command_keys = new &#39;ResizablePMCArray&#39;
    command_iter = iter commands

  NEXT_COMMAND:
    unless command_iter goto PREPARE_OUTPUT
    key = shift command_iter
    push command_keys, key
    goto NEXT_COMMAND

  PREPARE_OUTPUT:
    output = &#34;COMMANDS\n&#34;
    command_keys.&#39;sort&#39;()

    .local string command_name
    .local string command_explanation
    .local string command_summary
    command_iter = iter command_keys

  NEXT_SUMMARY:
    unless command_iter goto RETURN_OUTPUT
    command_name = shift command_iter
    command_explanation = commands[command_name;&#39;explanation&#39;]
    command_summary = command_name . &#39;    &#39;
    command_summary .= command_explanation
    command_summary .= &#34;\n&#34;
    output .= command_summary
    goto NEXT_SUMMARY

  RETURN_OUTPUT:
    .return(output)
.end</code></pre>
</figure><p>A little explanation about <code>default_help</code> couldn&rsquo;t hurt. Hashes use their own special tricks to make storing their elements more effective, which means you have no guarantee of getting them in any particular order. I want to see the commands in alphabetical order, so I will have to handle the ordering myself. I did that by first building a list of keys.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >    command_keys = new &#39;ResizablePMCArray&#39;
    command_iter = iter commands

  NEXT_COMMAND:
    unless command_iter goto PREPARE_OUTPUT
    key = shift command_iter
    push command_keys, key
    goto NEXT_COMMAND</code></pre>
</figure><p>Once that list was constructed, it needed to be put in some sort of order. Luckily, the Array PMCs come with a prepackaged <code>sort()</code> method - a special subroutine that works directly with the elements of the array.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >    command_keys.&#39;sort&#39;()</code></pre>
</figure><p>The default sort behavior works for me. In this case they will be sorted more or less alphabetically.</p>
<p>Now, I could add a lot of code to <code>evaluate_command</code> that will magically determine what sort of arguments are required by the command, and to behave appropriately. But before I go doing a significant rewrite - how about an experiment? Maybe I can just call every command with <code>commands</code> as a parameter, and see what happens in the tests.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/lib/spacetrade.pir

# ...

.sub evaluate_command
    .param pmc    commands
    .param string name

    .local string sub_name
    .local pmc    command_sub
    .local string output

    sub_name = commands[name;&#39;sub_name&#39;]
    unless sub_name goto UNKNOWN_COMMAND
    command_sub = get_global sub_name
    if_null command_sub, INVALID_COMMAND
    output = command_sub(commands)
    goto RETURN_OUTPUT

  UNKNOWN_COMMAND:
    output = &#34;Unknown command: &#34; . name
    goto RETURN_OUTPUT

  INVALID_COMMAND:
    output = &#34;Invalid command: &#34; . name
    output .= &#34; points to nonexistent sub &#34;
    output .= sub_name

  RETURN_OUTPUT:
    .return(output)
.end</code></pre>
</figure><p>You have to be willing to experiment, because the results may occasionally surprise you.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot t/01-shell-metacommands.t
1..6
ok 1 - :help should be a registered default command
ok 2 - :quit should be a registered default command that returns an empty string
ok 3 - :help should reflect registered commands
ok 4 - User command &#34;:dude&#34; should result in string &#34;Dude!&#34;
ok 5 - Shell should warn about unknown commands
ok 6 - Shell should warn about invalid commands</code></pre>
</figure><p>How about that - it worked. PIR subroutines will apparently ignore positional parameters that they didn&rsquo;t ask for, which means that <code>evaluate_command</code> can call <code>say_dude</code> and <code>default_help</code> with the same parameter list and nothing bad will happen.</p>
<h3 id="the-new-and-slightly-improved-shell">The New and Slightly Improved Shell</h3>
<p>A lot of work has gone into making the shell easier to use for me and people who want to hack on the game in the future. Let&rsquo;s apply that work to the <code>run_shell</code> subroutine itself.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0d-05/lib/spacetrade.pir

.sub run_shell
    .local pmc    commands
    .local string input
    .local string output
    .local pmc    stdin
    .const string PROMPT     = &#39;&gt; &#39;
    .const string QUICK_HELP = &#34;Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.&#34;

    commands = register_default_commands()
    stdin = getstdin

    say &#34;Welcome to SpaceTrade!&#34;
    say QUICK_HELP

  READLINE:
    input = stdin.&#39;readline_interactive&#39;(PROMPT)
    output = evaluate_command(commands, input)
    unless output goto EXIT
    say output
    goto READLINE

  EXIT:
    say &#34;Goodbye!&#34;
.end</code></pre>
</figure><p>It&rsquo;s certainly shorter than what I started with. How well does it work?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot lib/spacetrade.pir
Welcome to SpaceTrade!
Type &#39;:help&#39; for help, and &#39;:quit&#39; to quit.
&gt; :dude
Unknown command: :dude
&gt; :help
COMMANDS
:help    This view
:quit    Exit the shell

&gt; :quit
Goodbye!</code></pre>
</figure><p>It isn&rsquo;t perfect, but it will work for the moment. This new shell has most of the core behavior from the original, and we have shown that it will not be hard to add new commands. There is still a large part of me that thinks the code for the shell should be tucked into its own corner, where it cannot get mixed up with the code for the actual game. That will have to wait for the next step, though.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 0c - The Stellar App</title>
  <link>https://randomgeekery.org/post/2010/07/parrot-babysteps-0x-the-stellar-app/</link>
  <pubDate>Thu, 15 Jul 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/07/parrot-babysteps-0x-the-stellar-app/</guid>
  <description>Our search journey continues. We have accomplished the hard part: checking a single star to see if it has the traits we’re looking for. Today we just have to use that logic to search a set of stars. First we’ll examine a handpicked selection. Guess what happens after that? We finally get back into the full HYG Catalog and search for stars from the command line. That’s right. After all this work, stellar grows up and becomes an application.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>space</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>Our search journey continues. We have accomplished the hard
part: <a href="/post/2010/06/parrot-babysteps-0b-subroutine-params">checking a single star</a> to see if it has the traits we&rsquo;re looking for.
Today we just have to use that logic to search a set of stars. First we&rsquo;ll
examine a handpicked selection. Guess what happens after that? We finally get
back into the full <a href="http://www.astronexus.com">HYG Catalog</a> and search for stars from the command line.
That&rsquo;s right. After all this work, <code>stellar</code> grows up and becomes an
application.</p>
<h3 id="note">Note</h3>
<p>There are easier ways to get searches out of a large CSV file. If
that was really all I wanted to do, I could use a higher level language like
<a href="/tags/perl/">Perl</a> or <a href="/tags/python/">Python</a> to feed the CSV into a <a href="http://sqlite.org">SQLite</a> database and directly
query the database. However, we are not building a SQL database. We are learning
how to do interesting things with <a href="/card/parrot/">Parrot</a>.</p>
<h2 id="building-a-catalog-and-searching-it">Building a Catalog and Searching It</h2>
<p>The first thing that&rsquo;s tripping me up is how to set up the catalog itself. You
know the &ldquo;set of stars&rdquo; I was talking about? The easy way to do this from a test
is to have a few CSV strings for some sample stars, apply <code>extract_from_csv</code> to
each of them, push each star into an array, then search through the array. Thing
is, I <em>know</em> that this is not going to be acceptable when I get to the real data.
I expect this application to be one where you run it from the command line,
using your search conditions as command line arguments. Loading all the data
before searching it takes time. I should write this code so that it searches
while reading in data. That would be much faster.</p>
<p>On the other hand, what if I add an interactive prompt to this application later?
Loading the full catalog into memory before applying searches could be
faster in the long run compared to reading the data file for every search.</p>
<p>That is trying to predict the future, though. I know how I want to use this
catalog today. I want to run a search and see the results as soon as the
application knows about them.</p>
<aside>
I will share a secret. I spent a day writing the "load then
search" approach to building the catalog. Guess what? It is unbearably slow at
my current Parrot skill level. I am confident that this is only
slow because my code overall is simplistic. Maybe I can revisit this idea after
learning more about Parrot.
</aside>
<h3 id="searching-the-catalog">Searching The Catalog</h3>
<p>I do not want to dig right into searching the full 119,617 entries of the real
catalog. Instead, let&rsquo;s set up a small test catalog and write some tests.</p>
<p>Where you put your test data is a matter of taste. I will be keeping my data in
a folder named <code>data</code>. That seems reasonable.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mkdir data</code></pre>
</figure><p>Only a few entries are needed in the test catalog. We just need to be sure that
the code works with a CSV file with the same structure as the HYG database.
I&rsquo;ll grab Sol, another G2V spectrum star, and a K3V star.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0c-01/data/test-catalog.csv
StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ
0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0
80,80,224817,,,,,0.01611947,-11.82353722,64.143681847338,419.04,-82.83,,8.40,4.36423057594421,G2V,0.566,62.7822,0.26494,-13.14292,-5.827e-06,0.000130277,-2.5209e-05
7358,7372,9770,,Gl  60 A,,,1.58359898,-29.91056753,23.6462520690471,85.56,96.58,34.2,7.11,5.2411884257345,K3V,0.909,18.76027,8.25627,-11.79114,2.8852e-05,2.3413e-05,-7.844e-06</code></pre>
</figure><p>The test data is out of the way, so now I feel comfortable writing the tests
that use it.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0c-01/t/05-search-catalog.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(5)

    .local string csv_filename 
    .local pmc    matches
    .local pmc    star
    
    csv_filename = &#39;data/test-catalog.csv&#39;
    matches = search_catalog(csv_filename, &#39;ProperName&#39;, &#39;Sol&#39;)
    is(matches, 1, &#39;There should be one star named &#34;Sol&#34;&#39;)
    star = matches[0]
    $S0 = star[&#39;ProperName&#39;]
    is($S0, &#39;Sol&#39;, &#39;That star should be Sol&#39;)

    matches = search_catalog(csv_filename, &#39;Spectrum&#39;, &#39;G2V&#39;)
    is(matches, 2, &#39;There are two G2V stars in the test catalog&#39;)

    matches = search_catalog(csv_filename, &#39;Spectrum&#39;, &#39;K3V&#39;)
    is(matches, 1, &#39;There should be one K3V star in the test catalog&#39;)

    matches = search_catalog(csv_filename, &#39;Spectrum&#39;, &#39;G2V&#39;, &#39;ColorIndex&#39;, &#39;0.566&#39;)
    is(matches, 1, &#39;There should be one G2V star with Spectrum G2V and ColorIndex 0.566&#39;)
.end</code></pre>
</figure><p>I am deliberately keeping the tests simple right now. The goal is to make sure
the basic functionality works rather than to guarantee behavior for every little
detail. Tests can be added for those details as they become important.</p>
<p>The actual <code>search_catalog</code> sub borrows quite a bit from <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines">step 07</a>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0c-01/lib/stellar.pir

.loadlib &#39;io_ops&#39;

# ...
.sub search_catalog
    .param string filename
    .param pmc    conditions :slurpy
    .local pmc    chomp
    .local pmc    matches
    .local pmc    catalog
    .local string current_line
    .local pmc    current_star
    .local pmc    is_match

    load_bytecode &#39;String/Utils.pbc&#39;
    chomp = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;

    matches = new &#39;ResizablePMCArray&#39;

    catalog = open filename, &#39;r&#39;
    current_line = readline catalog # Ignore header line

  READ_LINE:
    unless catalog goto RETURN_MATCHES
    current_line = readline catalog
    current_line = chomp(current_line)
    current_star = extract_from_csv_line(current_line)
    is_match = check_star(current_star, conditions :flat)
    if is_match goto REMEMBER_MATCH
    goto READ_LINE

  REMEMBER_MATCH:
    push matches, current_star
    goto READ_LINE

  RETURN_MATCHES:
    close catalog
    .return(matches)
.end</code></pre>
</figure><p><code>search_catalog</code> will handle the task of reading the file and looking for
stars that match the search conditions it has been given. After it defines
a star from the current line, it asks <code>check_star</code> to compare that star
to the set of conditions it has been given. It remembers the stars that
match, and returns them once it has reached the end of the file. It is not
the fastest approach, but it works.</p>
<p>It works well enough that I am ready to add real data and some way for people
to use it!</p>
<h3 id="searching-from-the-command-line">Searching From The Command Line</h3>
<p>Now that we know <code>stellar</code> can read a CSV and return results, it&rsquo;s time to work
on that empty <code>main</code> that has been sitting in <code>stellar.pir</code>. Oh yeah - we will
want to make <code>hygxyz.csv</code> available now. I will be pushing my copy into the
<code>data</code> folder, next to <code>test-catalog.csv</code>. You can place your copy wherever you
like, but make sure that you set the path appropriately in <code>main</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0c-02/lib/stellar.pir

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main
    .param pmc    conditions
    .local string csv_file
    .local pmc    matches
    .local pmc    matches_iter
    .local pmc    star
    .local string summary
    .local int    match_count

    $S0 = shift conditions # ignore my own filename
    csv_file = &#39;data/hygxyz.csv&#39;
    matches = search_catalog(csv_file, conditions :flat)
    matches_iter = iter matches

  NEXT_MATCH:
    star = shift matches_iter
    summary = summarize_star(star)
    say summary
    if matches_iter goto NEXT_MATCH

    match_count = matches
    print match_count
    say &#34; matches.&#34;
.end</code></pre>
</figure><p>Here is the result of all that work we have done setting up the project and
support code. The main subroutine in <code>stellar</code> is downright civilized
compared to what we had for <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines">step 07</a>. All we do is search based on the
command line parameters and display each of the matches.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot lib/stellar.pir Spectrum G2V ColorIndex 0.656
&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;
&lt;Name: HD 7186, Spectrum: G2V, Distance: 112.359550561798&gt;
&lt;Name: HD 140235, Spectrum: G2V, Distance: 60.1684717208183&gt;
&lt;Name: HD 169019, Spectrum: G2V, Distance: 108.108108108108&gt;
4 matches.</code></pre>
</figure><p>Hey, this thing is almost useful!</p>
<h2 id="conclusion">Conclusion</h2>
<p><code>stellar</code> has reached a major milestone. When I started fiddling with the <a href="http://astronexus.com/node/34">HYG
Database</a>, I wanted to write a command-line Parrot tool that could look up
stars based on specific fields. This step gives us that ability. I admit that
a lot more could be done. For example, it only does exact matches. You can
easily find a star that is <code>108.108108108108</code> light years away, but not
stars that are roughly <code>108</code> light years away. And forget about finding
stars within 20 light years.</p>
<p>I am going to take a little break from the <code>stellar</code> project, though.
<a href="http://rakudo.org">Rakudo Star</a> is almost out, and I want to play with that.</p>
<p>You can add to <code>stellar</code> yourself. Make it faster. Make it
object-oriented. Make it a library. Rewrite it in LOLCODE. Have fun. Just
remember to give <a href="http://astronexus.com/node/10">David Nash</a> credit for creating the HYG Database.
We have been having all of this fun because he took the time to put that
catalog together.</p>
<p>Enjoy yourself!</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 0b - Subroutine Params</title>
  <link>https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/</link>
  <pubDate>Tue, 15 Jun 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/06/parrot-babysteps-0b-subroutine-params/</guid>
  <description>It’s time to treat the star database like a database. Well, it’s time to treat it like something we can search, anyways. I know this is not a trivial task in Parrot, so the Babysteps have been building up to it slowly. First, we figured out how to read from the database file and display its contents in a meaningful fashion. Second, we added subroutines to massage the data a little and produce some usable names for the thousands of stars in the database that do not have proper names.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>It&rsquo;s time to treat the star database like a database. Well, it&rsquo;s time to treat
it like something we can search, anyways. I know this is not a trivial task in
Parrot, so the Babysteps have been building up to it slowly. <a href="/post/2009/10/parrot-babysteps-06-files-and-hashes">First</a>, we
figured out how to read from the database file and display its contents in a
meaningful fashion. <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines">Second</a>, we added subroutines to massage the data a
little and produce some usable names for the thousands of stars in the database
that do not have proper names. Then we suddenly spun off in a seemingly random
direction, talking about <a href="/post/2009/12/parrot-babysteps-08-testing-with-testmore">testing</a> and setting up <a href="/post/2010/04/parrot-babysteps-09-simple-projects">larger projects</a>. That
was intentional, though. This sort of project requires more work in <a href="/card/parrot/">Parrot</a> than in
a language like Perl, due to Parrot&rsquo;s lower-level nature. I wanted to be
sure we could test this application as we add search functionality. We just
pushed our script into the <a href="/post/2010/06/parrot-babysteps-0a-the-stellar-project">Stellar project</a> to get that testing foundation.</p>
<p>First I am going to describe what is being built, then I&rsquo;m going to work on the
very important detail of examining a single star. We&rsquo;ll have to wait until the
next Baby Step before we start searching the catalog.</p>
<h2 id="thinking-through-the-problem">Thinking Through The Problem</h2>
<p>We could start by creating a simple search function, testing every line in the
HYG Catalog and verifying the results by hand. That will obviously not work.
Part of the reason we have been writing this is because the catalog is not
easily read without a little computer help.</p>
<p>It might be a better idea to take a smaller set and search against it. How small
is good enough? A thousand? A hundred? Ten? We could reasonably start
by searching a set of one star. It is certainly easy to manage. Okay, so we&rsquo;ll
start with a set of one star.</p>
<p>What do I mean when I talk about searching through the catalog? The basic idea
is that we have a catalog of stars and some conditions, like &ldquo;the ProperName
is &lsquo;Sol&rsquo;.&rdquo; We build a list of matches by examining each star, seeing if the
conditions are true for that star. If they are, then that star goes in the list
of matches. Either way, we then move on to the next star.</p>
<p>How do we determine if a single star is a match? Okay, we have a single star and
some conditions. We determine if the star is a match by testing each condition.
We can stop testing when we find a condition that is not true or we have run out
of conditions to test. We know that this star is a match if every condition we
tested was true.</p>
<p>There are a lot of technical details that we would think about if this code was
intended for use in the real world. Large match lists could use a lot of memory.
The conditions would need to allow for ranges or approximate matches.
Luckily, this code is not indented for use in the real world. I can be as clumsy
as I want, as long as my program gives the right answer.</p>
<h2 id="writing-code">Writing Code</h2>
<p>Now we&rsquo;re ready to go back to the <code>stellar</code> project and write some code.</p>
<h3 id="testing-a-condition">Testing a Condition</h3>
<p>Our first approach to checking a star&rsquo;s details will be to check a single field.
The star <code>ProperName</code> is a good field to start with:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-01/t/04-check-star.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    delimiter = &#34;,&#34;
    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;

    plan(2)

    header_fields = split delimiter, header_string
    star = extract_from_csv_line(star_string, header_fields, delimiter)
    $S0 = &#39;Sol&#39;

    $I0 = check_star_proper_name(star, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_proper_name(star, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
.end</code></pre>
</figure><p><code>check_star_proper_name</code> is an easy sub to write. My version is more verbose
than necessary, to be honest:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-01/lib/stellar.pir

# ...

.sub check_star_proper_name
    .param pmc    star
    .param string desired_value
    .local string actual_value
    .local int    check_result

    actual_value = star[&#39;ProperName&#39;]
    check_result = desired_value == actual_value
    .return(check_result)
.end</code></pre>
</figure><p>The sub returns the result of comparing our desired <code>ProperName</code> with the actual
value held in the <code>star</code>. I rely on Parrot to do the right thing when comparing
<code>desired_value</code> with <code>actual_value</code>. <a href="/post/2009/07/parrot-babysteps-02-variables-and-types">Remember</a> that Parrot automatically
handles any type conversions, so we can ignore type for now.</p>
<h3 id="revisiting-the-header_string">Revisiting the <code>header_string</code></h3>
<p>I want to stop for a moment and look at my tests. One annoying fact is that
every single test file includes the full <code>header_string</code> and <code>delimiter</code>. That
is explicit behavior, which I like. Then again, it is also cluttering up my
tests. The headers never change, yet I always include them. What if I could make
the header string and delimiter optional?</p>
<p>I <em>can</em> make those parameters optional. Let&rsquo;s reopen the test file <code>03-extract-from-csv.t</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-02/03-extract-from-csv.t
.sub main &#39;:main&#39;
    # ...
    plan(4)
    # ...
    star = extract_from_csv_line(star_string, header_fields)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;delimiter should be optional&#34;)

    star = extract_from_csv_line(star_string)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;header_fields should be optional&#34;)
.end</code></pre>
</figure><p>How do we make those fields optional? We use the parameter modifiers <code>:optional</code>
and <code>:opt_flag</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub extract_from_csv_line
    .param string star_string
    .param pmc    header_fields     :optional
    .param int    has_header_fields :opt_flag
    .param string delimiter         :optional
    .param int    has_delimiter     :opt_flag

    if has_delimiter goto CHECK_HEADER_FIELDS
    delimiter = &#39;,&#39;
  CHECK_HEADER_FIELDS:
    if has_header_fields goto BEGIN_EXTRACTING
    .local string header_string
    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    header_fields = split delimiter, header_string

  BEGIN_EXTRACTING:
    .local pmc    star_fields
    .local pmc    star

    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)

    .return(star)
.end</code></pre>
</figure><p>The <code>:optional</code> modifier makes sense. Use it to tell Parrot that a particular
parameter is not required for the sub to perform its duties. <code>:opt_flag</code> might
require a little bit of explanation, though. It is a bookkeeping parameter
provided by Parrot to let you know whether or not the preceding optional
parameter was provided by the caller. You test the flag to see if the optional
parameter was set. The name of the flag doesn&rsquo;t matter.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-03.pir
.sub &#39;main&#39; :main
    .local string eggs
    .local string topping 
    .local string order

    eggs = &#39;over easy&#39;
    topping = &#34;Frank&#39;s RedHot&#34;

    order = breakfast(eggs, topping)
    say order

    order = breakfast(eggs)
    say order
.end

.sub breakfast
    .param string eggs
    .param string topping   :optional
    .param int    has_stuff :opt_flag

    .local string breakfast_order
    breakfast_order = &#39;Eggs cooked &#39; . eggs

    unless has_stuff goto SERVE_BREAKFAST
    breakfast_order .= &#39; topped with &#39;
    breakfast_order .= topping

  SERVE_BREAKFAST:
    .return(breakfast_order)
.end</code></pre>
</figure><p>This program executes without a hitch. There is nothing important about the name
of the flag.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-0b-03.pir
Eggs cooked over easy topped with Frank&#39;s RedHot
Eggs cooked over easy</code></pre>
</figure><p>Order <em>does</em> matter, though. You always want to put the flag after the optional
parameter in your <code>.param</code> directives, or bad things will happen.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-04.pir
.sub &#39;main&#39; :main
    .local string eggs
    .local string topping 
    .local string order

    eggs = &#39;over easy&#39;
    topping = &#34;Frank&#39;s RedHot&#34;

    order = breakfast(eggs, topping)
    say order

    order = breakfast(eggs)
    say order
.end

.sub breakfast
    .param string eggs
    .param int    has_stuff :opt_flag
    .param string topping   :optional

    .local string breakfast_order
    breakfast_order = &#39;Eggs cooked &#39; . eggs

    unless has_stuff goto SERVE_BREAKFAST
    breakfast_order .= &#39; topped with &#39;
    breakfast_order .= topping

  SERVE_BREAKFAST:
    .return(breakfast_order)
.end</code></pre>
</figure><p>See?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-0b-04.pir
Eggs cooked over easy
too few positional arguments: 1 passed, 2 (or more) expected
current instr.: &#39;breakfast&#39; pc 34 (example-0b-04.pir:19)
called from Sub &#39;main&#39; pc 26 (example-0b-04.pir:15)</code></pre>
</figure><p>Back to <code>stellar</code>. <code>extract_from_csv_line</code> can work the headers out for itself now. Let&rsquo;s clean up
our test code.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-05/t/04-check-star.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star

    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star = extract_from_csv_line(star_string)

    plan(2)

    $I0 = check_star_proper_name(star, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_proper_name(star, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
.end</code></pre>
</figure><p>It is a little easier now to tell what I am actually testing in this code. Good.
I know I should be all methodical and orderly about checking my star fields, but
I have not had enough sleep for that to be practical. Let&rsquo;s check <code>Spectrum</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/t/04-check-star.t

.sub &#39;main&#39; :main
    # ...
    plan(4)
    # ...
    $I0 = check_star_spectrum(star, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have Spectrum of &#34;G2V&#34;&#39;)
    $I0 = check_star_spectrum(star, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have Spectrum of &#34;K3V&#34;&#39;)
.end</code></pre>
</figure><p>Meanwhile, in <code>stellar.pir</code>:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/lib/stellar.pir
.sub check_star_spectrum
    .param pmc star
    .param string desired_value
    .local string actual_value
    .local int check_result

    actual_value = star[&#39;Spectrum&#39;]
    check_result = desired_value == actual_value
    .return(check_result)
.end</code></pre>
</figure><p>This works perfectly, but compare <code>check_star_spectrum</code> to
<code>check_star_proper_name</code>. They are almost identical. In fact, the only difference between
the code for the two subs is which field gets grabbed for <code>actual_value</code>.
It seems to me that the same behavior could be described by a single sub.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/t/04-check-star.t
.sub &#39;main&#39; :main
    # ...

    plan(8)

    # ...

    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have Spectrum of &#34;G2V&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have Spectrum of &#34;K3V&#34;&#39;)
.end</code></pre>
</figure><p><code>check_star_field</code> looks like a generic version of <code>check_star_proper_name</code> and
<code>check_star_spectrum</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-06/lib/stellar.pir

# ...

.sub check_star_field
    .param pmc star
    .param string field
    .param string desired_value
    .local string actual_value
    .local int check_result

    actual_value = star[field]
    check_result = desired_value == actual_value
    .return(check_result)
.end</code></pre>
</figure><p>All tests are still passing. You <em>are</em> working along with me and running tests,
right? It&rsquo;s time to decide what to do with those specific subs now that we have
a nice general purpose field checker. You could argue that those subs should
stick around but as wrappers that call <code>check_star_field</code>. That is entirely
reasonable. I am comfortable using the general purpose sub as my main checker,
though. I will delete the specific subs and their tests in my code.</p>
<h3 id="testing-multiple-conditions">Testing Multiple Conditions</h3>
<p><code>stellar</code> does a convincing job of checking a single field in a star. The next
step is figuring out how to check multiple fields.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-07/t/04-check-star.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star

    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star = extract_from_csv_line(star_string)

    plan(9)

    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName of &#34;Sol&#34;&#39;)
    $I0 = check_star_field(star, &#39;ProperName&#39;, &#39;Arcturus&#39;)
    nok($I0, &#39;Sol should not have ProperName of &#34;Arcturus&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have Spectrum of &#34;G2V&#34;&#39;)
    $I0 = check_star_field(star, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have Spectrum of &#34;K3V&#34;&#39;)

    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Sol&#39;)
    ok($I0, &#39;Sol should have ProperName &#34;Sol&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Sol&#39;, &#39;Spectrum&#39;, &#39;G2V&#39;)
    ok($I0, &#39;Sol should have ProperName &#34;Sol&#34; and Spectrum &#34;G2V&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Arcturus&#39;, &#39;Spectrum&#39;, &#39;G2V&#39;)
    nok($I0, &#39;Sol should not have ProperName &#34;Arcturus&#34; and Spectrum &#34;G2V&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Sol&#39;, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have ProperName &#34;Sol&#34; and Spectrum &#34;K3V&#34;&#39;)
    $I0 = check_star(star, &#39;ProperName&#39;, &#39;Arcturus&#39;, &#39;Spectrum&#39;, &#39;K3V&#39;)
    nok($I0, &#39;Sol should not have ProperName &#34;Arcturus&#34; and Spectrum &#34;K3V&#34;&#39;)
.end</code></pre>
</figure><p>Yes, I did go through several variations on testing multiple fields. I wanted to
make sure that <code>check_star</code> behaved <em>exactly</em> the way I expected. How am I going
to make those tests succeed?</p>
<h4 id="slurpy-and-flat-save-the-day"><code>:slurpy</code> and <code>:flat</code> Save the Day</h4>
<p>Parrot gives us two excellent modifiers that simplify the job of checking
multiple fields. The <code>:slurpy</code> param modifier to effectively say &ldquo;Oh,
there might be some other params. Just put them in an array.&rdquo; The flip side of
that is the <code>:flat</code> modifier in subroutine calls, which lets us say &ldquo;Oh, I have
this array of stuff. Just tack its elements to the param list for the sub I&rsquo;m
about to call.&rdquo;</p>
<p>Enough imaginary dialog. Here&rsquo;s what <code>check_star</code> looks like.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-07/lib/stellar.pir
.sub check_star
    .param pmc    star
    .param string field
    .param string desired_value
    .param pmc    extra_fields :slurpy
    .local int    match_result
    .local int    extra_field_count

    match_result = check_star_field(star, field, desired_value)

    # We&#39;re done if this match fails.
    unless match_result goto RETURN_RESULT

    extra_field_count = extra_fields
    # We&#39;re done if there are no extra fields.
    unless extra_field_count goto RETURN_RESULT

    # Grab the result of checking the extra fields.
    match_result = check_star(star, extra_fields :flat)

  RETURN_RESULT:
    .return(match_result)
.end</code></pre>
</figure><p>I tried to make it clear what was going on the comments. <code>check_star</code> is given a
star and a handful of conditions. It only cares about the first condition, and
stuffs the rest into <code>extra_fields</code>. If the first condition fails, we&rsquo;re done.
There&rsquo;s no point in checking any more fields, so jump down to return the failure.
If there are no other conditions to check - which we determine by looking at
the size of <code>extra_fields</code> - we return the result, which should be a success.</p>
<p>If there <em>are</em> more conditions to check, we call <code>check_star</code> again, using the
star and the conditions we had stuffed into <code>extra_fields</code>. That goes through
the same process of testing and looking for extra conditions until it has
completed the last test. The result of all the completed tests is handed back to
<code>check_star</code>, which then hands it back to us.</p>
<p>This process of <a href="http://en.wikipedia.org/wiki/Recursion_%28computer_science%29">recursion</a> -
solving a complex problem by breaking it down into small problems - is common in
many programming languages, so it is supported by Parrot. After all, Parrot is
supposed to be used for creating new languages. It is not just for
browsing some guy&rsquo;s star catalog.</p>
<p>The &ldquo;<a href="http://en.wikipedia.org/wiki/Tail_call">tail call</a>&rdquo; pattern of evaluating a sub and immediately returning its result is so
common that Parrot provides the <code>.tailcall</code> directive to optimize its
behavior. <code>.tailcall</code> essentially tells Parrot to immediately return the result
of evaluating the sub rather than storing it in memory. It may not do much in a
case like <code>check_star</code>, but you should see a difference in complex problems.</p>
<p>Then again, it might help <code>check_star</code> immensely. I don&rsquo;t really know about
Parrot optimization effects yet.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0b-08/lib/stellar.pir
.sub &#39;main&#39; :main
    # ...

    # Return the result of checking the extra fields.
    .tailcall check_star(star, extra_fields :flat)

  RETURN_RESULT:
    .return(match_result)
.end</code></pre>
</figure><h2 id="conclusion">Conclusion</h2>
<p>We can now examine multiple fields to determine if a star matches a description
we&rsquo;ve provided. Along the way, we explored subroutine parameters. We learned how
to make a parameter optional. We learned how to grab all of a subroutine&rsquo;s
params and stuff them into a list. We also learned how to paste the contents of
a list onto the parameters of a subroutine call. We even dabbled in
<a href="http://en.wikipedia.org/wiki/Recursion_%28computer_science%29">recursion</a>, the fine art of breaking a big problem down with small solutions.</p>
<p>In our next step, we will use <code>check_star</code> to search through sets of stars.
That&rsquo;s the part I&rsquo;ve been looking forward to for a while!</p>
<p>In the meantime, continue your own [Parrot][] exploration. You might review the
Parrot <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch06_subroutines.pod.html">Subroutines chapter</a> a little more. I hardly left that page while
working through this step. Whatever you do, remember to have fun!</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 0a - The Stellar Project</title>
  <link>https://randomgeekery.org/post/2010/06/parrot-babysteps-0a-the-stellar-project/</link>
  <pubDate>Wed, 02 Jun 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/06/parrot-babysteps-0a-the-stellar-project/</guid>
  <description>We just learned how to create and test simple Parrot projects. The next step is to reexamine the star catalog handler we’ve been writing, and turn it into a testable project. There will be some changes in how this code gets its work done, but don’t expect any new features.
I know - you really want to start adding features and working on cool new stuff. So do I. My workspace is scattered with half-completed steps that talked about adding new things and using new Parrot features.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>space</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>We just learned how to create and test <a href="/post/2010/04/parrot-babysteps-09-simple-projects">simple Parrot projects</a>. The next step
is to reexamine the star catalog handler we&rsquo;ve <a href="/post/2009/10/parrot-babysteps-07-writing-subroutines">been writing</a>, and turn it
into a testable project. There will be some changes in how this code gets its
work done, but don&rsquo;t expect any new features.</p>
<p>I know - you <em>really</em> want to start adding features and working on cool new
stuff. So do I. My workspace is scattered with half-completed steps that talked
about adding new things and using new <a href="/card/parrot/">Parrot</a> features. They kept breaking,
though. They kept breaking because I wasn&rsquo;t building from a stable, testable
foundation. Today we&rsquo;re going to get that step our of the way.</p>
<h2 id="set-up-the-project">Set up the project</h2>
<p>Let&rsquo;s apply what we learned last time putting together <a href="/post/2010/04/parrot-babysteps-09-simple-projects">larger projects</a>, and
set up a project named <code>stellar</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mkdir stellar
$ mkdir stellar/t
$ mkdir stellar/lib</code></pre>
</figure><p>The <code>setup.pir</code> file is copied directly from the previous project. I&rsquo;m not ready
for anything more elaborate.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-01/setup.pir
.sub &#39;main&#39; :main
    .param pmc args
    $S0 = shift args # Ignore my own filename
    load_bytecode &#39;distutils.pbc&#39;

    # Find out what command the user has issued
    .local string directive
    directive = shift args

    # Used by the test mode
    .local string prove_exec
    prove_exec = get_parrot()

    setup(directive, &#39;prove_exec&#39; =&gt; prove_exec)
.end</code></pre>
</figure><p>The behavior will be defined in <code>lib/stellar.pir</code>, which is initially
empty. We will steadily build up all of our functionality in the Stellar library
and eventually add a very simple file to act as the face of Stellar for
Parrot. Right now, we just have an empty <code>lib/stellar.pir</code>.</p>
<h2 id="reimplementing-features">Reimplementing Features</h2>
<p>The basic skeleton is in place. Now we can start adding the features we had
written before.</p>
<h3 id="extracting-details">Extracting Details</h3>
<p>It&rsquo;s important to keep test files organized. One helpful approach is to think of
each test as a story. This story describes a single specific thing we want the
Stellar library to accomplish. All of the stories together provide a description
of everything that users should be able to get from the library.</p>
<p>I like to start with the smallest useful test story I can. For this code, I
think that would be extracting the details about a single entry in the HYG
catalog. The whole catalog isn&rsquo;t even needed. We could get away with using the
header line and the line containing a star&rsquo;s details.</p>
<p>Names for test files usually follow a common pattern. They start with a number
and summarize what feature is being tested. What purpose does the number serve?
Well, they are probably executed in the order that Parrot finds them, so that
numbering provides a clue for test order. There are no promises about the order,
though. The system looks at each story individually, and you should too. I like
to think of the numbering as simply presenting the order that I came up with the
stories. It provides a simple history of sorts. First I came up with that test,
and I wrote this test after I was comfortable with the first.</p>
<p>In that spirit, I will name the first test story <code>01-extract-details.t</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-01/t/01-extract-details.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string sol_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star_fields
    .local pmc    star

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    sol_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    delimiter = &#34;,&#34;

    header_fields = split delimiter, header_string
    star_fields = split delimiter, sol_string
    star = extract_star_details(header_fields, star_fields)

    plan(1)

    $S0 = star[&#39;Proper Name&#39;]
    is($S0, &#39;Sol&#39;, &#39;ProperName should be Sol&#39;)
.end</code></pre>
</figure><p>Yes, I know that there is a typo in this test code. The key <code>Proper Name</code> should be
<code>ProperName</code>. We&rsquo;ll come back to that.</p>
<p>What happens if this test is run while <code>stellar.pir</code> is still empty? It fails,
of course. It might be useful to look at <em>how</em> it fails.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >stellar $ parrot setup.pir test
t/01-extract-details.t .. Dubious, test returned 1
Failed 1/1 subtests

Test Summary Report
-------------------
t/01-extract-details.t (Tests: 0 Failed: 0)
XXX
Files=1, Tests=0,  0.014 wallclock secs
Result: FAIL
test fails
current instr.: &#39;setup&#39; pc 883 (runtime/parrot/library/distutils.pir:376)
called from Sub &#39;main&#39; pc 29 (setup.pir:17)</code></pre>
</figure><p><code>setup</code> told us something we already know: <code>extract_star_details</code> hasn&rsquo;t been
written yet. This is different from a regular test failure, because Parrot
couldn&rsquo;t even get to the tests. I&rsquo;m showing this so that you recognize what&rsquo;s
going on when you see errors like this in your own library.</p>
<p>Adding <code>extract_star_details</code> is easy enough. Just copy the code from the
earlier step.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># stellar/lib/stellar.pir

.sub extract_star_details
    .param pmc    headers
    .param pmc    values

    .local pmc    star
    .local int    header_count
    .local string current_header
    .local string current_value
    .local int    current_index

    current_index = 0
    header_count = headers
    star = new &#39;Hash&#39;

  ASSIGN_NEXT_STAR_FIELD:
    if current_index &gt;= header_count goto RETURN_STAR
    current_header = headers[current_index]
    current_value = values[current_index]
    star[current_header] = current_value
    current_index &#43;= 1
    goto ASSIGN_NEXT_STAR_FIELD

  RETURN_STAR:
    .return(star)
.end</code></pre>
</figure><p>Let&rsquo;s run the test again.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-extract-details.t .. Failed 1/1 subtests

Test Summary Report
-------------------
t/01-extract-details.t (Tests: 1 Failed: 1)
  Failed test:  1
Files=1, Tests=1,  0.020 wallclock secs
Result: FAIL
test fails
current instr.: &#39;setup&#39; pc 883 (runtime/parrot/library/distutils.pir:376)
called from Sub &#39;main&#39; pc 29 (setup.pir:17)</code></pre>
</figure><p>There&rsquo;s only one assertion, so we already know which one failed. This output is a
little vague for larger test stories, though. Let&rsquo;s run the test file directly.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >#!text
$ parrot t/01-extract-details.t
1..1
not ok 1 - ProperName should be Sol
# Have:
# Want: Sol</code></pre>
</figure><p>Okay, <em>now</em> we can fix the typo.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >#!parrot
# t/01-extract-details.t
.sub &#39;main&#39; :main
    ...
    $S0 = star[&#39;ProperName&#39;]
    is($S0, &#39;Sol&#39;, &#39;ProperName should be Sol&#39;)
.end</code></pre>
</figure><p>The test should pass now that the correction has been made.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >#!text
$ parrot setup.pir test
t/01-extract-details.t .. ok
All tests successful.
Files=1, Tests=1,  0.014 wallclock secs
Result: PASS</code></pre>
</figure><p>Don&rsquo;t worry. I won&rsquo;t submit you to this for every test run. It&rsquo;s just important
to know what failure looks like before we can reach success.</p>
<p>What have we accomplished so far? We now have a story in which the user, armed
with a header line and a line describing a star, gets an object that she can
examine and manipulate for her own purposes. If we wanted to be thorough, we
could test every field. I&rsquo;m not going to do that, though. One thing you want to
avoid when making test stories is predicting the future. It&rsquo;s easy to get
distracted by testing every possible aspect of a single chunk of code when you
could be working on the next story.</p>
<p>These stories aren&rsquo;t static. We will come back and add more when some
detail doesn&rsquo;t work out the way we expect it to.</p>
<p>Our first story is pretty much out of the way. Let&rsquo;s move on to the next one.</p>
<h3 id="stringifying-stars">Stringifying Stars</h3>
<p>Next up is the string representation of a star. In the original application, we
had the <code>say_star_details</code> sub, which printed the star information as soon as it
had been prepared. <code>Stellar</code> is more of a library, though. This means that we
can&rsquo;t be completely sure what folks will want to do with the star summary once
they have it. They might want to print it, but they might also want to feed it
to an unmanned orbiter for some reason.</p>
<p>Because we can&rsquo;t predict with certainty what someone will do with the string
summary of a star, this test story will focus on asking for that string.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># t/02-summarize-star.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string sol_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star_fields
    .local pmc    star
    .local string summary

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    sol_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    delimiter = &#34;,&#34;

    plan(1)

    header_fields = split delimiter, header_string
    star_fields = split delimiter, sol_string
    star = extract_star_details(header_fields, star_fields)

    summary = &#34;&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;&#34;
    $S0 = summarize_star(star)
    is($S0, summary, &#34;Sol&#39;s summary should include basic details&#34;)
.end</code></pre>
</figure><p>It&rsquo;s not hard to create the code which will make this story true, but it does
involve a little more work than the simple copy and paste for
<code>extract_star_details</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-04/lib/stellar.pir

# ...

.sub summarize_star
    .param pmc star

    .local string star_name
    .local string star_spectrum
    .local string star_distance
    .local string summary

    star_name = star[&#39;ProperName&#39;]
    star_spectrum = star[&#39;Spectrum&#39;]
    star_distance = star[&#39;Distance&#39;]

    if star_name goto PREPARE_SUMMARY

  TRY_GLIESE:
    .local string gliese_number
    gliese_number = star[&#39;Gliese&#39;]
    unless gliese_number goto TRY_BAYER_FLAMSTEED
    star_name = &#39;Gliese &#39; . gliese_number
    goto PREPARE_SUMMARY

  TRY_BAYER_FLAMSTEED:
    .local string bayer_flamsteed
    bayer_flamsteed = star[&#39;BayerFlamsteed&#39;]
    unless bayer_flamsteed goto TRY_HR
    star_name = &#34;BF &#34; . bayer_flamsteed
    goto PREPARE_SUMMARY

  TRY_HR:
    .local string hr_id
    hr_id = star[&#39;HR&#39;]
    unless hr_id goto TRY_HD
    star_name = &#34;HR &#34; . hr_id
    goto PREPARE_SUMMARY

  TRY_HD:
    .local string hd_id
    hd_id = star[&#39;HD&#39;]
    unless hd_id goto USE_STAR_ID
    star_name = &#34;HD &#34; . hd_id
    goto PREPARE_SUMMARY

  TRY_HIP:
    .local string hip_id
    hip_id = star[&#39;HIP&#39;]
    unless hip_id goto USE_STAR_ID
    star_name = &#34;HIP &#34; . hip_id
    goto PREPARE_SUMMARY

  USE_STAR_ID:
    .local string star_id
    star_id = star[&#39;StarID&#39;]
    star_name = &#34;HYG &#34; . star_id
    goto PREPARE_SUMMARY

  PREPARE_SUMMARY:
    summary = &#34;&lt;Name: &#34;
    summary .= star_name
    summary .= &#34;, Spectrum: &#34;
    summary .= star_spectrum
    summary .= &#34;, Distance: &#34;
    summary .= star_distance
    summary .= &#34;&gt;&#34;

    .return(summary)
.end</code></pre>
</figure><p>Yes, this is mostly a copy and paste of <code>say_star_details</code>. The new details
change the focus from displaying the details to returning them as a simple
string.</p>
<p>What&rsquo;s most important is that this test passes when handed Sol. How about some
of those stars that don&rsquo;t have proper names?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-04/t/02-summarize-star.t
.include &#39;lib/stellar.pir&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star_fields
    .local pmc    star
    .local string summary

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    delimiter = &#34;,&#34;

    plan(3)

    header_fields = split delimiter, header_string

    summary = &#34;&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;&#34;
    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;Sol&#39;s summary should include basic details&#34;)

    summary = &#34;&lt;Name: HD 224693, Spectrum: G2V, Distance: 94.0733772342427&gt;&#34;
    star_string = &#34;117952,118319,224693,,,,,23.99826083,-22.42818030,94.0733772342427,148.74,27.53,,8.23,3.36266632261649,G2V,0.639,86.95751,-0.03959,-35.89135,4.82e-06,6.7829e-05,1.1605e-05&#34;
    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;HD identifier can be used if ProperName is unavailable&#34;)

    summary = &#34;&lt;Name: HYG 117782, Spectrum: G2V, Distance: 139.275766016713&gt;&#34;
    star_string = &#34;117782,118149,,,,,,23.96625102,15.95292997,139.275766016713,-46.50,-53.88,,9.59,3.8706222212115,G2V,0.648,133.90672,-1.18315,38.2796,9.72e-06,-3.1482e-05,-3.4977e-05&#34;
    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;HYG identifier can be used if ProperName is unavailable&#34;)
.end</code></pre>
</figure><p>It does indeed work.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-extract-details.t .. ok
t/02-summarize-star.t ... ok
All tests successful.
Files=2, Tests=4,  0.030 wallclock secs
Result: PASS</code></pre>
</figure><p>I am concerned about the heft of this test code. The concern is that I
had to split the CSV text, extract star details, and summarize the star
manually for each star string. Each of those times is an opportunity for me to
make a mistake. I <em>think</em> I would like to have a subroutine which would take the
header fields and a CSV line of star data, and return the extracted details.
Let&rsquo;s make a new test story for that.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-04/t/03-extract-from-csv.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local string header_string
    .local string star_string
    .local string delimiter
    .local pmc    header_fields
    .local pmc    star_fields
    .local pmc    star
    .local string summary

    header_string = &#34;StarID,HIP,HD,HR,Gliese,BayerFlamsteed,ProperName,RA,Dec,Distance,PMRA,PMDec,RV,Mag,AbsMag,Spectrum,ColorIndex,X,Y,Z,VX,VY,VZ&#34;
    delimiter = &#34;,&#34;

    plan(3)

    header_fields = split delimiter, header_string

    summary = &#34;&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;&#34;
    star_string = &#34;0,,,,,,Sol,0,0,0.000004848,0,0,0,-26.73,4.85,G2V,0.656,0,0,0,0,0,0&#34;
    star = extract_from_csv_line(star_string, header_fields, delimiter)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;Sol&#39;s summary should include basic details&#34;)

    summary = &#34;&lt;Name: HD 224693, Spectrum: G2V, Distance: 94.0733772342427&gt;&#34;
    star_string = &#34;117952,118319,224693,,,,,23.99826083,-22.42818030,94.0733772342427,148.74,27.53,,8.23,3.36266632261649,G2V,0.639,86.95751,-0.03959,-35.89135,4.82e-06,6.7829e-05,1.1605e-05&#34;
    star = extract_from_csv_line(star_string, header_fields, delimiter)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;HD identifier can be used if ProperName is unavailable&#34;)

    summary = &#34;&lt;Name: HYG 117782, Spectrum: G2V, Distance: 139.275766016713&gt;&#34;
    star_string = &#34;117782,118149,,,,,,23.96625102,15.95292997,139.275766016713,-46.50,-53.88,,9.59,3.8706222212115,G2V,0.648,133.90672,-1.18315,38.2796,9.72e-06,-3.1482e-05,-3.4977e-05&#34;
    star = extract_from_csv_line(star_string, header_fields, delimiter)
    $S0 = summarize_star(star)
    is($S0, summary, &#34;HYG identifier can be used if ProperName is unavailable&#34;)
.end</code></pre>
</figure><p>The code to make this work is simple enough.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-0a-04/lib/stellar.pir

# ...

.sub extract_from_csv_line
    .param string star_string
    .param pmc    header_fields
    .param string delimiter
    .local pmc    star_fields
    .local pmc    star

    star_fields = split delimiter, star_string
    star = extract_star_details(header_fields, star_fields)

    .return(star)
.end</code></pre>
</figure><p>I do not know if I have saved much work, but it is easier for me to read the
test story. That is important to me, because debugging and improving the code is
easier if I can easily understand what is happening.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It is time to take a break. The script we wrote a while back is evolving into a
tested library that can be used by others. Now that we have our foundation, we
can start building up. Our next step will involve adding some simple search
behavior to the library, and that is a significant improvement. For the moment,
take a little time to relax.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 09 - Simple Projects</title>
  <link>https://randomgeekery.org/post/2010/04/parrot-babysteps-09-simple-projects/</link>
  <pubDate>Thu, 29 Apr 2010 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2010/04/parrot-babysteps-09-simple-projects/</guid>
  <description>Introduction I spent a lot of time exploring Parrot testing with Test::More in the last step. That’s because I want to start building larger projects, and testing is a vital part of most projects. Another major part is a properly organized workspace with a script that can simplify testing or other tasks.
Creating a Simple Project A nice Parrot project layout includes a t folder for tests, a lib folder for library code, and a setup.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>I spent a lot of time exploring <a href="/card/parrot/">Parrot</a> testing with <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> in the <a href="/post/2009/12/parrot-babysteps-08-testing-with-testmore">last step</a>. That&rsquo;s because
I want to start building larger projects, and testing is a vital part of most
projects. Another major part is a properly organized workspace with a script that
can simplify testing or other tasks.</p>
<h2 id="creating-a-simple-project">Creating a Simple Project</h2>
<p>A nice Parrot project layout includes a <code>t</code> folder for tests, a <code>lib</code> folder for
library code, and a <code>setup.pir</code> file to drive the whole thing.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ mkdir simple-pir
$ mkdir simple-pir/t
$ mkdir simple-pir/lib
$ cd simple-pir</code></pre>
</figure><p>What gets placed in <code>setup.pir</code>? Not much, considering how much it does.
<code>setup.pir</code> takes advantage of the Parrot <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/distutils.pir">distutils</a> module for a whole range
of tasks. All I&rsquo;m concerned about today is <em>testing</em>, so my setup is going to be
rather lightweight.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-01/setup.pir
.sub &#39;main&#39; :main
    .param pmc args
    $S0 = shift args # Ignore my own filename
    load_bytecode &#39;distutils.pbc&#39;

    # Find out what command the user has issued
    .local string directive
    directive = shift args

    setup(directive)
.end</code></pre>
</figure><p>This is not exciting code, but it is enough to see what distutils <em>can</em> give me.
The first command line parameter is shifted onto a dummy register variable,
because I don&rsquo;t really care about the name of <code>setup.pir</code> from within
<code>setup.pir</code>.  Then I load the <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/distutils.pir">distutils</a> bytecode so I can get access to the <code>setup</code> subroutine.</p>
<p>This <code>setup.pir</code> will get more complicated as we go on, and you will
<em>definitely</em> see more complex <code>setup.pir</code> files out in the wild, but this will
get us started.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir help
usage: parrot setup.pir [target|--key value]*

    Default targets are :

        build:          Build the library.

        test:           Run the test suite.

        install:        Install the library.

        uninstall:      Uninstall the library.

        clean:          Basic cleaning up.

        update:         Update from the repository.

        plumage:        Output a skeleton for Plumage

        sdist:          Create a source distribution

        bdist:          Create a binary distribution

        help:           Print this help message.</code></pre>
</figure><p>What happens when I tell <code>setup.pir</code> that I want to test?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
Files=0, Tests=0,  0.000 wallclock secs
Result: NOTESTS</code></pre>
</figure><p>Well of course it failed. There aren&rsquo;t any test files, and <code>setup.pir</code> wouldn&rsquo;t
know how to run them if there were!</p>
<p>I&rsquo;ll fix the second part first.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-02/setup.pir
.sub &#39;main&#39; :main
    .param pmc args
    $S0 = shift args # Ignore my own filename
    load_bytecode &#39;distutils.pbc&#39;

    # Find out what command the user has issued
    .local string directive
    directive = shift args

    # Used by the test mode
    .local string prove_exec
    prove_exec = get_parrot()

    setup(directive, &#39;prove_exec&#39; =&gt; prove_exec)
.end</code></pre>
</figure><p>Parrot allows you to use <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch06_subroutines.pod.html#Named_Parameters">named parameters</a> for some subroutines, and <code>setup</code>
takes full advantage of that feature. If you&rsquo;re used to <a href="/tags/perl/">Perl</a> or <a href="/tags/ruby/">Ruby</a>,
named parameters look a lot like a hash. That&rsquo;s close enough for our purposes. A
named parameter generally follows a simple format:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&#39;&lt;key-1&gt;&#39; =&gt; &#39;&lt;value-1&gt;&#39;</code></pre>
</figure><p>Thankfully, <code>distutils.pir</code> is a well-documented module, and you
can find details about the many options by checking the documentation.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ perldoc /usr/local/lib/parrot/3.0.0/library/distutils.pir</code></pre>
</figure><p>I only care about a single option: <code>prove_exec</code>, which tells <code>setup</code> what program
will be used to run the tests. Why does <code>setup</code> care? Well, Parrot is a VM. Your
tests can be in PIR, NQP, <a href="/tags/raku-lang/">Rakudo</a>, or even a language of your own design.
These <a href="/post/2009/07/parrot-babysteps">Babysteps</a> are about Parrot PIR, so it makes sense that the tests will be in
the same language.</p>
<p>Oh yes, the tests. Let&rsquo;s write one. I&rsquo;ll follow the convention I see in the Perl
world of a number followed by a description for the test filename, and the test
itself will be for a simple area calculating function.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-02/t/01-radius.t
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;
    .local num radius
    .local num expected_area, actual_area

    plan(1)

    radius = 1.0
    expected_area = 3.1415926
    actual_area = area_of_circle(radius)
    is(expected_area, actual_area, &#39;Circle with radius 1 should have area PI&#39;, 1e-6)
.end</code></pre>
</figure><p>So - this should fail, right?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-radius.t .. Dubious, test returned 1
Failed 1/1 subtests 

Test Summary Report
-------------------
t/01-radius.t (Tests: 0 Failed: 0)
  Non-zero exit status: 1
  Parse errors: Unknown TAP token: &#34;Could not find sub area_of_circle&#34;
                Unknown TAP token: &#34;current instr.: &#39;main&#39; pc 40
(t/01-radius.t:13)&#34;
                Bad plan.  You planned 1 tests but ran 0.
Files=1, Tests=0,  0.021 wallclock secs
Result: FAIL
test fails
current instr.: &#39;setup&#39; pc 883 (runtime/parrot/library/distutils.pir:376)
called from Sub &#39;main&#39; pc 29 (setup.pir:18)</code></pre>
</figure><p>Excellent. Parrot didn&rsquo;t just tell us that the test failed. It also told us
about some unexpected output from our test script. What&rsquo;s that unexpected
output? Oh, something about not having a subroutine called <code>area_of_circle</code>.
Let&rsquo;s fix that by adding a new library file called <code>lib/area.pir</code>, and adding
the missing subroutine.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-03/lib/area.pir

.sub area_of_circle
    .param num radius
    .const num PI = 3.1415926
    .local num area

    area = PI
    area *= radius
    area *= radius

    .return(area)
.end</code></pre>
</figure><p>This is code borrowed from <a href="/post/2009/07/parrot-babysteps-02-variables-and-types">step 2</a> and dropped into a subroutine.</p>
<p>Don&rsquo;t forget to include this library code from your test file.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-09-03/lib/area.pir

.include &#39;lib/area.pir&#39;

.sub &#39;main&#39; :main
    # ...
.end</code></pre>
</figure><p>Did it work?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot setup.pir test
t/01-radius.t .. ok
All tests successful.
Files=1, Tests=1,  0.016 wallclock secs
Result: PASS</code></pre>
</figure><p>Yay!</p>
<p>Hold on a second. I snuck an extra argument back when I wrote the <code>is</code> assertion. What was that
all about? Well, <a href="http://leto.net">Jonathan Leto</a> explained to me that <code>is</code> takes an additional argument
for precision, which is useful in the fuzzy world of <a href="http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">floating point
math</a> on
a modern computer. The <code>1e-6</code> requirement asks Parrot to make sure <code>expected_area</code>
and <code>actual_area</code> look the same down to six places past the decimal point.</p>
<p>This approach of writing the tests before you write the code is called TDD, for
<a href="http://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a>. I like TDD because I&rsquo;m basically describing the next
thing I want my library or application to do. That&rsquo;s perfect for me, since I&rsquo;m such
a chatty person. Well, I&rsquo;m chatty when typing at the computer.</p>
<p>You don&rsquo;t need to follow a
test driven approach, but other developers will like you more if you consistently
test the code you write. The easiest way to consistently test it is to write the
test before you write the code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Combining what we&rsquo;ve learned about <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> with <code>setup.pir</code> allows us to
confidently build more complicated applications, testing as we go along. It is
true that all we know how to do with <code>setup.pir</code> at this point is ask it to run
tests for us, but even that can save a lot of work.</p>
<p>I don&rsquo;t know about you, but I&rsquo;m ready to take another look at that star catalog.</p>
]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 08 - Testing With Test::More</title>
  <link>https://randomgeekery.org/post/2009/12/parrot-babysteps-08-testing-with-testmore/</link>
  <pubDate>Wed, 16 Dec 2009 00:00:00 -0800</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/12/parrot-babysteps-08-testing-with-testmore/</guid>
  <description>&lt;p&gt;Co-written by &lt;a href=&#34;http://leto.net&#34;&gt;Jonathan “Duke” Leto&lt;/a&gt;, &lt;a href=&#34;https://randomgeekery.org/card/parrot/&#34;&gt;Parrot&lt;/a&gt; core developer
and author of &lt;a href=&#34;http://github.com/leto/tapir&#34;&gt;Tapir&lt;/a&gt;.&lt;/p&gt;</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<p>Co-written by <a href="http://leto.net">Jonathan &ldquo;Duke&rdquo; Leto</a>, <a href="/card/parrot/">Parrot</a> core developer
and author of <a href="http://github.com/leto/tapir">Tapir</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>I&rsquo;ll be creating more complex PIR programs soon, but first I want to stop for a minute and look at
testing in Parrot. Why? Code is a weird thing. You need to pin
down its behavior as specifically as you can, or it&rsquo;ll become
unreadable before you realize what&rsquo;s going on. Good tests help you describe
how your program should behave. Tests aren&rsquo;t a magic pill that will guarantee
perfect programs, but they <em>will</em> help you check that your program behaves the
way you claim it does.</p>
<p>There are many testing libraries in the programming world, but I will focus
on <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> for Parrot.</p>
<h2 id="using-testmore-to-write-tests">Using Test::More to Write Tests</h2>
<p><a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> is more or less an implementation of <a href="http://perldoc.perl.org/Test/More.html">Perl&rsquo;s Test::More</a>. It provides a set of simple
assertions such as <code>ok</code>, <code>is</code>, and <code>isnt</code>, along with a few testing-specific
commands like <code>skip</code> and <code>todo</code>. I&rsquo;ll be looking at some of those simple assertions, but
not spending so much time on the testing commands. This <em>is</em> a Babystep, after all.</p>
<p>Test::More is already included in the standard Parrot runtime, so we don&rsquo;t need
to do anything special to install it. Even better - there&rsquo;s a <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">test_more.pir</a> include
file that you can include to import all of the important Test::More subroutines
automatically.</p>
<p>Let&rsquo;s start writing tests.</p>
<h3 id="plan"><code>plan</code></h3>
<p>Every test needs a plan. The <code>plan</code> subroutine in Test::More tells the world
one simple thing: how many tests are in this file. Accuracy is important,
because it&rsquo;s no fun when you are told to expect ten tests but only five run.
The other five might not have run for a number of reasons: the test script failed,
Parrot failed in some mysterious way, or you just forgot to mention that you
removed half of your tests.</p>
<p>We don&rsquo;t plan to have any tests yet, so let&rsquo;s be honest.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-01.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(0)
.end</code></pre>
</figure><p>The <code>.include</code> directive will insert the contents of <code>test_more.pir</code> into the
subroutine, which saves us a lot of namespace wrangling. The testing starts
when a <em>plan</em> is declared.</p>
<p>Of course, this is <em>not</em> the most exciting test plan in the world to run.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-01.pir
$</code></pre>
</figure><p>What if we lie?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-02.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(10)
.end</code></pre>
</figure><p>Running this is a little different.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-02.pir
1..10</code></pre>
</figure><p>Now Parrot is telling whoever cares that there will be ten tests in this file.
It&rsquo;s true that nothing exploded. For right now, you&rsquo;re going to have to trust me
when I say that honesty is the best policy. You&rsquo;ll see later that some tools
do care about how many tests you claim to run.</p>
<h3 id="diag"><code>diag</code></h3>
<p>All right. Sometimes we want to make a comment in our test for the world to see.
We could just <code>say</code> what we want to say, but Test::More provides the <code>diag</code>
subroutine to produce those comments in a manner that will make testers happy later.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-03.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(10)
    diag(&#39;There are no tests. The plan is a lie.&#39;)
.end</code></pre>
</figure><p>What does this produce?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-03.pir
1..10
# There are no tests. The plan is a lie.</code></pre>
</figure><p>See the <code>#</code>? That&rsquo;s supposed to make our diagnostic comment stand out from
the test results without confusing anyone. But the diagnostic makes me sad.
Let&rsquo;s write an actual test.</p>
<h3 id="ok"><code>ok</code></h3>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-04.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(1)
    ok(1, &#39;`ok` tests for simple truth&#39;)
.end</code></pre>
</figure><p><code>ok</code> takes two arguments:</p>
<ul>
<li>The value you are testing</li>
<li>A description of the test</li>
</ul>
<p>The value being tested is obviously the most important part, but don&rsquo;t underestimate
the helpfulness of those descriptions. They are a form of documentation.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-04.pir
1..1
ok 1 - `ok` tests for simple truth</code></pre>
</figure><p>The test in <code>ok</code> is one of simple truth as seen by Parrot. <a href="/post/2009/09/parrot-babysteps-03-simple-control-structures/">parrot-babysteps-03-simple-control-structures</a> showed us that anything which looks like <code>0</code> or an empty string is considered false by Parrot, while everything else is considered true.</p>
<p>What happens when we introduce a test that we know will fail?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-05.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    plan(2)
    ok(1, &#39;`ok` tests for simple truth&#39;)
    ok(0, &#39;0 is false, so this should fail.&#39;)
.end</code></pre>
</figure><p>You updated your plan, right? Anyways, let&rsquo;s see what this produces.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-05.pir
1..2
ok 1 - `ok` tests for simple truth
not ok 2 - 0 is false, so this should fail.</code></pre>
</figure><p>Oh hey, this is starting to get interesting! Now we can see clearly that the output
from <code>ok</code> is a line split into three parts:</p>
<ul>
<li>The result of the test: &ldquo;<code>ok</code>&rdquo; or &ldquo;<code>not ok</code>&rdquo;</li>
<li>The test number</li>
<li>Our description string</li>
</ul>
<p><code>ok</code> has shown us what a test result line looks like. Let&rsquo;s look at
some of the other simple assertions.</p>
<h3 id="nok"><code>nok</code></h3>
<p>Sometimes you are more concerned if something is true which shouldn&rsquo;t be. For
example, let&rsquo;s say we have a Web site building script. It builds temporary
cache files to save time when building subpage links, but those cache files
need to go away when it&rsquo;s done. So we would test for existence of a cache file
and fail if the file exists.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-06.pir

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local int cache_file_exists

    plan(1)
    cache_file_exists = stat &#39;subpages.data&#39;, 0
    nok(cache_file_exists, &#39;Cache files should be cleaned up&#39;)
.end</code></pre>
</figure><p>The assertion may be <code>nok</code>, but the output is still <code>ok</code> or not based on whether
the assertion was true.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-06.pir
1..1
ok 1 - Cache files should be cleaned up</code></pre>
</figure><p>What does it look like if we deliberately confuse things?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ touch subpages.data
$ parrot example-08-06.pir
1..1
not ok 1 - Cache files should be cleaned up</code></pre>
</figure><p>Yes. That&rsquo;s what I hoped to see. Let&rsquo;s clean up after ourselves to avoid future
confusion.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ rm subpages.data</code></pre>
</figure><h3 id="is"><code>is</code></h3>
<p>There are many times where we want to compare two values. Let&rsquo;s continue with our Web site
building tool. This tool sets the title of a page in metadata. We obviously want to be
certain that it reads the metadata correctly. We would use the <code>is</code> assertion for
that kind of test.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-07.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local string expected_title
    .local string actual_title

    expected_title = &#39;08 - Test::More and Tapir&#39;

    plan(1)

    # Okay, let&#39;s pretend we got this result by running the builder.
    actual_title = &#39;08 - Test::More and Tapir&#39;
    is(actual_title, expected_title, &#39;The title should be correct.&#39;)
.end</code></pre>
</figure><p>Anybody know what we should see?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-07.pir
1..1
ok 1 - The title should be correct.</code></pre>
</figure><p>Let&rsquo;s deliberately mess things up again so we know what failure of <code>is</code> looks like.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-08.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local string expected_title
    .local string actual_title

    expected_title = &#39;08 - Test::More and Tapir&#39;

    plan(1)

    # Okay, let&#39;s pretend we got this result by running the builder.
    actual_title = &#39;I am a Walrus&#39;
    is(actual_title, expected_title, &#39;The title should be correct.&#39;)
.end</code></pre>
</figure><p>A failed <code>is</code> produces some useful information.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-08.pir
1..1
not ok 1 - The title should be correct.
# Have: I am a Walrus
# Want: 08 - Test::More and Tapir</code></pre>
</figure><p>There&rsquo;s the test result line, which shows &rsquo;not ok&rsquo;, just like we expected.
We also have a couple of diagnostic lines describing what we want and what we
actually have.</p>
<p><code>ok</code> has its opposite assertion <code>nok</code>, so there must be an opposite for <code>is</code>, right?
There sure is.</p>
<h3 id="isnt"><code>isnt</code></h3>
<p>Occasionally we care less about what a value is than making sure it&rsquo;s <em>not</em> something
in particular. Maybe we have a user registration process that uses social security numbers
to satisfy an obscure corporate tracking requirement, but can&rsquo;t save them as-is because of
privacy concerns. In this case we don&rsquo;t care what the stored value is. We want to be certain
that it&rsquo;s not the social security number.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-09.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local string provided_ssn
    .local string stored_ssn

    provided_ssn = &#39;5551234567&#39;

    plan(1)

    # Okay, let&#39;s pretend we got this result via user registration
    stored_ssn = &#39;wxdfk$!&#39;
    isnt(provided_ssn, stored_ssn, &#39;SSN should not be stored as-is&#39;)
.end</code></pre>
</figure><p>Really, nobody should be surprised by the output at this point.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >1..1
ok 1 - SSN should not be stored as-is</code></pre>
</figure><p>What does a failed <code>isnt</code> look like?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-10.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local string provided_ssn
    .local string stored_ssn

    provided_ssn = &#39;5551234567&#39;

    plan(1)

    # Okay, let&#39;s pretend we got this result via user registration
    stored_ssn = provided_ssn
    isnt(provided_ssn, stored_ssn, &#39;SSN should not be stored as-is&#39;)
.end</code></pre>
</figure><p>The output diagnostic is once again straightforward.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-10.pir
1..1
not ok 1 - SSN should not be stored as-is
# Have: 5551234567
# Want: not 5551234567</code></pre>
</figure><h3 id="is_deeply"><code>is_deeply</code></h3>
<p><code>is</code> fails us when we need to compare PMCs. Well, it <em>sort of</em> works:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-11.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local pmc expected_details
    .local pmc actual_details

    expected_details = new &#39;Hash&#39;
    expected_details[&#39;first&#39;] = &#39;Super&#39;
    expected_details[&#39;last&#39;] = &#39;Man&#39;

    actual_details = new &#39;Hash&#39;
    actual_details[&#39;first&#39;] = &#39;Super&#39;
    actual_details[&#39;last&#39;] = &#39;Woman&#39;

    plan(1)

    is(expected_details, actual_details, &#39;Super Man is not Super Woman&#39;)
.end</code></pre>
</figure><p>The output isn&rsquo;t incredibly useful, though.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-11.pir
1..1
not ok 1 - Super Man is not Super Woman
# Have: Hash[0x25ee84]
# Want: Hash[0x25ee48]</code></pre>
</figure><p>Thankfully, we have the <code>is_deeply</code> assertion to tell use exactly how a test
has failed.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-08-12.pir
.sub &#39;main&#39; :main
    .include &#39;test_more.pir&#39;

    .local pmc expected_details
    .local pmc actual_details

    expected_details = new &#39;Hash&#39;
    expected_details[&#39;first&#39;] = &#39;Super&#39;
    expected_details[&#39;last&#39;] = &#39;Man&#39;

    actual_details = new &#39;Hash&#39;
    actual_details[&#39;first&#39;] = &#39;Super&#39;
    actual_details[&#39;last&#39;] = &#39;Woman&#39;

    plan(1)

    is_deeply(expected_details, actual_details, &#39;Super Man is not Super Woman&#39;)
.end</code></pre>
</figure><p>Now we can see exactly which value in the PMC was different.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-08-12.pir
1..1
not ok 1 - Super Man is not Super Woman
# Mismatch at [last]: expected Man, received Woman</code></pre>
</figure><p>With <code>is_deeply</code> under our belt, we now know enough assertions to get started putting them to use in real
projects.</p>
<h3 id="what-about-the-other-assertions-and-commands">What About The Other Assertions and Commands?</h3>
<p>We won&rsquo;t be talking about them. I may eventually visit more as we get
the hang of Parrot, but this is a good enough core to start with. Do
you want to dig deeper? Go right ahead. The best resource for the
moment is the documentation within <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> itself.</p>
<h3 id="tap---the-test-anything-protocol">TAP - The Test Anything Protocol</h3>
<p>All of this output has looked remarkably consistent. There&rsquo;s a reason
for that. <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> formats its result in a format known as TAP - the
<a href="http://en.wikipedia.org/wiki/Test_Anything_Protocol">Test Anything Protocol</a>. All of the output can be read by another program
to provide you with a summary report. This other program is usually referred
to as a <a href="http://en.wikipedia.org/wiki/Test_harness">test harness</a>. The
test harness runs your tests and then tells you how many of them failed, or
if there were any surprises.</p>
<p>All I need is a test harness. I&rsquo;ll be back to talk about <a href="http://github.com/leto/tapir">Tapir</a> very soon.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Hey, we can test now! We learned how to use the <a href="https://github.com/parrot/parrot/blob/RELEASE_3_0_0/runtime/parrot/library/Test/More.pir">Test::More</a> library, making
simple assertions and reporting the results using the <a href="http://en.wikipedia.org/wiki/Test_Anything_Protocol">Test Anything Protocol</a>.
As long as we stay disciplined and run our tests regularly, we will learn
immediately when we have an &ldquo;inspired&rdquo; moment that breaks existing code. Since
I&rsquo;m such a huge fan of Test-Driven Development, you can be assured of seeing many assertions in
future Parrot Babysteps.</p>]]></content:encoded>
</item>
<item>
  <title>Post: Parrot Babysteps 07 - Writing Subroutines</title>
  <link>https://randomgeekery.org/post/2009/10/parrot-babysteps-07-writing-subroutines/</link>
  <pubDate>Tue, 06 Oct 2009 00:00:00 -0700</pubDate>
  
  <guid>https://randomgeekery.org/post/2009/10/parrot-babysteps-07-writing-subroutines/</guid>
  <description>Introduction We accomplished quite a bit in parrot-babysteps-06-files-and-hashes. We figured out how to parse a 20 MB star catalog and search for information that we thought could be important. The only problem is that it was turning to spaghetti. Even though it had barely 100 lines of code, it was becoming a bigger challenge to figure out what was going on or how to add new features.
Today we’re going to streamline the code somewhat by wrapping that complexity in subroutines.</description>
   <category>post</category> 
   <category>post</category> 
   <category>parrot</category>  <category>learn</category>  <category>coolnamehere</category> 
  <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>We accomplished quite a bit in <a href="/post/2009/10/parrot-babysteps-06-files-and-hashes/">parrot-babysteps-06-files-and-hashes</a>.
We figured out how to parse a 20 MB star catalog and search for information that
we thought could be important. The only problem is that it was turning to
spaghetti. Even though it had barely 100 lines of code, it was becoming a bigger
challenge to figure out what was going on or how to add new features.</p>
<p>Today we&rsquo;re going to streamline the code somewhat by wrapping that complexity
in subroutines.  The <a href="/card/parrot/">Parrot</a> Book has a <a href="http://docs.parrot.org/parrot/latest/html/docs/book/pir/ch06_subroutines.pod.html">sizable chapter discussing subroutines</a>.
I won&rsquo;t be spending much time exploring the depths of subroutines, because
that would take me far beyond what is appropriate for a babystep. However, a
quick glance at the chapter should suggest that Parrot subroutines are quite
powerful and worth deeper exploration on your own.</p>
<h2 id="subroutines">Subroutines</h2>
<p>We&rsquo;ve been working with subroutines since <a href="/post/2009/07/parrot-babysteps-01-getting-started/">parrot-babysteps-01-getting-started</a> Every Parrot application has a subroutine tagged as <code>:main</code> to show that it contains the main logic for the program. Let&rsquo;s start adding our own supplementary subroutines.</p>
<p>Our first function will encapsulate the display of star highlights.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-07-01

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main

    load_bytecode &#39;String/Utils.pbc&#39;

    .const string DELIMITER  = &#39;,&#39;
    .local pmc    chomp
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local int    field_count
    .local int    current_field_index
    .local string current_field_name
    .local string current_field_value
    .local pmc    star_data
    .local pmc    star
    .local string star_name
    .local string star_spectrum
    .local pmc    sol
    .local string sol_spectrum
    .local int    matching_count
    .local int    unnamed_match_count

    chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;
    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    current_line  = chomp(current_line)
    field_names   = split DELIMITER, current_line
    field_count   = field_names

    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    current_field_index = 0
    sol = new &#39;Hash&#39;

  ASSIGN_NEXT_SOL_FIELD:
    if current_field_index &gt;= field_count goto FIND_MATCHING_STARS
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    sol[current_field_name] = current_field_value
    current_field_index &#43;= 1
    goto ASSIGN_NEXT_SOL_FIELD

  FIND_MATCHING_STARS:
    sol_spectrum = sol[&#39;Spectrum&#39;]
    matching_count = 0
    unnamed_match_count = 0
    # We want to show Sol&#39;s details as well as other matches.
    say_star_details(sol)

  LOAD_NEXT_STAR:
    unless data_file goto END
    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    current_field_index = 0
    star = new &#39;Hash&#39;

  ASSIGN_NEXT_STAR_FIELD:
    if current_field_index &gt;= field_count goto EXAMINE_STAR
    current_field_name = field_names[current_field_index]
    current_field_value = star_data[current_field_index]
    star[current_field_name] = current_field_value
    current_field_index &#43;= 1
    goto ASSIGN_NEXT_STAR_FIELD

  EXAMINE_STAR:
    star_spectrum = star[&#39;Spectrum&#39;]
    if star_spectrum == sol_spectrum goto REMEMBER_MATCH
    goto LOAD_NEXT_STAR

  REMEMBER_MATCH:
    matching_count &#43;= 1
    star_name = star[&#39;ProperName&#39;]
    if star_name goto DISPLAY_STAR_DETAILS
    unnamed_match_count &#43;= 1
    goto LOAD_NEXT_STAR

  DISPLAY_STAR_DETAILS:
    say_star_details(star)
    goto LOAD_NEXT_STAR

  END:
    close data_file
    print matching_count
    print &#34; stars exactly matched Sol&#39;s spectrum &#34;
    say sol_spectrum
    print unnamed_match_count
    say &#39; have no proper name&#39;

.end

.sub say_star_details
    .param pmc star

    .local string star_name
    .local string star_spectrum
    .local string star_distance

    star_name = star[&#39;ProperName&#39;]
    star_spectrum = star[&#39;Spectrum&#39;]
    star_distance = star[&#39;Distance&#39;]

    print &#34;&lt;Name: &#34;
    print star_name
    print &#34;, Spectrum: &#34;
    print star_spectrum
    print &#34;, Distance: &#34;
    print star_distance
    say &#34;&gt;&#34;
.end</code></pre>
</figure><p>To create a subroutine that will get used by your <code>:main</code> sub, all
you need to do is declare a <code>.sub</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub say_star_details
.end</code></pre>
</figure><p>I like my subroutine names to clearly describe the task being accomplished,
to minimize the guesswork when I come back to code later.</p>
<p>This subroutine accepts a single parameter: a Hash describing the star to be
printed. We learned <a href="/post/2009/09/parrot-babysteps-04-adding-command-line-arguments/">a few steps ago</a>
that the <code>.param</code> directive declares a parameter for your subroutine.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub say_star_details
    .param pmc star
.end</code></pre>
</figure><p>The subroutine body in this case is going to be a copy and paste of the
<code>DISPLAY_STAR_DETAILS</code> code chunk, along with declarations of <code>.local</code>
variables needed to make it work.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.sub say_star_details
    .param pmc star

    .local string star_name
    .local string star_spectrum
    .local string star_distance

    star_name = star[&#39;ProperName&#39;]
    star_spectrum = star[&#39;Spectrum&#39;]
    star_distance = star[&#39;Distance&#39;]

    print &#34;&lt;Name: &#34;
    print star_name
    print &#34;, Spectrum: &#34;
    print star_spectrum
    print &#34;, Distance: &#34;
    print star_distance
    say &#34;&gt;&#34;
.end</code></pre>
</figure><p>We no longer care about stellar distances in our main code, so we can safely
remove the <code>.local string star_distance</code> directive from <code>main</code>.</p>
<p>Now we can rewrite our code to display Sol&rsquo;s details. Remember that subroutines
require that their parameters be wrapped in parentheses.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># We want to show Sol&#39;s details as well as other matches.
say_star_details(sol)</code></pre>
</figure><p>We could have also wrapped <code>say_star_details</code> in quotes, but it&rsquo;s only required
when our subroutines have non-ASCII characters - that is, characters outside the
range of what we consider &ldquo;normal&rdquo; characters in the United States. Still, I won&rsquo;t
complain if you&rsquo;re devoted to good form and prefer to show those subroutine calls
as:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >&#39;say_star_details&#39;(sol)</code></pre>
</figure><p>The <code>DISPLAY_STAR_DETAILS</code> chunk becomes just a few lines:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >DISPLAY_STAR_DETAILS:
  say_star_details(star) # or &#39;say_star_details&#39;(star)
  goto LOAD_NEXT_STAR</code></pre>
</figure><p>Does it produce the same result as the code we ran before?</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-07-01.pir 
&lt;Name: Sol, Spectrum: G2V, Distance: 0.000004848&gt;
&lt;Name: Rigel Kentaurus A, Spectrum: G2V, Distance: 1.34749097181049&gt;
568 stars exactly matched Sol&#39;s spectrum G2V
567 have no proper name</code></pre>
</figure><p>It sure does. The code is still rather awkward, though. How about we add a
subroutine for transforming a line from the text file into star data?</p>
<h2 id="returning-values">Returning Values</h2>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-07-02

.loadlib &#39;io_ops&#39;

.sub &#39;main&#39; :main

    load_bytecode &#39;String/Utils.pbc&#39;

    .const string DELIMITER  = &#39;,&#39;
    .local pmc    chomp
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local pmc    star_data
    .local pmc    star
    .local string star_name
    .local string star_spectrum
    .local pmc    sol
    .local string sol_spectrum
    .local int    matching_count
    .local int    unnamed_match_count

    chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;
    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    current_line  = chomp(current_line)
    field_names   = split DELIMITER, current_line

    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    sol = extract_star_details(field_names, star_data)

  FIND_MATCHING_STARS:
    sol_spectrum = sol[&#39;Spectrum&#39;]
    matching_count = 0
    unnamed_match_count = 0
    # We want to show Sol&#39;s details as well as other matches.
    say_star_details(sol)

  LOAD_NEXT_STAR:
    unless data_file goto END
    current_line = readline data_file
    current_line = chomp(current_line)
    star_data    = split DELIMITER, current_line
    star         = extract_star_details(field_names, star_data)

  EXAMINE_STAR:
    star_spectrum = star[&#39;Spectrum&#39;]
    if star_spectrum == sol_spectrum goto REMEMBER_MATCH
    goto LOAD_NEXT_STAR

  REMEMBER_MATCH:
    matching_count &#43;= 1
    star_name = star[&#39;ProperName&#39;]
    unless star_name goto LOAD_NEXT_STAR
    if star_name goto DISPLAY_STAR_DETAILS
    unnamed_match_count &#43;= 1
    goto LOAD_NEXT_STAR

  DISPLAY_STAR_DETAILS:
    say_star_details(star)
    goto LOAD_NEXT_STAR

  END:
    close data_file
    print matching_count
    print &#34; stars exactly matched Sol&#39;s spectrum &#34;
    say sol_spectrum
    print unnamed_match_count
    say &#39; have no proper name&#39;

.end

.sub extract_star_details
    .param pmc headers
    .param pmc values

    .local pmc star
    .local int header_count
    .local string current_header
    .local string current_value
    .local int current_index

    current_index = 0
    header_count = headers
    star = new &#39;Hash&#39;

  ASSIGN_NEXT_STAR_FIELD:
    if current_index &gt;= header_count goto RETURN_STAR
    current_header = headers[current_index]
    current_value = values[current_index]
    star[current_header] = current_value
    current_index &#43;= 1
    goto ASSIGN_NEXT_STAR_FIELD


  RETURN_STAR:
    .return(star)
.end

.sub say_star_details
    # ...
.end</code></pre>
</figure><p>The code is starting to get a little long, so I am adopting the habit
of replacing subroutine blocks with <code># ...</code> when the code is unchanged from
the previous example.</p>
<p>Most of the code in our new <code>extract_star_details</code> subroutine looks familiar, but we do
have one noteworthy addition:</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >.return(star)</code></pre>
</figure><p>This directive hands the Hash we&rsquo;ve just built back to whoever called the function.</p>
<p>Is our application cleaner? Yes, a little bit. I&rsquo;m tired of having so many unnamed
stars, though. Let&rsquo;s add a little logic to attempt an alternate name if no proper
name is available.</p>
<h3 id="making-say_star_details-smarter">Making <code>say_star_details</code> Smarter</h3>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      ># example-07-03
.sub &#39;main&#39; :main

    load_bytecode &#39;String/Utils.pbc&#39;

    .const string DELIMITER  = &#39;,&#39;
    .local pmc    chomp
    .local string filename
    .local pmc    data_file
    .local string current_line
    .local pmc    field_names
    .local pmc    star_data
    .local pmc    star
    .local string star_spectrum
    .local pmc    sol
    .local string sol_spectrum
    .local int    matching_count

    chomp         = get_global [&#39;String&#39;;&#39;Utils&#39;], &#39;chomp&#39;
    filename      = &#39;hygxyz.csv&#39;
    data_file     = open filename, &#39;r&#39;
    current_line  = readline data_file
    current_line  = chomp(current_line)
    field_names   = split DELIMITER, current_line

    current_line = readline data_file
    current_line = chomp(current_line)
    star_data = split DELIMITER, current_line
    sol = extract_star_details(field_names, star_data)

  FIND_MATCHING_STARS:
    sol_spectrum = sol[&#39;Spectrum&#39;]
    matching_count = 0
    # We want to show Sol&#39;s details as well as other matches.
    say_star_details(sol)

  LOAD_NEXT_STAR:
    unless data_file goto END
    current_line = readline data_file
    current_line = chomp(current_line)
    star_data    = split DELIMITER, current_line
    star         = extract_star_details(field_names, star_data)

  EXAMINE_STAR:
    star_spectrum = star[&#39;Spectrum&#39;]
    if star_spectrum == sol_spectrum goto REMEMBER_MATCH
    goto LOAD_NEXT_STAR

  REMEMBER_MATCH:
    matching_count &#43;= 1
    say_star_details(star)
    goto LOAD_NEXT_STAR

  END:
    close data_file
    print matching_count
    print &#34; stars exactly matched Sol&#39;s spectrum &#34;
    say sol_spectrum
.end

.sub extract_star_details
    # ...
.end

.sub say_star_details
    .param pmc star

    .local string star_name
    .local string star_spectrum
    .local string star_distance

    star_name = star[&#39;ProperName&#39;]
    star_spectrum = star[&#39;Spectrum&#39;]
    star_distance = star[&#39;Distance&#39;]

    if star_name goto DISPLAY_DETAILS

  TRY_GLIESE:
    .local string gliese_number
    gliese_number = star[&#39;Gliese&#39;]
    unless gliese_number goto TRY_BAYER_FLAMSTEED
    star_name = &#39;Gliese &#39; . gliese_number
    goto DISPLAY_DETAILS

  TRY_BAYER_FLAMSTEED:
    .local string bayer_flamsteed
    bayer_flamsteed = star[&#39;BayerFlamsteed&#39;]
    unless bayer_flamsteed goto TRY_HR
    star_name = &#34;BF &#34; . bayer_flamsteed
    goto DISPLAY_DETAILS

  TRY_HR:
    .local string hr_id
    hr_id = star[&#39;HR&#39;]
    unless hr_id goto TRY_HD
    star_name = &#34;HR &#34; . hr_id
    goto DISPLAY_DETAILS

  TRY_HD:
    .local string hd_id
    hd_id = star[&#39;HD&#39;]
    unless hd_id goto USE_STAR_ID
    star_name = &#34;HD &#34; . hd_id
    goto DISPLAY_DETAILS

  TRY_HIP:
    .local string hip_id
    hip_id = star[&#39;HIP&#39;]
    unless hip_id goto USE_STAR_ID
    star_name = &#34;HIP &#34; . hip_id
    goto DISPLAY_DETAILS

  USE_STAR_ID:
    .local string star_id
    star_id = star[&#39;StarID&#39;]
    star_name = &#34;HYG &#34; . star_id
    goto DISPLAY_DETAILS

  DISPLAY_DETAILS:
    print &#34;&lt;Name: &#34;
    print star_name
    print &#34;, Spectrum: &#34;
    print star_spectrum
    print &#34;, Distance: &#34;
    print star_distance
    say &#34;&gt;&#34;
.end</code></pre>
</figure><p>Now <em>this</em> version of the app displays everything along with some kind of
designation. The order I look for names is arbitrary, and is based
roughly in order of how familiar they looked to me. The tediousness of
determining which reference to use has been hidden away in the <code>say_star_details</code>
subroutine, and consists of simply checking each field for a value until
something useful is found. I knew there would be some kind of name to display,
so I removed the name-counting functionality from <code>main</code>.</p>
<figure class="highlight">
  <pre tabindex="0"
    ><code class="language-" data-lang=""
      >$ parrot example-07-03.pir | more
# ... much text omitted
&lt;Name: HYG 117782, Spectrum: G2V, Distance: 139.275766016713&gt;
&lt;Name: HD 224693, Spectrum: G2V, Distance: 94.0733772342427&gt;
568 stars exactly matched Sol&#39;s spectrum G2V</code></pre>
</figure><h2 id="conclusion">Conclusion</h2>
<p>Right. Our script has grown to the point where it shows every <code>G2V</code> star
in the HYG database, and some of the complexity of this task has been
tucked away behind subroutines. Is there more to be done? You bet! I would
love to add user search features to the code. That&rsquo;s going to a fair step
on its own, so I think I will close my Vim window and push this page.</p>
]]></content:encoded>
</item>
</channel>
</rss>
